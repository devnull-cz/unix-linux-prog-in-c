
include(`macros.m4')

%%%%%

\begin{slide}
\sltitle{Hierarchical file system}
\begin{center}
\input{img/tex/fstree.pstex_t}
\end{center}
\end{slide}

\begin{itemize}
\item A \emph{file system} is a data structure to control how data is stored and
retrieved.  Without it the stored data would have no structure, ownership, etc.
The filesystem structure provides for storing directories (folders), files,
metadata, etc.
\item Each filesystem has a specific structure type it uses, for example
\texttt{ext4} (Linux specific), \texttt{XFS} (used on Linux but coming from SGI
IRIX), \texttt{JFS} (used on Linux but came from IBM AIX), \texttt{UFS} (BSD
systems), \texttt{FAT32} (Win), \texttt{ZFS} (Solaris born, then ported to other
systems), \texttt{APFS} (macOS and iOS since 2017), etc.  A filesystem can be
either used on local or remote storage, and in case of a remote storage network
filesystem protocols like \texttt{NFS} or \texttt{AFS} are used to access the
data.  Note that these network filesystems do not define the filesystem
structure itself, they only provide for accessing existing filesystems remotely.
Each filesystem also has its limits, a largest file size or the maximum size of
the filesystem itself, for example.
\item Unix does not have A, B, C, D\dots disks as Windows and other systems.
All filesystems are mounted to a single directory hierarchy on any Unix system,
as shown on the slide where you can see the root filesystem and three other
fileystems, mounted on \texttt{/usr}, \texttt{/dev/tty}, and \texttt{/home}
directories.  You could also further mount other filesystems on directories that
are part of these non-root filesystems.
\item Each filesystem mounted to the common hierarchy may be formatted using a
different filesystem type.  However, that is largely transparent to a user
traversing the hierarchy.  There are some exceptions though.  For example,
\texttt{FAT32} does no provide user and access rights for files so those are
faked when such filesystem is mounted.
\item Upon the system boot, the root filesystem is mounted first, other
filesystems are later mounted via the \texttt{mount} command, usually from
specific startup services based on the system you use.  The startup services
sometimes use file \texttt{/etc/fstab} as a source of information about what
filesystems to mount.  You can also use \texttt{mount} manually.  To unmount a
filesystem, the \texttt{umount} command is used.
\item Some systems also provide for auto mounting where filesystems are mounted
during the first access attempt, and may be automatically unmounted after a
period of inactivity.  Such functionality is usually called an
\emph{automounter}.  See \texttt{autofs}, \texttt{automount}, or \texttt{amd}
for more information.
\end{itemize}

%%%%%

\pdfbookmark[1]{typical layout of directories}{hier}

\begin{slide}
\sltitle{Typická skladba adresáøù}
\begin{tabular}{l@{\hspace{3ex}\dots\hspace{3ex}}l}
\texttt{/bin} & základní systémové pøíkazy\\
\texttt{/dev} & speciální soubory (zaøízení, devices)\\
\texttt{/etc} & konfiguraèní adresáø\\
\texttt{/lib} & základní systémové knihovny\\
\texttt{/tmp} & veøejný adresáø pro doèasné soubory\\
\texttt{/home} & koøen domovských adresáøù\\
\texttt{/var/adm} & administrativní soubory (ne na BSD) \\
\texttt{/usr/in{}clude} & hlavièkové soubory pro C\\
\texttt{/usr/local} & lokálnì instalovaný software\\
\texttt{/usr/man} & manuálové stránky\\
\texttt{/var/spool} & spool (po¹ta, tisk,...)
\end{tabular}
\end{slide}

\begin{itemize}
\item v \texttt{/bin}, \texttt{/lib}, \texttt{/sbin} jsou pøíkazy a knihovny
potøebné pøi startu systému, kdy je pøipojen pouze koøenový filesystém. Ostatní
pøíkazy a knihovny jsou typicky v \texttt{/usr/bin}, \texttt{/usr/lib} a
\texttt{/usr/sbin}. \texttt{/usr} bývá èasto samostatný filesystém, èím¾ jeho
obsah není dostupný bìhem startu systému.
\item \texttt{s} v \texttt{sbin} znaèí ,,system'', ne SUID. Jsou to binárky, u
kterých se pøedpokládá, ¾e je bì¾ný u¾ivatel nebude typicky potøebovat.
\item podstrom \texttt{/usr} obsahuje soubory, které se nemìní pøi bì¾ném
provozu a nejsou závislé na konkrétním poèítaèi. Proto by mìl jít sdílet
read-only. Na své stanici doma ho ale vìt¹inou budete mít read-write.
\item \texttt{/lib} typicky obsahuje knihovny potøebné pro programy z koøenového
svazku. Pokud by v¹echny knihovny byly v \texttt{/usr/lib} a \texttt{/usr} byl
samostatný svazek, problém s pøipojením \texttt{/usr} by kompletnì ochromil celý
systém, proto¾e by ne¹lo spustit nic. Nìkdy to systémy øe¹í tak, ¾e koøenový
svazek obsahuje sadu základních programù, které jsou staticky slinkované.
Napøíklad FreeBSD má takové binárky v adresáøi \texttt{/rescue}, má ale i
samostatné adresáøe \texttt{/lib} a \texttt{/usr/lib}.
\item v podstromu \texttt{/var} jsou data, která se za provozu mìní a jsou
specifická pro ka¾dý poèítaè.
\item rùzné systémy i instalace jednoho systému se èasto li¹í.
\item \texttt{hier(7)} na FreeBSD a Linuxu popisuje adresáøovou hierarchii
tohoto systému, Solaris má \texttt{filesystem(5)}.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Pøístup k periferním zaøízením}
\begin{itemize}
\item adresáø \texttt{/dev} obsahuje speciální soubory zaøízení.
Proces otevøe speciální soubor systémovým voláním \texttt{open()} a
dále komunikuje se zaøízením pomocí volání \texttt{read()},
\texttt{write()}, \texttt{ioctl()}, apod. 
\item speciální soubory se dìlí na 
    \begin{itemize2}
    \item \emsl{znakové} \dots{} data se pøená¹í pøímo mezi procesem a
    ovladaèem zaøízení, napø. sériové porty 
    \item \emsl{blokové} \dots{} data prochází systémovou
    vyrovnávací pamìtí (buffer cache) po blocích pevnì dané
    velikosti, napø. disky 
    \end{itemize2}
\item speciální soubor identifikuje zaøízení dvìma èísly 
    \begin{itemize2}
    \item \emsl{hlavní (major) èíslo} \dots{} èíslo ovladaèe v jádru 
    \item \emsl{vedlej¹í (minor) èíslo} \dots{} èíslo v rámci
    jednoho ovladaèe
    \end{itemize2}
\end{itemize}
\end{slide}

\begin{itemize}
\item vyrovnávací pamìti (cache) urychlují periferní operace. Pøi ètení se data
hledají nejprve v~bufferu. Teprve kdy¾ nejsou k dispozici, tak se ètou z disku.
Pøi pøí¹tím ètení stejného bloku jsou data v bufferu. Pøi zápisu se data ulo¾í
do bufferu. Na disk je systém pøepí¹e pozdìji. Lze si vynutit i okam¾itý zápis
dat na disk. Dnes ji¾ cache typicky není samostatná struktura, v¹e je zastøe¹eno
modulem vitruální pamìti.
\item disky v UNIXu jsou obvykle pøístupné pøes znakové (pou¾ívané pøi
\texttt{mkfs} -- vytvoøení svazku -- a \texttt{fsck} -- kontrola konzistence) i
blokové rozhraní (pou¾ívané pøi normálním provozu systému souborù). Nìkteré
systémy (FreeBSD) ale u¾ v \texttt{/dev} vùbec soubory pro bloková zaøízení
nemají, pouze znaková.
\item døíve musel administrátor systému po zmìnì hardwarové konfigurace upravit
obsah adresáøe \texttt{/dev} skriptem \texttt{MAKEDEV} nebo ruènì. Dnes (Linux,
IRIX, Free\-BSD, Solaris, \dots) ji¾ speciální soubory dynamicky vznikají a
zanikají podle toho, jak jádro detekuje pøidání nebo odebrání hardwarových
komponent (viz \emph{devfs} na stranì \pageref{DEVFS}).
\item okam¾itý zápis na disk lze vynutit pøes \texttt{O\_DIRECT} command ve
volání \texttt{fcntl}.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Fyzické ulo¾ení systému souborù}
\begin{itemize}
\item \emsl{systém souborù} (svazek, \emsl{filesystem}) lze vytvoøit na: 
    \begin{itemize2}
    \item \emsl{oddílu disku} (\emsl{partition}) -- èást disku, na jednom
    disku mù¾e být více oddílù 
    \item \emsl{logickém oddílu} (\emsl{logical volume}) -- takto lze spojit
    více oddílù, které mohou být i na nìkolika discích, do jednoho svazku. 
    \end{itemize2}
\item dal¹í mo¾nosti: striping, mirroring, RAID
\end{itemize}
\begin{center}
\input{img/tex/partitions.pstex_t}
\end{center}
\end{slide}

\begin{itemize}
\item výraz systém souborù se pou¾ívá v nìkolika významech:
    \begin{itemize}
    \item jeden filesystém, tj. to, co vyrobí pøíkaz \texttt{mkfs}
    \item celá hierarchie pøipojených svazkù v systému (výstup pøíkazu
    \texttt{mount})
    \item zpùsob organizace svazku (tj. typ fs) a tomu odpovídající
    modul jádra, který s daty manipuluje (UFS2, Ext3, XFS, ...)
    \end{itemize}
\item striping je od slova stripe, ne strip; podle toho se také
vyslovuje. Znamená, ¾e za sebou následující bloky dat se ukládají
paralelnì na rùzné disky a tím se zvy¹uje pøenosová rychlost.
\item mirroring ukládá kopie dat více diskù pro pøípad havárie nìkterého z nich.
\item paritní disky: data se ukládají na dva disky, na tøetí se ukládá XOR
prvních dvou, po havárii libovolného disku jsou v¹echna data stále èitelná.
\item jednotlivé úrovnì RAID (Redundant Array of Inexpensive Disks)
zahrnují striping, mirroring a vyu¾ití paritních diskù.
\item na terminologii je tøeba dát velký pozor. Napø. to, co se v
DOS svìtì nazývá \emph{partition}, se v BSD nazývá \emph{slice}.
Tam jsou pak partitions definovány v rámci jednoho slice a v nich se
vytváøejí filesystémy.
\item pokud vás to zajímá nebo se s tím setkáváte v praxi, doporuèuji va¹í
pozornosti ZFS, co¾ je filesystém a mana¾er logických oddílù v jednom. Ze
Solarisu se ji¾ dostal do FreeBSD od verze 7.0. Mù¾ete okam¾itì zapomenout na
jednotlivé disky, co je dùle¾ité je pouze celková disková kapacita v systému.
\end{itemize}

%%%%%

\pdfbookmark[1]{UNIX System V file system}{sysVfs}

\begin{slide}
\sltitle{Organizace systému souborù \texttt{s5}}
\begin{center}
\input{img/tex/s5.tex}
\end{center}
\end{slide}

\begin{itemize}
\item pùvodní UNIXový systém souborù standardnì pou¾ívaný do verze
System V Release 3; v BSD se primárnì pou¾íval do verze 4.1
\item vlastnosti:
    \begin{itemize}
    \item bloky délky 512, 1024 nebo 2048 bajtù 
    \item jediný (neduplikovaný) superblok
    \item datový prostor pevnì rozdìl{}ený na oblast \emph{i-uzlù} a
    oblast \emph{datových blokù}
    \item pøi velikosti bloku 1024 bajtù byla teoretická velikost
    filesystému pøes 16 GB
    \end{itemize}
\item \emph{boot block} -- pro ulo¾ení zavadìèe OSu
\item \emph{superblok} -- základní informace o svazku: poèet blokù pro i-uzly,
poèet blokù svazku, seznam volných blokù (pokraèuje ve volných blocích), seznam
volných i-uzlù (po vyèerpání se prohledává tabulka i-uzlù), zámky pro seznamy
vol\-ných blokù a i-uzlù, pøíznak modifikace pou¾ívaný pro kontrolu korektního
odpojení svazku, èas poslední aktualizace, informace o zaøízení
\item \emph{i-uzel} -- typ souboru, pøístupová práva, vlastník, skupina, èasy
posledního pøístupu, modifikace dat a modifikace i-uzlu, poèet odkazù na soubor,
velikost souboru, 10 odkazù na datové bloky a 3 odkazy na nepøímé bloky. Pozor
na to, ¾e èas vytvoøení souboru není ulo¾en.
\item maximální velikost souboru: 2113674 blokù, tj. pøibli¾nì 1 GB pøi pou¾ití
blokù velikosti 512 B
\item jména souborù -- max. 14 znakù (14 + 2 = 16, tedy mocnina dvou a tedy
bezproblémové ulo¾ení adresáøových polo¾ek do blokù)
\item pøi pou¾ití tohoto filesystému byla výkonnost diskù vyu¾ita jen cca na 2\%
a rychlost ètení byla v øádu jen nìkolika desítek kilobajtù za sekundu (!!!)
\item pro srovnání -- MS-DOS 2.0 z roku 1983 podporoval pouze FAT12, poèítající
s maximální velikostí filesystému 16 MB. Velikost svazku do 2 GB byla umo¾nìna
a¾ ve verzi 4.0 (1988); tato verze zároveò zavedla diskové vyrovnávací pamìti,
tedy to, co UNIX má od svého vzniku v roce 1970.
\end{itemize}


%%%%%

\begin{slide}
\sltitle{Navigace v adresáøové struktuøe}
\begin{center}
\input{img/tex/nav_dir.pstex_t}
\end{center}
\end{slide}

\begin{itemize}
\item kdy¾ cesta zaèíná znakem '\texttt{/}', zaèíná navigace v koøenovém
adresáøi, jinak zaène v~pracovním adresáøi procesu.
\item koøenový adresáø má typicky èíslo 2. 0 je pro oznaèení prázdného uzlu a
1 byla døíve pou¾ívaná pro soubor, do kterého se vkládaly vadné bloky, aby je
systém u¾ dále nepou¾íval.


\item cesta ve které je více lomítek za sebou je stále platná, tj.
\texttt{///a///b///c} je ekvivaletní \texttt{/a/b/c}.
\end{itemize}


%%%%%

\pdfbookmark[1]{links and their properties}{links}

\begin{slide}
\sltitle{Linky}
\begin{center}
\input{img/tex/links.tex}
\end{center}

Hard linky lze vytváøet pouze v rámci jednoho (logického)
filesystému.
\end{slide}

\begin{itemize}
\item to co ``normálnì'' vidíte pøi výpisu adresáøù jsou vìt¹inou hardlinky,
tak¾e rozdìl{}ení není na soubory, hardlinky a symbolické linky. Co se týèe
souborù, jsou \emsl{pouze} hardlinky a symlinky.

\begin{description}
\item[hardlink]~

    \begin{itemize}
    \item odkaz na stejný i-uzel
    \item vlastnì druhé jméno souboru
    \item není rozdíl mezi originálem a hardlinkem
    \item lze vytváøet jen v rámci filesystému
    \item nelze vytváøet pro adresáøe
    \end{itemize}
\item [symbolický link (symlink, softlink)]~

    \begin{itemize}
    \item pouze odkaz na skuteènou cestu k souboru jiného typu (\texttt{ls -l}
    jej o\-zna\-èu\-je '\texttt{l}'), tj. symbolický link je typem odli¹ný od
    bì¾ného souboru a jeho data obsahují obyèejný øetìzec -- jméno cesty, a»
    ji¾ relativní nebo absolutní
    \item odli¹né chování pro originál a link (napø. pøi mazání)
    \item pozor na relativní a absolutní cesty pøi pøesouvání
    symbolického linku
    \item mù¾e ukazovat i na adresáø nebo na neexistující soubor
    \end{itemize}
\end{description}

\item nejjednodu¹¹í zpùsob jak si ovìøit, zda dané dva linky ukazují na
stejný soubor na disku je pou¾ít \texttt{-i} pøepínaè pøíkazu
\texttt{ls}, který vám uká¾e èíslo indexového uzlu.

\begin{verbatim}
$ ls -i /etc/passwd 
172789 /etc/passwd
\end{verbatim}
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Vylep¹ení systému souborù}
\begin{itemize}
\item cíl: sní¾ení fragmentace souborù, omezení pohybu hlav disku umístìním
i-uzlù a datových blokù blí¾ k sobì 
\item UFS (Unix File System), pùvodnì Berkeley FFS (Fast File System) 
\item èle{}nìní na skupiny cylindrù, ka¾dá skupina obsahuje 
    \begin{itemize}
    \item kopii superbloku 
    \item øídicí blok skupiny 
    \item tabulku i-uzlù 
    \item bitmapy volných i-uzlù a datových blokù 
    \item datové bloky 
    \end{itemize}
\item bloky velikosti 4 a¾ 8 kB, men¹í èásti do fragmentù blokù 
\item jména dlouhá 255 znakù
\end{itemize}
\end{slide}

\begin{itemize}
\item superblok v ka¾dé cylinder skupinì posunut tak, aby superbloky nebyly na
stejné plotnì.
\item dal¹í typy filesystémù: UFS2, Ext3, ReiserFS, XFS, ZFS aj.
\item v \url{http://mff.devnull.cz/pvu/common/docs/filesystems.ps} je
po\-rov\-ná\-ní osmi rùzných filesystémù podle rùzných implementaèních
kritérií; nezahrnuje v sobì ale vývoj posledních let.
\item UFS byl stále 32-bitový, co¾ se odrá¾elo na maximální délce souboru i na
maximální velikosti filesystému. (Oznaèení file systému jako 32-bitového
znamená, ¾e èísla i-uzlù jsou reprezentována jako 32-bitová. To pak dává
teoretický limit pro velikost filesystému.)
\item ¾urnálování (XFS, Ext3, ReiserFS) -- snaha o zmen¹ení nebezpeèí ztráty
dat v pøípadì havárie, urychlení zotavení po havárii
\item ZFS -- moderní 128-bitový filesystém vyvinutý v Sun Microsystems, od
Solarisu 10, teï ji¾ také v FreeBSD 7.
\end{itemize}


%%%%%

\begin{slide}
\sltitle{Vývoj ve správì adresáøových polo¾ek}
\begin{itemize}
\item maximální délka jména souboru 14 znakù nebyla dostaèující
\item FFS -- délka a¾ 255; ka¾dá polo¾ka zároveò obsahuje i její délku
\item nové filesystémy pou¾ívají pro vnitøní strukturu adresáøù rùzné varianty
B-stromù
    \begin{itemize}
    \item výraznì zrychluje práci s adresáøi obsahující velké
    mno¾ství souborù
    \item XFS, JFS, ReiserFS, \dots
    \end{itemize}
\item UFS2 zavádí zpìtnì kompatibilní tzv. \emph{dirhash} pro zrychlení
pøístupu k adresáøùm s velkým poètem souborù
\end{itemize}
\end{slide}

\begin{itemize}
\item \emph{dirhash} pracuje tak, ¾e pøi prvním pøeètení adresáøe se vytvoøí v
pamìti hash struktura, následné pøístupy do adresáøe jsou pak srovnatelné se
systémy pou¾ívající B-stromy. Tímto zpùsobem je dosa¾eno zlep¹ení bez toho,
aby se mìnila struktura filesystému na disku. Taková vylep¹ení ale nelze
v implementaci filesysému dìlat do nekoneèna, nakonec je typicky nutná
zmìna on-disk formátu pro adaptaci na výkonostní po¾adavky (nebo pøechod
na jiný filesystém).
\item malé soubory se èasto ukládají v i-nodech, èím¾ se u¹etøí dal¹í pøístupy
na disk
\end{itemize}

%%%%%

\pdfbookmark[1]{Virtual File System}{VFS}

\begin{slide}
\sltitle{Virtual File System}
\begin{center}
\input{img/tex/vfs.pstex_t}
\end{center}
\end{slide}

\begin{itemize}
\item The \emph{FFS} filesystem introduced in 4.2BSD was historically the second
unix filesystem. Some manufacturers of unix system started to prefer its
considering its better performance and new features, others remained with 
\emph{s5fs} from compatibility reasons. This deepened the problem with already
insufficient interoperability between different unix systems. For some
applications neither of these filesystems was enough. Gradually the need to work
with non-unix systems started appearing, e.g. with \emph{FAT}. With growing
popularity of computer networks the demand for file sharing between systems
started to increase. This lead to the inception of distributed filesystems
-- e.g. \emph{NFS} (Network File System).
\item Given the above described situation it was just a matter of time when
fundamental changes in the filesystem infrastructure will happen to support
multiple filesystem types simultaneously. Several different implementations from
multiple manufacturers were made; in the end the de facto standard became
the \emph{VFS/vnode} architecture from Sun Microsystems. Today practically all
unix u{}nix-like systems support VFS, even though with often non-compatible
changes. VFS appeared for the first time in 1985 in Solaris 2.0;
soon it was adopted by BSD -- FFS with VFS support started to be called UFS.
\item the main idea: for each open file there is a \texttt{file} structure;
it would be actually one slot in the already known system table of open files.
This shows to \emph{vnode} (\emph{virtual node}). Vnode contains one part which
is independent on given file system and one part dependent that could be e.g.
the \emph{inode} structure. This is specific for each type of file system.
\emsl{Each file system type implements concrete set of functions for individual
file operations}. This set is referenced by each vnodes corresponding to given
file system. \emsl{This set of functions define vnode interface.} When e.g.
\texttt{open} is called, the kernel will call the corresponding implementation
depending on file system type (e.g. from the \emph{ext2fs} module).
Implementation dependent part of vnode structure is accessible only from
functions of given filesystem; for kernel it is opaque. Next slide will shown
another set of functions that works with filesystems themselves.
\emsl{This set defines VFS interface.}
These \emsl{two sets together} constitute the vnode/VFS interface, generally
referred to as VFS.
\item For special file types the situation is a bit more complicated, in SVR4
the \texttt{file} structure points to \emph{snode}
(\emph{shadow-special-vnode}), that defines operations with a device (using the
\emph{spec} filesystem) and using the \texttt{s\_realvp} pointer it refers to
real vnode for the operations with the special file; this file is necessary for
example for checking file access rights. Each device can have multiple special
files, hence more snodes and corresponding real vnodes. All such snodes for one
device have the \texttt{s\_commonvp} pointer to one common snode, this is
however not captured in the picture. When opening a special file, an item
corresponding to the special file is searched in hash table of snodes of opened
devices according to major and minor device number. If the snode is not found,
new one is created. This snode will be then used for operations with the device.
More in [Vahalia].
\end{itemize}

%%%%%

\pdfbookmark[1]{file system hierarchy}{fshier}

\begin{slide}
\sltitle{File system hierarchy}
\begin{center}
\input{img/tex/mount.pstex_t}
\end{center}
\end{slide}

\begin{itemize}
\item The \texttt{vfs} structure contains implementation independent
information about given filesystem, similarly to how vnode works for files.
This structure represents once concrete physical filesystem, currently mounted
to the hierarchy of files. In this linked list there can be more structures of
the same filesystem type.
\item \texttt{rootvfs} -- root file system reference
\item \texttt{vfsops} -- function table for given file system type
\item \texttt{vfssw[]} -- array of pointers to the \texttt{vfsops} tables for
all file system types supported by the system. This table is used for selection
based on filesystem type upon \texttt{mount} syscall.
\item \texttt{v\_vfsp} -- reference from vnode to filesystem (the \texttt{vfs}
structure), on which the file represented by the vnode lies
\item \texttt{v\_vfsmountedhere} -- only in vnode representing a mount point
(directory where root of different file system is mounted); points to
the \texttt{vfs} structure represented mounted filesystem
\item \texttt{v\_vnodecovered} -- pointer to the vnode of directory where
the filesystem is mounted to
\end{itemize}

%%%%%

\begin{slide}
\sltitle{System view of open files II.}
\begin{center}
\input{img/tex/open_files.pstex_t}
\end{center}
\end{slide}

\begin{itemize}
\item The \texttt{proc} and \texttt{user} strucures are created by the kernel
for each process. They contain service information about the process.
\item The \texttt{ufchunk} structure contains \texttt{NFPCHUNK} (usually 24)
\emph{file descriptors}, after it is full new \texttt{ufchunk} is allocated.
\item The \texttt{file} structure (\emph{file opening}) contains the mode
of file (whether it is opened for reading, writing, etc.), number of descriptors
that refers to it, the \texttt{vnode} pointer and file position.
One opening of file can be shared by multiple file descriptors,
if the original descriptor was copied e.g. with the \texttt{fork()}
or \texttt{dup()} syscalls.
\item The \texttt{cred} structure contains user and group identity of the
process that opened the file.
\item One vnode corresponding to one file can be shared by multiple file
structures if given file was opened multiple times.
\item Not all vnodes are associated with the table of opened files.
E.g. when executing a program it is necessary to access the executable file and
hence a vnode is allocated for that.
\end{itemize}


%%%%%

\pdfbookmark[1]{filesystem consistency check and repair}{fsck}

\begin{slide}
\sltitle{Filesystem consistency check and repair}
\setlength{\baselineskip}{0.8\baselineskip}
\begin{itemize}
\setlength{\itemsep}{0ex}
\item If a filesystem is not correctly unmounted before the system is halted,
the data can be inconsistent.
\item The \texttt{fsck} command is used to check and correct file system.
It tests progressively tests possible inconsistencies:
    \begin{itemize}
    \setlength{\itemsep}{0ex}
    \item multiple references to the same block
    \item references to blocks outside of data region of given file system
    \item incorrect number of inode references
    \item incorrect size of files and directories
    \item invalid inode format
    \item blocks that are neither used or free
    \item invalid directory contents
    \item invalid superblock contents
    \end{itemize}
\item the \texttt{fsck} operation is time consuming.
\item journaling (e.g. XFS in IRIXu, Ext3 in Linux) a transactional (ZFS)
filesystems do not need \texttt{fsck}.
\end{itemize}
\end{slide}

\begin{itemize}
\item The data is written to the drives from the memory with some delay.
To save all file system buffers the \texttt{sync()} syscall can be used.
The buffers are saved periodically by special system process (or daemon).
\item The \texttt{fsck} command only checks metadata. If a data corruption
happened it cannot tell, let alone do something about it.
\item Exaple of \texttt{fsck} run on \emsl{unmounted} filesystem:
\begin{verbatim}
toor@shewolf:~# fsck /dev/ad0a 
** /dev/ad0a
** Last Mounted on /mnt/flashcard
** Phase 1 - Check Blocks and Sizes
** Phase 2 - Check Pathnames
** Phase 3 - Check Connectivity
** Phase 4 - Check Reference Counts
** Phase 5 - Check Cyl groups
24 files, 8848 used, 12951 free (7 frags, 1618 blocks, 0.0% fragmentation)
\end{verbatim}
\end{itemize}


%%%%%

\pdfbookmark[1]{more ways for ensuring filesystem consistency}{fsconsistency}

\begin{slide}
\sltitle{More ways for ensuring filesystem consistency}
\setlength{\baselineskip}{0.8\baselineskip}
\begin{itemize}
\setlength{\itemsep}{0ex}
\item traditional UFS -- synchronous metadata writes
    \begin{itemize}
    \setlength{\itemsep}{0ex}
    \item an application creating new file is waiting till the inode is
    initialized on disk; these operations are done with disk speed, not CPU
    speed
    \item however asynchronous writes more often cause metadata inconsistencies
    \end{itemize}
\item solutions to metadata inconsistency problem:
    \begin{itemize}
    \setlength{\itemsep}{0ex}
    \item \emph{journalling} -- one group of operations dependent on each other
    is written to a journal first; if a problem is encountered the journal can
    be ``replayed''
    \item metadata blocks are written to non-volatile memory first
    \item \emph{soft-updates} -- follows dependencies between pointers to disk
    structures and writes the data using the \emph{write-back} method so that
    the data are always consistent on disk.
    \item \emph{transactions}
    \end{itemize}
\end{itemize}
\end{slide}

\begin{itemize}
\item filesystem \emph{metadata} = inodes, directories, free block
maps
\item \emph{ext2} uses asynchronous metadata writes even by default and when
in synchronous mode it is much slower to UFS.
\item Dependent operations are for example deleting an item from directory and
deleting disk inode. If the inode is deleted first and then the directory entry
then if there is outage between these two operations then inonsistency follows
-- the link points to disk file that does not exist. It is not a problem to
avoid this when using synchronous metadata writes (we know when a what is being
written, the ordering of writes is therefore under our control) however when
using the write-back method it is necessary to solve dependencies of the blocks
because with classic synchronization of cache buffers the kernel is not
interested in which blocks is written first.
\item Often the block dependencies for a cycle. Soft updates can recognize sych
cycle and break it by performing \emph{roll-back} and after the write is done it
performs \emph{roll-forward}.
\item The soft updates performance is comparable to that of UFS with
asynchronous metadata writes.
\item Theoreticall soft updates guratantee that it is not necessary to use
\texttt{fsck} after the reboot, i.e. that the filesystem is in bootable state.
It is however necessary to use so called \emph{background fsck} for correcting
non-grave errors -- this is considered to be one of the big drawbacks of soft
updates, especially given how sizes of disks grow over time. Example of an error
that does not block booting would be a block that is marked as used however is
not used by any file.
\item soft updates are not always recommended for the root filesystem.
The problem is that metadata loss on root file system (see the 30 second
period of writes) can be more dangerous than in \texttt{/usr}, \texttt{/home}
etc. Another disadvantage is that after deleting huge file soft updates do not
free up the space immediately.
\item Example: it is necessary 4 writes for secure rename operations when using
synchronous writes -- increase the number of references in inode, create new
directory entry, delete old entry, decrease the number of references.
If a system goes down between each of these a dangerous situation will ensue.
For example 2 references from directories to inode with reference count of 1 is
a problem because after deleting one of the references it would look like the
file is still on disk, when its data has been deleted already.
It is not hard to imagine what would it mean if the file contained important
data -- e.g. backup.
Opposite situation, i.e. one reference to inode with reference count equal 2 is
not correction situation either however it does not pose a threat to mount the
filesystem and normally use it. In the worst case the file looks as it is no
longer on disk while it still exists. For soft updates the rename operation will
form a cycle because it is necessary to write the increased reference count
first, then directory blocks and then decreased reference. And because
increase/decrease is done for the same inode, then for the write it is necessary
to do roll-back to (say) 2, write inode to disk, write directory blocks and then
roll-forward to reference of 1. During this operation a lock is held for the
inode so that no one will read older data. It is simple to show that it is not
possible to write any of these 3 blocks in a cycle to match the end of the
rename operation so that the roll-back is truly needed -- we could consider that
the inode did not really change and it is not necessary to decide whether to
write it or not; the write of directory reference without increasing reference
count in the inode could get us into situation which is descibed above.
\end{itemize}

\endinput
