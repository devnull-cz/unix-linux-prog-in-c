
changequote([[[, ]]])

\pagebreak
\pdfbookmark[0]{access rights, peripheal devices, file system}{soubory}

\begin{slide}
\sltitle{Contents}
\slidecontents{3}
\end{slide}

\begin{slide}
\sltitle{Users and groups}
\begin{center}
\framebox{\texttt{beran:x:1205:106:Martin Beran:/home/beran:/bin/bash}}
\end{center}
\vspace{2ex}

\emsl{The fields, in order from left to right:} user name, 
hashed password (today in \texttt{/etc/shadow} or elsewhere), user ID (aka UID);
primary group ID (aka GID), full name, home directory, login shell

Note that a superuser (root) has always UID 0.

\vspace{2ex}
\begin{center}
\framebox{\texttt{sisal:*:106:forst,beran}}
\end{center}
\vspace{2ex}

\emsl{The fields, in order from left to right:} group name, group password (not
used today), group ID (GID), list of group members
\end{slide}

\begin{itemize}
\item User information in files \texttt{/etc/passwd} and \texttt{/etc/group} are
processed by various system programs, like \texttt{login} or \texttt{su}.
The kernel knows nothing about these files as it only uses numeric
representation of users and groups.
\item Passwords are long gone from \texttt{/etc/passwd}, they are stored some
place else, for example in \texttt{/etc/shadow}, which is not readable to an
uprivileged user.  The passwords are also salted and then hashed.  On BSD based
systems, eg. FreeBSD or macOS, instead of \texttt{/etc/shadow},
\texttt{/etc/master.passwd} database is used.
\item If \texttt{/etc/shadow} does exist, it is structured in a similar way as
\texttt{/etc/passwd}.
\item There are also protocols used for autentization that do not use
\texttt{/etc/passwd} at all, for example NIS (Network Information Service) or
LDAP (Lightweight Directory Access Protocol).
\item The user group in \texttt{/etc/passwd} is called \emph{primary} for the
user.  Such a group is used when files are created.  Other groups a user belongs
to, those in the user's entry in \texttt{/etc/group}, are called
\emph{supplementary} and provide additional group privileges to access files.
\end{itemize}

%%%%%

\pdfbookmark[1]{file access rights}{fsaccessrights}

\begin{slide}
\sltitle{Access rights}
\begin{center}
\input{img/tex/prava.tex}
\end{center}
\begin{itemize}
\item \emsl{SGID} on a file without the executable bit for its group means
\emsl{mandatory locking} in systems based on System~V
\item \emsl{sticky bit} for directories: remove and renamed allowed for file
owners only.
\item \emsl{SGID} for directory: new files will have the same group as the
directory (on System~V based systems; it works in a different way on BSD
systems, see below)
\end{itemize}
\end{slide}

\begin{itemize}
\item The sticky bit for directories means that when the directory is writable
for a given user (possibly because all users can write), the user can create any
file that does not exist in that directory yet.  However, if the file exists but
is not owned by the user, he/she can not remove nor rename it even that by
itself he/she can write the directory.  Sticky bit is denoted by ``t'' and is
typically used for temporary directories:

\begin{verbatim}
$ ls -ld /tmp
drwxrwxrwt 9 root root 356352 Jan 27 22:37 /tmp/
\end{verbatim}

\item The SGID bit on directories on BSD based systems means that files and
directories created in this directory will have the same owner as the directory
itself.  The filesystem must be mounted with an \texttt{suiddir} flag and
the kernel may need an additional non-default option \texttt{SUIDDIR}.  It also
does not work for the root user.  This functionality is there to support Samba.
\item Originally, the sticky bit had a meaning for regular files as well but
that is not used anymore.
\item Some filesystems (XFS, AFS, UFS2, ZFS, and others) also support
\emph{access control lists} (ACLs) that allow for finer access right management.
\end{itemize}
%%%%%

\pdfbookmark[1]{getpwnam, getpwuid, getpwent}{getpw}

\label{GETPW_FUNC}
\begin{slide}
\sltitle{Obtain user/group information}
\begin{itemize}
\item \texttt{struct passwd *\funnm{getpwnam}(const char *name)}

return structure describing user found in password database or NULL.

\item \texttt{struct passwd *\funnm{getpwuid}(uid\_t uid)}

ditto; perform search according to UID.

\item \texttt{void \funnm{setpwent}(void)}
\item \texttt{void \funnm{endpwent}(void)}
\item \texttt{struct passwd *\funnm{getpwent}(void)}

these functions traverse password database. \funnm{setpwent} rewinds to the
beginning of the password database, \funnm{getpwent} gets the current entry,
\funnm{endpwent} closes the password database and free allocated resources.
\end{itemize}
\end{slide}

\begin{itemize}
\item These functions work independently on what database was used to get the
user information, see page \pageref{name_service_switch} for more information on
naming databases.
\item All these functions are part of POSIX 1003.1-2008.
\item \funnm{setpwent}() is needed to call before first calling
\funnm{getpwent}().
\item There are also functions \funnm{getgrnam}() and \funnm{getgrent}() which
can be used to get group information.
\item To search and list naming databases, you can use program \texttt{getent}.
For example:

\begin{verbatim}
$ getent passwd root
root:x:0:0:Super-User:/root:/sbin/sh
$ getent group root
root::0:
\end{verbatim}
\end{itemize}

%%%%%

\pdfbookmark[1]{name service switch}{NSS}

\begin{slide}
\sltitle{Name service switch}
\begin{itemize}
\item today's systems are not confined to only using
\texttt{/etc/passwd} and \texttt{/etc/groups}
\item such systems have \emph{databases} (passwd, groups, protocols, \dots)
\item database data come from \emph{sources} (files, DNS, NIS, LDAP, \dots)
\item file \texttt{nsswitch.conf} defines what databases use what sources
\item library functions must support this, obviously
\item it is possible to combine some sources, eg. users may be first be searched
in \texttt{/etc/passwd}, then in LDAP
\item came first with Solaris, other systems took over the idea
\end{itemize}
\end{slide}

\label{name_service_switch}

\begin{itemize}
\item Systems using the name service switch typically have
\texttt{nsswitch.conf(4)} where you can find information about what databases
are supported, including the API.  For example, with the \texttt{passwd}
database, standard calls like \texttt{getpwnam(3)} and \texttt{getpwent(3)} use
it.  In general, it is not needed to process such databases manually as there is
always an API to use for that.
\item Example of an existing \texttt{nsswitch.conf} on Solaris:

\begin{verbatim}
passwd:     files ldap
group:      files ldap

# You must also set up the /etc/resolv.conf file for DNS name
# server lookup.  See resolv.conf(4).
hosts:      files dns

# Note that IPv4 addresses are searched for in all of the
# ipnodes databases before searching the hosts databases.
ipnodes:   files dns

networks:   files
protocols:  files
rpc:        files
ethers:     files
\end{verbatim}
\end{itemize}

%%%%%

\pdfbookmark[1]{Access rights evaluation algorithm}{accessrights}

\begin{slide}
\sltitle{Access rights testing}
\setlength{\baselineskip}{0.9\baselineskip}
\begin{itemize}
\item user is identified with (\emsl{UID}) number and group numbers
for groups he belongs to (\emsl{primary GID}, \emsl{supplementary GIDs}).
\item this identification is inherited by each process
\item file $F$ has owner ($UID_F$) and group owner ($GID_F$). 
\item algorithm for evaluation of access rights for process:
$P(UID_P,GID_P,SUPG)$ and file $F(UID_F,GID_F)$:
\begin{tabular}{ll}
If & then $P$rocess has w.r.t. $F$ile \\ 
\hline
\texttt{if($UID_P$ == 0)} & \dots{} all rights \\
\texttt{else if($UID_P$ == $UID_F$)} & \dots{} owner rights \\
\texttt{else if($GID_P$ == $GID_F$ ||} &\\
\texttt{~~~~~~~~$GID_F \in SUPG$)} & \dots{} group rights \\
\texttt{else} & \dots{} rights of others
\end{tabular}
\end{itemize}
\end{slide}

\begin{itemize}
\item The processes of the \texttt{root} user can change its user and group
identity. This is used by e.g. the \texttt{login} process, that runs as
\texttt{root} and after performing authentication check successfully it runs
shell process with identity of given user (using the \texttt{setuid} syscall
-- see upcoming slides).
\item The implication of the algorithm is that for the \texttt{root} user the
access rights are not relevant (it has always unlimited access -- at least in
classic UNIX without fine grained privileges). If the user is equal, the
group/other rights are not used even though them permit more than what user
rights do. Similarly the others rights are not used if the group is equal.
\emsl{Therefore if a file owned by my user has the rights set to
\texttt{---rwxrwx}, I cannot read/write/execute it until I change the rights.}
\item More and more system diverge from the classic model where many processes
were running under a user with UID 0. Security vulnerability in such application
meant total control of the system. To thwart this, these systems employ models
like \emph{least privilege} in Solarisu or \emph{privilege separation} and
\emph{pledge} in OpenBSD.
\item \label{FILEDELETE} In order to delete a file, the user has to have a right
to write to the \emsl{directory} containing the file, because this is the
``file'', that is being changed. \emsl{The rights of the file to be deleted are
not relevant}; the shell might give you a warning that you are about to delete a
file for which you do not have the right to write, however this is just
informative. It is logical -- if you set a file as read-only, the shell will
deduce that you do not normally want to delete such file. See the example below.
\emsl{Unix systems do not have delete-like operation for a fike}, the file is
deleted automatically once it is no longer referenced from directory structure
and the file is not open by any process.

\begin{verbatim}
$ whoami
janp
$ ls -ld janp-dir
drwx------   2 janp  staff  512 Mar 23 12:12 janp-dir/
$ ls -l janp-dir
total 0
-rw-r--r--   1 root  root     0 Mar 23 12:11 root_wuz_here.txt
$ rm janp-dir/root_wuz_here.txt 
rm: janp-dir/root_wuz_here.txt: override protection 644 (yes/no)? yes
$ ls janp-dir/root_wuz_here.txt 
janp-dir/root_wuz_here.txt: No such file or directory
\end{verbatim}
\item However if \texttt{root} creates its own sub-directory in the
\texttt{janp-dir} directory and creates a new file there, the
\texttt{janp} user can no longer delete the \texttt{janp-dir} directory and its
contents because:
\begin{itemize}
\item sub-directory cannot be deleted if non-empty
\item given file cannot be deleted because \texttt{janp} is not user of
the sub-directory
\end{itemize}
\item If the read bit is removed from a directory rights, it is not possible to
read its contents, therefore list files therein contained. However if I know
the name of the file in the directory and the execute bit is set, I can read the
file:
\begin{verbatim}
$ mkdir foo
$ ls -ald foo
drwxr-xr-x  2 vladimirkotal  staff  68 Nov  5 14:37 foo
$ touch foo/bar
$ file foo/bar
foo/bar: empty
$ ls foo
bar
$ chmod u-r foo
$ ls foo
ls: foo: Permission denied
$ file foo/bar
foo/bar: empty
\end{verbatim}
\item There is a situation where even the execute bit for a directory is not
sufficient. This is used for temporary directories, where anyone can write to
however it is not desirable to permit users to delete each others files.
To achieve that there is the \emph{sticky bit} (01000). There might be a
\texttt{sticky} man page, where the sticky bit function is described.
It is visible as \texttt{\emsl{t}} in the \texttt{ls} output:

\begin{verbatim}
$ ls -ld /tmp
drwxrwxrwt   7 root     root         515 Mar 23 12:22 /tmp
\end{verbatim}
\end{itemize}

%%%%%

\pdfbookmark[1]{ruid, euid, suid}{resugid}

\begin{slide}
\sltitle{Real and effective UID/GID}
\begin{itemize}
\item for each process the following IDs are distinguished:
    \begin{itemize}
    \item \emsl{real UID} (RUID) -- real owner of the process
    \item \emsl{effective UID} (EUID) -- user, whose rights are used by the
process
    \item \emsl{saved UID} -- original effective UID
    \end{itemize}
\item similarly each process has real, effective and saved GID.
\item usually \texttt{RUID==EUID \&\& RGID==EGID}.
\item \emsl{right vesting} \dots{} execution of a program with
SUID (\emsl{set user ID}) bit set changes EUID and saved UID of the process
to the UID of the program owner, RUID stays the same.
\item similarly SGID bit changes EGID of the process. 
\item \emsl{access rights checking always consults EUID, EGID a
supplementary GIDs}
\end{itemize}
\end{slide}

\label{ROOT_SETUID}

\begin{itemize}
\item \label{SUID_BIT} The SUID and SGID bits are used for programs that need
bigger privileges thatn the user who executes them. One example is the
\texttt{passwd} program that needs to update files \texttt{/etc/passwd} and
\texttt{/etc/shadow}, where the ordinary user cannot modify the first and
cannot write into the the second. Another example is the \texttt{su} program,
which has to have the right to arbitrarily change user and group identity,
which is a privilege of programs running with UID 0.
\item Programs using the SUID and SGID bits should be carefully programmed
to allow only such operations for which they were designed and prevent misuse
of their privileges for non-authorized actions (root shell execution).
Such programs used to be one of the most frequent causes of security problems
in Unix systems.
\item The basic rule for writing SUID/SGID programs is: \emsl{do not write
them} if it is not absolutely necessary. This area is typical as security
problem generator. It is not easy to produce correct (i.e. secure) SUID/SGID
program, especially of higher complexity.
\item \emsl{These are the rules for ID change:}
\begin{itemize}
\item ordinary user cannot change its RUID or saved UID (the \texttt{exec} is an
exception to that, see page \pageref{EXEC})
\item the process can always change its EUID to that of RUID or saved UID.
This guarantees that in SUID program it is possible to arbitrarily change EUID
between the one that enabled the process to gain ownership rights and the
UID of the real user that executed the process originally.
\item \emsl{root can do everything}, and when it changes RUID, it will also
change saved UID -- it does not make sense to change just one of them when
either can be used to set EUID.
\end{itemize}
\end{itemize}

%%%%%

\pdfbookmark[1]{getuid, getgid, geteuid, getegid, getgroups}{getuid}

\begin{slide}
\sltitle{Process owner identification}
\begin{itemize}
\item \texttt{uid\_t \funnm{getuid}(void)}

returns real user ID of the calling process.
\item \texttt{uid\_t \funnm{geteuid}(void)}

returns effective user ID of the calling process.
\item \texttt{gid\_t \funnm{getgid}(void)}

returns real group ID of the calling process.
\item \texttt{gid\_t \funnm{getegid}(void)}

returns effective group ID of the calling process.
\item \texttt{int \funnm{getgroups}(int \emph{gidsz}, gid\_t \emph{glist}[])}

-- \texttt{glist} returns at most \texttt{gidsz} supplementary group
IDs of the calling process and returns number of all GIDs of the process.
\end{itemize}
\end{slide}

\begin{itemize}
\item pro reálné UID je volání \texttt{getuid}, volání \texttt{getruid}
neexistuje
\item \texttt{getgroups}: kdy¾ \texttt{gidsz~==~0}, jen vrátí poèet
skupin.  Kdy¾ \texttt{0 < gidsz < \#skupin}, vrátí \texttt{-1}.
\item v UNIXu je mnoho typù jako \verb#uid_t#, \verb#gid_t#,
\verb#size_t#, apod. Vesmìs jsou to celoèíselné typy, èasto je
najdete v \texttt{/usr/inc{}lude/sys/types.h}
\item Solaris má pøíkaz \texttt{pcred}, který jednodu¹e zobrazí informace o
identifikaci procesu:
\begin{verbatim}
$ pcred 5464
5464:   e/r/suid=1993  e/r/sgid=110
        groups: 33541 41331 110
\end{verbatim}
\end{itemize}

%%%%%

\pdfbookmark[1]{setuid, setgid, setgroups}{ownerchange}

\begin{slide}
\sltitle{Process owner change}
\begin{itemize}
\item \texttt{int \funnm{setuid}(uid\_t \emph{uid});}
    \begin{itemize}
    \item in process with EUID~==~0 sets RUID, EUID and saved-SUID to
    \texttt{uid}
    \item for other processes it sets just EUID, and \texttt{uid} must be
    either equal to RUID or saved UID
    \end{itemize}
\item \texttt{int \funnm{setgid}(gid\_t \emph{gid});} \\
similar to \texttt{setuid}, for group-IDs of the process.
\item \texttt{int \funnm{setgroups}(int \emph{ngroups},
gid\_t *\emph{gidset})} \\
sets the supplementary group IDs for the calling process. Can only be used
by superuser process.
\end{itemize}
\end{slide}

\begin{itemize}
\item o nastavení UID pro proces s EUID 0 viz také poznámky na stranì
\pageref{ROOT_SETUID}.
\item co vý¹e uvedené tedy znamená: proces s efektivními právy superu¾ivatele
mù¾e libovolnì mìnit identitu. Ostatní procesory mohou pouze støídat svá
reálná a efektivní práva.
\item program \emph{login} vyu¾ívá volání \texttt{setuid}
\item pokud chce process s UID~==~0 zmìnit svou identitu, musí
nejprve volat \texttt{setgid} a \texttt{setgroups}. Teprve pak
lze zavolat \texttt{setuid}. Pøi opaèném poøadí volání by proces
po provedení \texttt{setuid} u¾ nemìl práva na \texttt{setgid} a
\texttt{setgroups}.
\item \texttt{setgroups} není uvedeno v UNIX~98 ani UNIX~03.
\item RUID/EUID jsou ulo¾ené v záznamu tabulky procesù pro pøíslu¹ný proces a
zároveò v tzv. \emph{u-area} (viz napøíklad [Bach]). EUID v tabulce procesù se
nazývá ji¾ zmínìné uschované UID, neboli \emph{saved UID}.  Jak ji¾ bylo
øeèeno, uschované UID se pou¾ívá pro kontrolu, kdy¾ se proces chce vrátit k
EUID, se kterým byl spu¹tìn (po té, co doèasnì nastavil své EUID na UID
u¾ivatele, který proces spustil, tj. na RUID).
\item pokud tedy jako root vytvoøíte SUID program a v nìm zavoláte
\texttt{setuid} pro jakéholi UID mimo 0, ji¾ se v programu k EUID==0 nemù¾ete
vrátit (je to logické -- pøedstavte si situaci, kdy se u¾ivatel loguje do
systému). V tom pøípadì byste museli pou¾ít volání \texttt{seteuid}, které
nastavuje pouze EUID.
\item pøíklad: \example{setuid/screate-file.c}
\end{itemize}

\pdfbookmark[1]{file system}{filesys}

\begin{slide}
\sltitle{Systém souborù}
\setlength{\baselineskip}{0.8\baselineskip}
\begin{itemize}
\item adresáøe tvoøí strom, spolu se soubory acyklický graf (na
jeden soubor mù¾e existovat více odkazù). 
\item ka¾dý adresáø navíc obsahuje odkaz na sebe '\texttt{.}'
(teèka) a na nadøazený adresáø '\texttt{..}' (dvì teèky). 
\item pomocí rozhraní systému souborù se pøistupuje i k dal¹ím
entitám v~systému: 
    \begin{itemize2}
\setlength{\itemsep}{-3pt}
\setlength{\topsep}{0pt}
    \item periferní zaøízení 
    \item pojmenované roury 
    \item sokety
    \item procesy (\texttt{/proc}) 
    \item pamì» (\texttt{/dev/mem}, \texttt{/dev/kmem}) 
    \item pseudosoubory (\texttt{/dev/tty}, \texttt{/dev/fd/0},\dots) 
    \end{itemize2}
\item z pohledu jádra je ka¾dý obyèejný soubor pole bajtù. 
\item v¹echny (i sí»ové) disky jsou zapojeny do jednoho stromu.
\end{itemize}
\end{slide}

\label{DEVFS}

\begin{itemize}
\item zaøízení, soubory v \texttt{/proc}, terminály, pamì» atd. jsou v¹echno
jeden typ souborù - speciální soubory. Dal¹í typy souborù - regulární soubor
(hardlink), adresáø, pojmenovaná roura, socket, symbolický link.
\item novì vytvoøený adresáø má na sebe 2 odkazy -- jeden z nadøazeného
adresáøe, a jeden sám na sebe, '\texttt{.}':

\begin{verbatim}
$ mkdir test
$ ls -ld test
drwx------   2 janp     staff        512 Mar 23 12:46 test
\end{verbatim}

\item root mù¾e v nìkterých systémech strukturu adresáøù zacyklit, ale tím
zmate utility pro procházení filesystému; moc se cyklické struktury
nepou¾ívají. Symbolické linky na adresáøe fungují v¹ude.
\item pojmenované roury (viz strana \pageref{MKFIFO}) lze pou¾ít i mezi
procesy, které nejsou pøíbuzensky spøíznìné. Jinak fungují stejnì jako
nepojmenované roury.
\item zmiòované sokety jsou v doménì UNIX, tj. slou¾í pro komunikaci v rámci
jednoho systému. Sokety z domény INET, pøes které probíhá sí»ová komunikace,
se v systému souborù neobjevují. Sí»ová komunikace zaèíná na stranì
\pageref{NETWORKING}.
\item debuggery pou¾ívají pamì»ové obrazy procesù dostupné v \texttt{/proc}.
Ve vìt¹inì u{}nix-like systémù obsahuje podstrom \texttt{/proc} údaje o jádru
systému a bì¾ících procesech ve formì textových souborù.
\item dne¹ní moderní unixy mívají speciální filesystém \emph{devfs}, jeho¾
obsah odrá¾í aktuální konfiguraci systému co se týèe pøipojených zaøízení. Tj.
napø. pøi pøipojení USB sticku se v \texttt{/dev} objeví pøíslu¹né diskové
zaøízení. Po fyzickém odpojení zaøízení odkaz z adresáøové struktury opìt
zmizí.
\end{itemize}

\endinput
