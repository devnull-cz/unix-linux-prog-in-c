% The title slide

changequote([[[, ]]])

\begin{slide}
\centerslidestrue
\begin{center}
\title{\LARGE Unix/Linux Programming in C}
\author{(NSWI015)}
\date{Version: \rm\today}
\maketitle

% \v{c} - hacek nad c
% \'{y} - carka nad y
% \'{\i} - carka nad i (\i je treba proto, aby nam zmizela tecka nad i)
% \accent23o{u} - krouzek nad u samozrejme

\vspace{2ex}
{\small (c) 2011 -- 2018 Vladim\'{i}r Kotal}\\
{\small (c) 2005 -- 2011, 2016 -- 2018 Jan Pechanec}\\
{\small (c) 1999 -- 2004 Martin Beran}

\vspace{2ex}
Department of SISAL\\
Faculty of Mathematics and Physics, Charles University\\
Malostransk\'{e} n\'{a}m. 25, 118 00 Praha 1 

\begin{figure}[htb!]
  \includegraphics[scale=0.75]{img/by-nc-sa-small}
\end{figure}
\end{center}
\end{slide}

\begin{itemize}
\item This is official material for the class \emph{Unix/Linux Programming in C}
(NSWI015) lectured at the Faculty of Mathematics and Physics, Charles University
in Prague.
\item The text is currently being translated to English.
\item This material is published under the
\href{http://creativecommons.org/licenses/by-nc-sa/3.0/cz/}{Creative Commons
BY-NC-SA 3.0} license and is always work in progress, see the history on
GitHub:\\
\url{https://github.com/devnull-cz/unix-linux-prog-in-c}
\item To download the latest version, go to the \emph{releases} tab on GitHub.
\item Source code referenced from this material is published in
\href{http://creativecommons.org/licenses/publicdomain/}{Public Domain} unless
specified otherwise in the files.
\item The source code files can be found on GitHub here:\\
\url{https://github.com/devnull-cz/unix-linux-prog-in-c-src}
\item In case you find any errors either in the text or in the example programs,
we appreciate if you let us know.
\end{itemize}

\pagebreak

\begin{slide}
\sltitle{Contents}
\slidecontents{0}
\end{slide}

\begin{itemize}
\item This lecture is mostly about Unix principles and Unix programming in the~C
language.
\item \emsl{The lecture is mostly about system calls, ie. an interface between a
user space and system kernel.}
\item For the API, we will follow the \emph{Single UNIX Specification,
version~4} (SUSv4). Systems that submit to the Open Group for certification and
pass conformance tests are termed to be compliant with the UNIX standard
UNIX~V7.  Some versions of Solaris, AIX, HP-UX a macOS on selected architectures
are compliant with the previous version SUSv3
(\url{http://www.opengroup.org/openbrand/register/xy.htm}).
\item The specific source code examples linked from this material are usually
tested on macOS and Linux.
\end{itemize}

%%%%%
\pdfbookmark[0]{intro, programming utilities}{intro}

\begin{slide}
\sltitle{Contents}
\slidecontents{1}
\end{slide}

\pdfbookmark[1]{Current UNIX and Unix-like Systems}{currentunix}

\begin{slide}
\sltitle{Proprietary UNIX and Unix-like Systems}

\begin{itemize}
\item Sun Microsystems, now Oracle: \emsl{SunOS} (defunct), \emsl{Solaris}
\item Apple: \emsl{macOS} (formerly Mac OS X, Mac OS)
\item SGI: \emsl{IRIX} (in maintenance mode)
\item IBM: \emsl{AIX}
\item HP: \emsl{HP-UX}, \emsl{Tru64 UNIX} (defunct, formerly by Compaq)
\item SCO: \emsl{SCO Unix} (discontinued)
\item BSD/OS: \emsl{BSDi} (discontinued)
\item Xinuos (formerly Novell): \emsl{UNIXware}
\end{itemize}
\end{slide}

\begin{slide}
\sltitle{Open source Unix-like Systems}

\begin{itemize}
\item rather extensive number of \emsl{Linux} distributions
\item \emsl{FreeBSD}
\item \emsl{NetBSD}
\item \emsl{OpenBSD}
\item \emsl{DragonflyBSD}
\begin{itemize}
\item all BSD variants have roots in the 4.3BSD-Lite source code
\end{itemize}
\item \emsl{Minix}, micro-kernel based
\item \emsl{OpenSolaris}, discontinued
\end{itemize}
\end{slide}

\begin{itemize}
\item Note that \emsl{Linux is a kernel}, not the whole system.  In contrast to
FreeBSD, for example, which covers both the kernel and the userland.  It is
better to say a ``Linux distribution'' if you discuss a whole system that is
built around the Linux kernel.
\item FreeBSD and NetBSD forked from 386BSD (now defunct) in 1993, OpenBSD
forked from NetBSD in 1995, and DragonflyBSD forked from FreeBSD in 2003.
386BSD itself was based on 4.3BSD-Lite.  However, the history is much more
complicated, as usual.
\item Presently, the ``UNIX'' trademark can be only used by systems that passed
conformance tests defined in the Single UNIX Specification (SUS).
\item From those systems listed above, only Solaris, macOS, AIX, and HP-UX are
UNIX~03 compliant (\url{http://www.opengroup.org/openbrand/register/}).  Other,
not certified systems, are often described as ``Unix-like'', even that in many
cases they closely follow the standard.  However, word ``Unix'' is often used
for systems from either group.
\item The above list is a tiny fraction of the whole Unix world.  Every
proprietary Unix variant usually came from either UNIX~V or BSD, and added its
own features.  That is why there were quite a few standards as well, see page
\pageref{UNIXSTANDARDS}.  In the end vendors agreen upon a small set of those.
\item If you are interested in detailed and up-to-date Unix system version
history, go check \url{https://www.levenez.com/unix/}.
\end{itemize}

%%%%%

\pdfbookmark[1]{UNIX standards}{unixstd}

\begin{slide}
\sltitle{Standardy UNIXu}
\begin{itemize}
\renewcommand{\baselinestretch}{0.8}
\item \emsl{SVID} (System~V Interface Definition) 
    \begin{itemize2}
    \item \uv{fialová kniha}, kterou AT\&T vydala poprvé v roce 1985
    \item dnes ve verzi SVID3 (odpovídá SVR4) 
    \end{itemize2}
\item \emsl{POSIX} (Portable Operating System based on UNIX)
    \begin{itemize2}
    \item série standardù organizace IEEE znaèená P1003.xx, postupnì je
    pøejímá vrcholový nadnárodní orgán ISO 
    \end{itemize2}
\item \emsl{XPG} (X/Open Portability Guide) 
    \begin{itemize2}
    \item doporuèení konsorcia X/Open, které bylo zalo¾eno v r. 1984 pøedními
    výrobci platforem typu UNIX
    \end{itemize2}
\item \emsl{Single UNIX Specification}
    \begin{itemize2}
    \item standard organizace The Open Group, vzniklé v roce 1996 slouèením
    X/Open a OSF 
    \item dnes Version~4 (\emsl{SUSv4})
    \item splnìní je nutnou podmínkou pro u¾ití obchodního názvu UNIX
    \end{itemize2}
\end{itemize}
\end{slide}

\label{UNIXSTANDARDS}

\begin{itemize}
\item základní informace je, ¾e oblast standardù týkající se unixových systémù
je vìc znaènì slo¾itá a na první pohled velmi nepøehledná.
\item AT\&T dovolila výrobcùm nazývat svoji komerèní UNIX variantu ``System
V'' pouze pokud splòovala podmínky standardu SVID. AT\&T také publikovala
\emph{System~V Verification Suite} (SVVS), které ovìøilo, zda daný systém
odpovídá standardu. 
\item POSIX (Portable Operating System Interface) je standardizaèní snaha
organizace IEEE (Institute of Electrical and Electronics Engineers).
\item SUSv4 je spoleèný standard The Open Group, IEEE (Std. 1003.1, 2008
Edition) a ISO (ISO/IEC 9945-2008).
\item Pro certifikaci operaèního systému na Single Unix Specification
je nutné aby systém (na dané architektuøe, napø. 64-bit x86) pro¹el sadou
testù. Výsledky testù jsou pak vyhodnoceny. Testy samotné jsou sdru¾eny
do tzv. \emph{test suites}, co¾ jsou sady automatických testù, které
projdou systém a zjistí jestli splòuje rozhraní dané normou.
Pro SUSv3 je takových test suites cca 10.
\item Rozhraní specifikované normou POSIX.1-2008 se dìlí na 4
základní skupiny: XSH (System Interfaces), XCU (Shell and Utilities), XBD
(Base definitions). Z nich je co do poètu
rozhraní nejobsáhlej¹í XSH, která popisuje více ne¾ 1000 rozhraní.
\item Skupiny rozhraní POSIXu spolu se skupinou Xcurses, která je souèástí
Single Unix Specification (ale nikoliv souèást POSIX báze v normì IEEE Std
1003.1-2001) zahrnují celkem 1742 rozhraní, které tvoøí Single Unix
Specification (2003). Tabulky rozhraní SUS je mo¾né získat zde:
\url{http://www.unix.org/version3/inttables.pdf}
\item komerèní UNIXy vìt¹inou sledují Single UNIX Specification, splnìní této
normy je právì podmínkou pro u¾ití názvu UNIX (znaèka UNIX 98 odpovídá
SUSv2, znaèka UNIX 03 odpovídá SUSv3, SUSv4 je UNIX V7 - neplést s historickým
V7 UNIX). Je postavena na bázi POSIXu. My se budeme dr¾et SUSv4. Popis datových
struktur a algoritmù jádra v tomto materiálu bude vìt¹inou vycházet ze
System~V Rel.~4.
\item na Solarisu je obsáhlá manuálová stránka \texttt{standards(5)}, kde mù¾ete
na jednom místì nalézt mnoho informací týkající se standardù. Jednotlivé pøíkazy
splòující danou normu jsou navíc umístìny do vyhrazených adresáøù. Napø.
program \texttt{tr} je v adresáøích \texttt{/usr/xpg4/bin/} a
\texttt{/usr/xpg6/bin/}, v ka¾dém je verze pøíkazu splòující danou normu.
Na pøepínaèe a chování dané normou se pak lze spolehnout napø. pøi psaní
shellových skriptù.
\item opìt na Solarisu, podívejte se na hlavièkový soubor
\texttt{/usr/inc{}lude/sys/fea\-ture\-\_tests.h}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pdfbookmark[1]{POSIX}{POSIX}

\begin{slide}
\sltitle{POSIX}
\begin{itemize}
\renewcommand{\baselinestretch}{0.8}
\item tvrzení ``tento systém je POSIX kompatibilní'' nedává ¾ádnou konkrétní
informaci
\begin{itemize}
\item asi podporuje POSIX1990 a mo¾ná i nìco dal¹ího (co?)
\end{itemize}
\item dotyèný buï neví co je POSIX nebo si myslí, ¾e to nevíte vy
\item jediná rozumná reakce je otázka ``jaký POSIX?''
\item POSIX je \emsl{rodina standardù}
\item prvním dokumentem je \emph{IEEE Std POSIX1003.1-1988}, pozdìji po vzniku
dal¹ích roz¹íøení neformálnì odkazovaný jako POSIX.1
\item poslední verze POSIX.1 je \emph{IEEE Std 1003.1, 2004 Edition}
\begin{itemize}
\item obsahuje v sobì ji¾ i to, co døíve definoval POSIX.2 (Shell and Utilities)
a rùzná, døíve samostatná roz¹íøení
\end{itemize}
\end{itemize}
\end{slide}

\label{POSIX}

\begin{itemize}
\item prvním dokumentem je \emph{IEEE Std POSIX1003.1-1988}, døíve oznaèovaný
pros\-tì jako POSIX, pak odkazovaný jako \emph{POSIX.1}, proto¾e POSIXem se nyní
míní sada vzájemnì souvisejících standardù. POSIX.1 v té dobì obsahoval
programovací API, tj. práce s procesy, signály, soubory, èasovaèi atd. S malými
zmìnami byl pøevzat organizací ISO (\emph{ISO 9945-1:1990}), a je
oz\-na\-èo\-va\-ný i
jako POSIX1990. IEEE oznaèení je \emph{IEEE Std POSIX1003.1-1990}. Tento
standard byl sám o sobì velký úspìch, ale stále je¹tì nespojoval tábory System~V
a BSD, proto¾e v sobì napøíklad nezahrnoval BSD sockety nebo IPC (semafory,
zprávy, sdíl{}ená pamì») ze System~V. Souèástí standardu je i ``POSIX
conformance test suite (PCTS)'', který je volnì k dispozici.
\item oznaèení POSIX vymyslel Richard Stallman, tedy èlovìk, který v roce 1983
zalo¾il GNU projekt.
\item dùle¾itá ro¾¹íøení k IEEE Std 1003.1-1990 (jsou souèástí IEEE Std 1003.1,
2004 Edition):
\begin{itemize}
\item \emph{IEEE Std 1003.1b-1993 Realtime Extension}, neformálnì známý jako
POSIX.4, proto¾e to bylo jeho pùvodní oznaèení pøed pøeèíslováním; já budu toto
roz¹íøení nìkdy také nazývat POSIX.4. Vìt¹ina tohoto roz¹íøení je nepovinná,
tak¾e tvrzení ``systém podporuje POSIX.1b'' má je¹tì hor¹í vypovídací hodnotu
ne¾ ``systém je POSIX kompatibilní'', a to prakticky nulovou. Jediná povinná
èást POSIX.4 je malé doplnìní k signálùm oproti POSIX1990. Je proto nutné v¾dy
uvést, co z POSIX.4 je implementováno -- napø. sdíl{}ená pamì», semafory,
real-time signály, zamykání pamìti, asynchronní I/O, èasovaèe atd.
\item \emph{IEEE Std 1003.1c-1995 Threads}, viz strana \pageref{POSIXTHREADS}.
\item \emph{IEEE Std 1003.1d-1999 Additional Realtime Extensions}
\item \emph{IEEE Std 1003.1j-2000 Advanced Realtime Extensions}, viz strana
\pageref{RWLOCKS}.
\item \dots
\end{itemize}
\item standardy POSIX je mo¾né nalézt na \url{http://www.open-std.org/}.
HTML verze je volnì k prohlí¾ení, za PDF verzi se platí.
\end{itemize}


\pdfbookmark[1]{books}{books}

%%%%%

\begin{slide}
\sltitle{Books on Unix system principles and design}

\begin{enumerate}
\item Uresh Vahalia: \emsl{UNIX Internals: The New Frontiers}.
 Prentice Hall; 1st edition, 1995
\item Bach, Maurice J.: \emsl{The Design of the UNIX Operating System}.
Prentice Hall, 1986
\item McKusick, M. K., Neville-Neil, G. V.: \emsl{The Design and
Implementation of the FreeBSD Operating System}. Addison-Wesley, 2004
%\item Goodheart, B.; Cox, J.: \emsl{The Magic Garden Explained: the
%Internals of UNIX System~V Release 4}. Prentice Hall, 1994
\item McDougall, R.; Mauro, J.: \emsl{Solaris Internals}. Prentice Hall; 2nd
edition, 2006.
\item \emsl{Linux Documentation Project}. \url{http://tldp.org/}
\end{enumerate}
\end{slide}

\begin{itemize}
\item These books are about Unix internals, not about Unix system programming.
\end{itemize}

\begin{enumerate}
\item A great book on Unix in general and compares SVR4.2, 4.4BSD, Solarix~2.x
and Mach systems.  The 2nd edition scheduled for 2005 never happened,
unfortunately.
\item UNIX classic book. On UNIX System~V Rel.~2, and partially 3 as well.
While outdated, it is one of the best books ever written on Unix.  In 1993 a
Czech translation was released as \emsl{Principy opera\v{c}n\'{\i}ho syst\'{e}mu
UNIX}, SAS.
\item Structures, functions, and algorithms of the FreeBSD 5.2 kernel; it is
based on another Unix classic book \emsl{The Design and Implementation of the
4.4 BSD Operating System} by the same author.
\item The best book on the Solaris operating system.  The system version in the
book is Solaris~10.
\item Linux documentation project home page.
\end{enumerate}

%%%%%

\begin{slide}
\sltitle{Books on Unix programming}
\begin{enumerate}
\item Stevens, W. R., Rago, S. A.: \emsl{Advanced Programming in UNIX(r)
Environment}. Addison-Wesley, 2nd edition, 2005.
\item Rochkind, M. J.: \emsl{Advanced UNIX Programming},
Addison-Wesley; 2nd edition, 2004
\item Stevens, W. R., Fenner B., Rudoff, A. M.: \emsl{UNIX Network
Programming, Vol. 1 -- The Sockets Networking API}. Prentice Hall,
3rd edition, 2004
\item Butenhof, D. R.: \emsl{Programming with POSIX Threads},
Addison-Wesley; 1st edition, 1997
% I don't why but after I switched from FreeBSD to Solaris, I can't typeset
% word "unix" anymore. It's like it wasn't there. Using {} trick helps.
\item UNIX specifications, see \url{http://www.unix.org}
\item manual pages, mainly sections 2 and 3
\end{enumerate}
\end{slide}

\label{REF_PROGRAMMING}

\begin{enumerate}
\item One of the best book on programming in Unix environment.  Does not cover
net\-work\-ing, that is in 3.
\item Another classic book on programming in Unix environment.  Also covers
net\-work\-ing.  Not as detailed as books 1 and 3 but that could be to your
advantage.  We very much recommend this book, especially if you want just one.
The author can see the big picture which is quite rare.
\item Unix network programming classics, one of the best on the topic; there is
also volume 2, \emsl{UNIX Network Programming, Volume 2: Interprocess
Communications}, covering interprocess communication in great detail.
\item Great book on programming with threads using POSIX API.  Highly
recommended.
\item UNIX specifications.
\item Detailed descriptions of system calls and functions.
\item \label{POSIX4} A book that did not fit the slide and covers topics outside
of the scope of this class: Gall\-meis\-ter, B. R.: \emsl{POSIX.4 Programmers
Guide: Programming for the Real World}, O'Reilly; 1st edition, 1995.  A great
book on real-time POSIX extensions with a beatiful cover.  See also pages
\pageref{REALTIMEEXTENSIONS} a \pageref{SIGWAITINFO}.
\item[\ldots] Go to Amazon and search for ``unix''.  If you ever buy anything,
always check whether there is a newer edition of the same book.  Note that they
often still sell older releases as well.
\item[\ldots] You can also buy lots of these books on Amazon in a decent second
hand quality for a fraction of the original price.
\end{enumerate}

%%%%%

\begin{slide}
\sltitle{Manual page sections}
\begin{itemize}
\item the convention is that ``(X)'' after a name means the manual page section
\item for example, \texttt{chmod(2)} means a man page for the system call from a
section 2, it does \emsl{not} mean a function call
\item \texttt{chmod(1)} means the shell command
\item use ``\texttt{man <N> <name>}'' to get the specific man page
\item example: \texttt{man 2 chmod}
\item see the \texttt{man-pages(7)} man page on Linux on what sections exist
\end{itemize}
\end{slide}

\begin{itemize}
\item Different systems might have a different list of manual page sections, the
numbering may not match, etc.  See also \texttt{man(1)}.  For example, on
Solaris, the manual page section needs to be provided with the \texttt{-s}
option, ie. ``\texttt{man -s 2 chmod}''.
\item The \texttt{man} command uses a list of system directories to search for
man pages.  If you have manual pages some place else, perhaps in a local subtree
after you unpacked a tar file you downloaded and want to check the
documentation, the \texttt{-M} option may come in handy.
\item Sometimes there are entries for the same name in several sections.  If
unsure what you are looking for, use the \texttt{-a} option to get all manual
pages for that name (otherwise you get just one, usually from the first
section found), and go through the individual man pages with the \texttt{q}
command for \texttt{less(1)} which is usually the default pager (or possibly
\texttt{more(1)}).
\end{itemize}
%%%%%

\pdfbookmark[1]{The C Programming Language}{C}
\label{C_LANGUAGE}

\begin{slide}
\sltitle{The C Programming Language}
\begin{itemize}
\item virtually all Unix kernels are written in C.  Only some HW dependend parts
are written in assembler.
\item C came into existence in the years 1969-1973, by Dennis M. Ritchie (\dag
2011)
\item it evolved from B, designed by Ken Thomson
\item created as means to rewrite original Unix in a higher language.  It also
greatly helped \emsl{portability of the system.}
\item language variants
    \begin{itemize}
    \item original K\&R C (1978-1979)
    \item standard ANSI/ISO C (1989), then next C standard revisions
    \end{itemize}
\end{itemize}
\end{slide}

\begin{itemize}
\item The success of C eventually overcame the success of Unix itself.
\item CPL $\Rightarrow$ BCPL $\Rightarrow$ B (Thompson, interpret)
$\Rightarrow$ C.  Both Thompson and Ritchie worked for Bell Laboratories.
\item It took many years before C reached its first standard.  Most work on C
happened in 1972, another peak was in 1977-1979, then in the 1980s ANSI commitee
was established to provide the first standard on C.  For more information on the
early C history, see \emph{Dennis M. Ritchie, The Development of the C Language}
paper, available freely.
\item K\&R C refers to the C language as described in the first edition of
\emph{The C Prog\-ramm\-ing Language} classic book by Kernighan and Ritchie,
Prentice-Hall, 1978.
\item In 1983 ANSI (American National Standards Institute) formed a commitee
X3J11 to create the first C standard.  After a long and tedious process the
standard came to existence as ANSI X3.159-1989 ``Programming Language C,'' and
is mostly known as ``ANSI C'', or C89, and the command line name for the
compiler itself was \texttt{c89}.
\item The 2nd edition of the C book (1988) was updated for the upcoming
standard as it used one of its final drafts.  In 1990, ANSI C was adopted by ISO
as ISO/IEC 9899:1990; that standard is sometimes called C90.  It's the same as
C89 but it renumbered its sections and removed the rationale document which was
part of ANSI C.  That standard was adopted back by ANSI.  After C89, ANSI never
got involved in the C standardization anymore, it only adopted each ISO C
standard.
\item The next revision of the language was released in 1999 as ISO 9899:1999,
informally called C99.  After that, there were three technical corrigendums,
TC1, TC2, and TC3, so the current version of the C99 standard is the combined
C99+TC1+TC2+TC3, WG14~N1256, dated 2007-09-07.  It is a work in progress,
with its current final draft located here,
\url{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf}.
\item After C99, C11 came, officially ISO/IEC 9899:2011.
\item Some difference between C89 and C99 -- inline functions, variable
definitions intermixed with code, one-line comments using \texttt{//}, new
functions like \funnm{snprintf}() etc.
\item The ISO C standards are not free but the drafts are.  The latest draft for
each standard is virtually the standard itself, it just not does not say that.
See \url{http://www.open-std.org/}.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Byte ordering}
\begin{itemize}
\item byte ordering -- depends on the architecture
    \begin{itemize}
    \item \raisetab{
    \begin{tabular}[t]{r|c|c|c|c|}
    little endian: 0x11223344 =
    &44&33&22&11\\
    \multicolumn{1}{r}{\texttt{addr +}}&
    \multicolumn{1}{c}{0}&\multicolumn{1}{c}{1}&
    \multicolumn{1}{c}{2}&\multicolumn{1}{c}{3}
    \end{tabular}}
    \item \raisetab{
    \begin{tabular}[t]{r|c|c|c|c|}
    big endian: 0x11223344 =
    &11&22&33&44\\
    \multicolumn{1}{r}{\texttt{addr +}}&
    \multicolumn{1}{c}{0}&\multicolumn{1}{c}{1}&
    \multicolumn{1}{c}{2}&\multicolumn{1}{c}{3}
    \end{tabular}}
    \end{itemize}
\item little endian -- Intel, ARM (mostly, but it does support both)
\item big endian -- SPARC, MIPS, network byte ordering
\end{itemize}
\end{slide}

\label{BYTE_ORDERING}

\begin{itemize}
\item Be careful when using tools like \texttt{hexdump} that by default print
out a file as 16-bit numbers.  The ordering of individual bytes may not be how
they are stored in a file.  For example, take FreeBSD on i386.  The first number
in the file is character ``i'' which represents lower 8 bits of the first 16-bit
number, so when the first two bytes are printed out as a 16-bit number, the byte
representing ``i'', ie. ``69'', is shown as the second byte.  Similarly for
``kl''.

\begin{verbatim}
$ echo -n ijkl > test
$ hexdump test
0000000 6a69 6c6b
0000004
\end{verbatim}

You can use other output formats though, for example as hexa bytes and
characters in the same output:

\begin{verbatim}
$ hexdump -C test 
00000000 69 6a 6b 6c            |ijkl|
00000004
\end{verbatim}

\item The UNIX spec does not list \texttt{hexdump} but defines \texttt{od}
(octal dump).  The equivalent output for the \texttt{hexdump} default output is
as follows.  Note that since we did that on SPARC, the output is different from
the i386 output above!

\begin{verbatim}
$ od -tx2 test
0000000 696a 6b6c
0000004
\end{verbatim}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}
\sltitle{New line character(s)}
\begin{itemize}
\item in Unix, a text file line ends with a single character \emsl{LF}
\item in Windows (and MS~DOS), a new line ends with two characters, \emsl{CR+LF}
\item on Unix, calling \verb.putc('\n'). thus prints only one character
\item ``classic'' Mac~OS used \emsl{CR}
\end{itemize}
\end{slide}

\label{NEWLINECHAR}

\begin{itemize}
\item \emsl{LF}, \emph{line feed}, sometimes also referred to as \emph{new
line}, is a character 0x0A (10).  \emsl{CR}, \emph{carriage return}, or simply
\emph{return}, is a character 0x0D (13).
\item To further confuse the enemy, ``classic'' Mac OS used a single \emsl{CR}
as line breaks.  As present time macOS comes from the Unix world, it also uses
\emsl{LF} now.
\item When you open a text file in classic \texttt{vi} and you see strange
\verb|^M| characters at the end of every line, it is that \emsl{CR} character
from a line separator in a file brought over from a Windows system.  Just get
rid of them via \verb|:%s/^V^M//g| where \verb|^X| means Ctrl+X.  ViM by default
tries to be smarter in such situations but not always to your benefit.
\item See the \texttt{ascii} man page for the octal, hexadecimal, and decimal
ASCII character sets (ie. up to character 127 as ASCII table has only 128
characters).
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pdfbookmark[1]{C style}{cstyle}

\begin{slide}
\sltitle{C style}
\begin{itemize}
\item C style of the source code files is extremely important
\item there are quite a few ways how to do it:

\begin{verbatim}
int
main(void)
{
        int i;
        char c = 'X';

        for (i = 0; i < 10; ++i)
                printf("%c%d\n", c, i);
        return (0);
}
\end{verbatim}
\end{itemize}
\end{slide}

\begin{itemize}
\item One of the most important thing of a C style (well, any style) is
consistency.  And often it is not that important what an exact C style a group
of coders is going to pick as it is that one specific style is chosen and then
religiously followed by all in the group.  A good and rigorously followed cstyle
leads to a smaller number of bugs in code.
\item A pre-push hook that runs a C style check script and refuses to accept any
changesets not following the chosen C style is a working solution to avoid C
style violations.
\item \url{http://mff.devnull.cz/cstyle.html}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}
\sltitle{C style (cont.)}
\begin{itemize}
\item many ways how \emsl{NOT} to do it (so called assembler style):

\begin{verbatim}
int main(void) {
int i = 0; char c;
printf("%d\n", i);
return (0);
}
\end{verbatim}

\item or a schizophrenic style:
\begin{verbatim}
int main(void) {
        int i = 0; char c;
        if (1)
        printf("%d\n", i);i=2;
return (0); }
\end{verbatim}

\end{itemize}
\end{slide}

\begin{itemize}
\item A good C style of of the source code you write represents you.  You will
be judged by other people by the way your source code looks.  Always try to
write beautiful code.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Standard Utilities}
\begin{tabular}{ll}
\emsl{cc}, \emsl{c99}$^*$, \emsl{gcc}$^\dagger$& C compiler\\
\emsl{CC}, \emsl{g++}$^\dagger$& C++ compiler\\
\emsl{ld}& linker\\
\emsl{ldd}& for listing dynamic object dependencies\\
\emsl{cxref}$^*$& generate a C program cross-reference table\\
\emsl{sccs}$^*$& source code management\\
\emsl{make}$^*$& for maintaining program dependencies\\ 
\emsl{ar}$^*$& for managing archives\\
\emsl{dbx}, \emsl{gdb}$^\dagger$& debuggers\\
\emsl{prof}, \emsl{gprof}$^\dagger$& profilers\\
\end{tabular}

\hspace{0.5cm}$^*$ SUSv4 $^\dagger$ GNU
\end{slide}

SUSv4
\begin{itemize}
\item The standard C language compiler is \texttt{c99}, required by the
specification.  Be careful as the default mode for \texttt{gcc} does not
conform to any of the ANSI/ISO C standards.  You need to check the manual page
for your version, look for the option \texttt{-std=} to see what is the default.
For example, for version 4.2.1, the default is \texttt{-std=gnu89}, for version
7.2, it is \texttt{-std=gnu11}.
\item Do not use \texttt{sccs} for source code management.  Unless you are
forced to use a centralized source code management (CVS, Subversion, etc.) due
to historical reasons or while working on an existing project, always use a
\emsl{distributed} source code management system when starting a new project.
We recommend Git (\texttt{git}) or Mercurial (\texttt{hg}).
\item Debuggers and profilers are not part of the standard.
\end{itemize}


%%%%%

\begin{slide}
\sltitle{File name convention}
\begin{tabular}{ll}
\texttt{*.c} & the C language source code files\\
\texttt{*.cc} & the C++ language source code files\\
\texttt{*.h} & header files\\
\texttt{*.o} & object files\\
\texttt{a.out} & the default executable file name after the compilation
\end{tabular}

\begin{tabular}{ll}
\texttt{/usr/inc{}lude} & system header file root\\
\texttt{/usr/lib/lib*.a} & static libraries\\
\texttt{/usr/lib/lib*.so} & dynamic libraries
\end{tabular}
\end{slide}

\begin{itemize}
\item Static libraries -- code for used external functions is copied into a
target program.  Not used much nowadays.
\item Dynamic libraries -- the list of dynamic libraries needed are part of the
program, on execution the dynamic linker (path to the dynamic linker is also
part of the program, see page \pageref{RUNTIMELINKER}) loads them to memory and
relocates pointers.
\item Today, dynamic libraries are mostly used as they save disk space and you
do not need to recompile all the utilities and other program on library
upgrades.
\item In specific situations, static libraries are still needed though, for
example, in standalone binaries when booting an operating system.
\item The origin of the name \texttt{a.out} is as follows.  Initially, even
before the C was invented, there were no libraries, no loader or link editor in
the first version of the UNIX system: the entire source of a program was
presented to the assembler, and the output file with a fixed name that emerged
was directly executable.  So \texttt{a.out} means ``the output of the
assembler''.  Even after the system gained a linker and a means of specifying
another name explicitly, it was retained as the default executable result of a
compilation.  See \emph{Dennis M. Ritchie, The Development of the C Language}
paper, available freely.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Process of compilation}
\begin{center}
\input{img/tex/princip_prekladu.tex}
\end{center}
\end{slide}

\begin{itemize}
\item Non-trivial programs are often split into several source code files that
contain related functions.  Such files can be compiled independently, and you
can even use different languages and different compilers for each file.  The
advantage is the speed of building as only modified files are re-compiled (see
page \pageref{MAKE} on the \texttt{make} utility), and also flexibility as you
can use some of the files in other programs as well.
\item The \emph{compiler} compiles each file into a corresponding object file.
Instead of external function pointers in the compiled code, the object file
contains a table of global symbols.
\item Then, the \emph{linker} combines the built object files and used
libraries into an output file.  By default, it also resolves all the references
to make sure all symbols used are available. 
\item Used code from the static libraries is copied to the executable file.
When using dynamic libraries, the executable only contains a list of them, the
linking process is then performed by the runtime linker (aka loader) on the
program execution.  For more on the dynamic linking process, see page
\pageref{RUNTIMELINKER}.
\item To select whether to use static or dynamic libraries, you use options for
the linker.  By default, dynamic libraries are used nowadays.  The source code
is same in either case.  There is also a mechanism (\texttt{dlopen},
\texttt{dlsym}\dots) that allows to load an additional dynamic library during
the program execution, and use it.  For more information, see page
\pageref{DLOPEN}.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Compilation of one file: preprocesor}
\begin{center}
\input{img/tex/preprocesor.pstex_t}
\end{center}
\end{slide}

\begin{itemize}
\item The preprocessor performs macro expansion, conditional compilation, and
inserts included files.  It also removes comments.
\item The preprocessor output can be provided via \texttt{cc -E} or calling
\texttt{cpp} directly.  However, some compilers have the preprocessor
functionality built in so calling the external preprocessor may not get the same
results.  You can of course use the preprocessor for anything else where its
functionality comes in handy, not just for C source code.
\item In a situation where you need to fix code full of includes and conditional
compilation, the output after the preprocessor phase may be very helpful to
locate the problem.
\item \texttt{cpp} (or \texttt{cc -E}) also allow you to see the whole tree of
included files, printed on the standard error output.  For that, use a separate
\texttt{-H} option (not \texttt{-EH}) and redirect the output to
\texttt{/dev/null}:

\begin{verbatim}
$ gcc -E -H tcp/connect.c >/dev/null
. /usr/include/stdio.h
.. /usr/include/sys/cdefs.h
... /usr/include/sys/_symbol_aliasing.h
... /usr/include/sys/_posix_availability.h
.. /usr/include/Availability.h
... /usr/include/AvailabilityInternal.h
.. /usr/include/_types.h
... /usr/include/sys/_types.h
.... /usr/include/machine/_types.h
..... /usr/include/i386/_types.h
etc...
\end{verbatim}

\item You cannot nest comments in C so in order to temporarily disable code with
comments without deleting it, wrapping it in another comment will not work.
So, the preprocessor to your rescue -- use the conditional compilation feature:

\begin{verbatim}
...
#if 0
        /* some comment */
        some_function();
        /* another comment */
        another_function();
#endif
...
\end{verbatim}
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Compilation of one file:  compiler}
\begin{center}
\input{img/tex/kompilator.tex}
\end{center}
\end{slide}

\begin{itemize}
\item The picture is an example output for the x86 platform, 32-bit, with AT\&T
syntax.
\item Compilation from the C language into assembler.
\item The assembler output file is the result of \texttt{cc -S}.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Compilation of one file: assembler}
\begin{center}
\input{img/tex/assembler.pstex_t}
\end{center}
\end{slide}

\begin{itemize}
\item Again an example for the x86 platform, 32-bit.
\item Compilation from the assembler language into the object code.
\item The output file is the result of \texttt{cc -c}.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Compiler}
\renewcommand{\arraystretch}{1.1}
\begin{itemize}
\item volání:\\
\texttt{cc [\emph{options}] \emph{file} \dots}
\item the most important options:\\
\begin{tabular}{ll}
\texttt{-o \emph{file}} & output file name\\
\texttt{-c} & only compile, do not link\\
\texttt{-E} & only preprocessor\\ 
\texttt{-l} & link with the specified library\\
\texttt{-L\emph{directory}} & add a directory to search when using \texttt{-l}\\
\texttt{-O\emph{level}} & optimalization level\\
\texttt{-g} & compile with debug information\\
\texttt{-D\emph{jméno}} & define a macro for the preprocessor\\
\texttt{-I\emph{directory}} & add a directory to search for \texttt{\#include} files
\end{tabular}
\end{itemize}
\end{slide}

\begin{itemize}
\item \texttt{-l}/\texttt{-L} are actually options for the linker, ie. the
compiler will pass them on onto the linker.
\item Both the compiler and linker have an extensive list of additonal options
that influence the generated code and what warnings are printed during the
compilation/linking based on the chosen language and the standard.  See manual
pages for \texttt{cc}, \texttt{gcc}, and/or \texttt{ld}.
\end{itemize}

%%%%%

\pdfbookmark[1]{standard macros}{stdmacros}

\begin{slide}
\sltitle{UNIX standard macros}
\begin{tabbing}
\hskip 13em \= \kill
\verb#__FILE__#, \verb#__LINE__#,\\\verb#__DATE__#, \verb#__TIME__#,\\
\verb#__cplusplus#, etc.
\> are standard macros for the compiler \\\>C/C++\\
\verb#unix# \> always defined if on Unix\\
\verb#mips#, \verb#i386#, \verb#sparc# \> hardware architecture\\
\verb#linux#, \verb#__APPLE__#, \verb#sun#, \verb#bsd# \> operating system\\
\verb#_POSIX_SOURCE#,\\\verb#_XOPEN_SOURCE#
\> build using the specific standard\\
\end{tabbing}
\end{slide}

\begin{slide}
\sltitle{UNIX standard macros (cont.)}

To build using a specific standard, you need to define one of the macros below
before any \verb.#include..  Then include \texttt{unistd.h}.

\vspace{2ex}

\begin{tabular}{l@{\hspace{3em}}l}
\emsl{UNIX 98} &\verb.#define _XOPEN_SOURCE 500.\\
\emsl{SUSv3} &\verb.#define _XOPEN_SOURCE 600.\\
\emsl{SUSv4} &\verb.#define _XOPEN_SOURCE 700.\\
\emsl{POSIX1990} &\verb.#define _POSIX_SOURCE.
\end{tabular}
\end{slide}

\begin{itemize}
\item The way how it works is that you use specific macros to define what you
want (eg. \texttt{\_POSIX\_SOURCE}), and then you use other macros (eg.
\texttt{\_POSIX\_VERSION}) to find out what you actually got.  You always have
to include \texttt{unistd.h} after you set the macros and use a compiler that
supports what you want.  For example, below we tried to compile
\example{basic-utils/standards.c} which requires SUSv3, on a system supporting
SUSv3 (Solaris 10), using a compiler that only supports SUSv2 (the compiler
defined in SUSv3 is \texttt{c99}).  Note that the default behavior of your
compiler might be same as \texttt{c89}.

\begin{verbatim}
$ cat standards.c 
#define _XOPEN_SOURCE   600
/* you must #include at least one header !!! */
#include <stdio.h>
int main(void)
{
        return (0);
}
$ c89 basic-utils/standards.c 
"/usr/include/sys/feature_tests.h", line 336: #error: "Compiler or
options invalid; UNIX 03 and POSIX.1-2001 applications require
the use of c99"
cc: acomp failed for standards.c
\end{verbatim}
%\item zdroj maker pro standard tedy mù¾e být ji¾ na stranì
%\pageref{UNIXSTANDARDS} zmiòovaný hla\-viè\-ko\-vý soubor
%\texttt{feature\_tests.h} na Solarisu.
\item See the documentation for your compiler about what other macros can be
used.
\item See page \pageref{C_LANGUAGE} for more information on standards.
\item Regarding macros for specific standards, you can find very good
information in chapter 1.5 in [Rochkind]. See also
\example{basic-utils/suvreq.c}.

\begin{verbatim}
int
main(void)
{
#ifdef unix
        printf("Yeah!\n");
#else
        printf("Oh, no.\n");
#endif
        return (0);
}
\end{verbatim}
\item For an example on using \texttt{\_\_LINE\_\_}, see
\example{basic-utils/main\_\_LINE\_\_.c}
\end{itemize}

%%%%%

\pdfbookmark[1]{link editor}{linker}

\begin{slide}
\sltitle{Link editor (linker)}
\begin{itemize}
\item Invocation:\\
\texttt{ld [\emph{options}] \emph{soubor} \dots}\\
\texttt{cc [\emph{options}] \emph{soubor} \dots}
\item Often used options:\\
\begin{tabular}{ll}
\texttt{-o \emph{file}} & output file name (default \texttt{a.out})\\
\texttt{-l\emph{lib}} & link with library \texttt{lib\emph{lib}.so} or
\texttt{lib\emph{lib}.a}\\ 
\texttt{-L\emph{path}} & path to libraries (\texttt{-l\emph{lib}})\\
\texttt{-shared} & create a dynamic library\\
\texttt{-non\_shared} & create a static executable
\end{tabular}
\end{itemize}
\end{slide}

\begin{itemize}
\item A linker takes one or more objects generated by a compiler and creates a
binary executable, library, or another object file suitable for another linking
phase.
\item Note that different systems support different options.  For example,
\texttt{ld} on Solaris does not support \texttt{-shared} and
\texttt{-non\_shared}, and you have to use alternatives.
\item An option \texttt{-R} allows to specify where to look for libraries when
loading the executable via the dynamic linker.  That path might be different
from the path used during building the object, modifiable via \texttt{-L}.
\item Often you do not use the linker directly at all but pass all the linker
options via the compiler.
\end{itemize}

%%%%%

\pdfbookmark[1]{make}{make}

\begin{slide}
\sltitle{Maintaining programs (\texttt{make})}
\renewcommand{\baselinestretch}{1}
\begin{itemize}
\item \emsl{source code}\\
\begin{minipage}[t]{3.3cm}
main.c\\
\setbox0=\hbox{\begin{minipage}[t]{3.1cm}
\begin{verbatim}
#include "util.h"
main()
{
  msg();
}
\end{verbatim}
\end{minipage}}
\framebox{\box0}
\end{minipage}\hfill
\begin{minipage}[t]{2.2cm}
util.h\\
\setbox1=\hbox{\begin{minipage}[t]{2cm}
\begin{verbatim}
void msg();
\end{verbatim}
\end{minipage}}
\framebox{\vphantom{\texttt{\#include"}}\box1}
\end{minipage}\hfill
\begin{minipage}[t]{3.3cm}
util.c\\
\setbox0=\hbox{\begin{minipage}[t]{3.2cm}
\begin{verbatim}
#include "util.h"
msg()
{
  puts();
}
\end{verbatim}
\end{minipage}}
\framebox{\box0}
\end{minipage}
\end{itemize}
\begin{minipage}[t]{3.7cm}
\begin{itemize}
\item \emsl{dependencies}\\\vskip-1ex
\renewcommand{\arraystretch}{0.1}
\setlength{\tabcolsep}{0.25ex}
\begin{tabular}{lclcl}
\texttt{main.c} &            &                 &            & \\
                & $\searrow$ &                 &            & \\
		&            & \texttt{main.o} &            & \\
		& $\nearrow$ &                 & $\searrow$ & \\
\texttt{util.h} &            &                 &            & \texttt{prog} \\
                & $\searrow$ &                 & $\nearrow$ & \\
		&            & \texttt{util.o} &            & \\
		& $\nearrow$ &                 &            & \\
\texttt{util.c} &            &                 &            & \\
\end{tabular}
\end{itemize}
\end{minipage}\hfill
\begin{minipage}[t]{6.5cm}
\begin{itemize}
\item \emsl{file} \texttt{Makefile}\\
\setbox0=\hbox{\begin{minipage}[t]{5.9cm}
\begin{verbatim}
prog : main.o util.o
        cc -o prog main.o util.o
main.o : main.c util.h
        cc -c main.c
util.o : util.c util.h
        cc -c util.c
\end{verbatim}
\end{minipage}}
\framebox{\box0}
\end{itemize}
\end{minipage}
\end{slide}

\label{MAKE}.

\begin{itemize}
\item You could compile and link the program via one invocation of a compiler,
or write a simple shell script.  However, by using \texttt{make} you will only
update a target if its dependencies have been modified.  In other words, a well
written makefile will cause to re-compile only what is really necessary after
some files have been changed.  You could always do something like
``\texttt{make clean; make all}'' but if the whole compilation process takes
minutes or even hours, you really want a well written \texttt{Makefile}.
\item A line ``\verb#prog : main.o util.o#'' defines that before \texttt{prog}
is checked, the existence of
\texttt{main.o} and \texttt{util.o} needs to be checked, and also whether they
are up to date.  That check is performed recursively.  After that, the existence
of \texttt{prog} is checked and whether it is up-to-date, which means whether
the last modification time is younger than that of \texttt{main.o} and
\texttt{util.o}.  If yes, nothing else is done.  If not, the command on the next
line is performed.
\item \texttt{make} is usually run with an argument specifying the target to be
built; if run without arguments, the first target in the \texttt{Makefile} is
used.  That often is \texttt{all} which if the standard Unix convention is
followed, builds everything that can be built.  After that, \texttt{make
install} often follows, etc.
\item \texttt{make} is a universal tool, useful not just for building source
code.  For example, to build this material from various \LaTeX{} and other source
files, \texttt{make} is used as well.
\item Example: \example{basic-utils/Makefile01}.  Note that if a non-standard
make file is used, you need the \texttt{-f} option: ``\texttt{make -f
Makefile01}''.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Syntax of the \texttt{make} input file}
\begin{itemize}
\item \makebox[4cm][l]{target dependencies:}
\texttt{\emph{targets} : [\emph{files}]}
\item \makebox[4cm][l]{commands to be executed:} \verb#<Tab>#\texttt{\emph{command}}
\item \makebox[4cm][l]{comment:} \texttt{\#\emph{comment}}
\item \makebox[4cm][l]{line continuation:}
\texttt{\emph{line-begin}}\verb#\#\\
\makebox[4cm][l]{~} \texttt{\emph{line-continuation}}
\end{itemize}
\end{slide}

\begin{itemize}
\item \emsl{Note that the line with a command starts with a tabulator, not
spaces.}  Every command line is executed via its own shell invocation.  If
multiple commands need to be executed via the same shell process, all but the
last line needs to be terminated with a backslash.  See the following example
where the last two \texttt{echo} commands are part of the same \texttt{if}
construct.

\begin{verbatim}
$ cat basic-utils/Makefile02
all:
        @echo $$$$
        @echo $$$$
        @if true; then \
                echo $$$$; \
                echo $$$$; \
        fi
$ make -f Makefile02
5513
5514
5515
5515
\end{verbatim}

\item The backslash works as a word separator and a space is inserted.  See
the following example: \example{basic-utils/Makefile07}.
\item Using a double \texttt{\$} supresses the special meaning of a dollar sign,
see the next slide.
\item A character \texttt{@} at the beginning of a line supresses its printout.
Otherwise, \texttt{make} always prints out what is gonna be executed next.
\item For a dry run, ie. to see what would be executed, but do not execute
anything, use option \texttt{-n}.
\item A character \texttt{-} at the beginning of a line causes \texttt{make} to
ignore a non-zero return value (usually indicating a failure), otherwise
\texttt{make} reports the error and bails out right away.  Example:
\example{basic-utils/Makefile04}.
\item 
\begin{verbatim}
test1:
        false
        echo "OK"

test2:
        -false
        echo "OK"
\end{verbatim}
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Macros (\texttt{make})}
\begin{itemize}
\item macro definition:\\
\hspace*{5em}\texttt{name = string}
\item continuation via a backslash inserts a space
\item undefined macros are empty
\item ordering of macro definitions is not important
\item defining a macro on a command line: \\
\hspace*{5em}\texttt{make \emph{target} \emph{name}=\emph{string}}
\item macro invocation: \\
\hspace*{5em}\texttt{\$\emph{name}} (pouze jednoznakové
\texttt{\emph{name}}), \\
\hspace*{5em}\texttt{\$\{\emph{name}\}} or \texttt{\$(\emph{name})}
\item environment variables are accessible as macros (eg. \texttt{\$\{EDITOR\}})
\end{itemize}
\end{slide}

\begin{itemize}
\item If a macro is defined multiple times, the last definition rules, you can
see an example in \example{basic-utils/Makefile03}.
\item You cannot define a macro recursively, see
\example{basic-utils/Makefile05}:

\begin{alltt}
\$ cat basic-utils/Makefile05
M=value1
M=\$(M) value2
all:
        echo \$(M)
\$ make -f Makefile05
Variable M is recursive.
\end{alltt}
\item Often extended \texttt{make} versions are used, eg. GNU (\texttt{gmake})
or BSD.
\item To write a non-trivial \texttt{Makefile} that will work with
different \texttt{make} implementations is not a simple task.  Therefore
projects as GNU Automake exist.  For a simple conditional compilation where
based on the system we need to set different options, the following code might
come in handy.  A character ` is a back quote, and a ' is a normal single quote:

\begin{verbatim}
CFLAGS=`x=\`uname\`; \
        if [ $${x} = FreeBSD ]; then \
                echo '-Wall'; \
        elif [ $${x} = SunOS ]; then \
                echo '-v'; \
        elif [ $${x} = Linux ]; then \
                echo '-Wall -g'; \
        fi`

all:
        @echo "$(CFLAGS)"
\end{verbatim}

\item In other situations it is recommended or even needed to use utilities like
\texttt{autoconf} or \texttt{automake}.
\item Some \texttt{make} implementations support directives for conditional
processing, eg.  BSD make.  Example: \example{basic-utils/Makefile08.bsd}.
\item With the \texttt{-e} option, we can force \texttt{make} to ignore a
variable definition in the input file if an environment variable of the same
name exists.  By default \texttt{make} accepts environment variables only if
they are not defined in the input file.  Example:
\example{basic-utils/Makefile06}.
\item In general, \texttt{make} is a immensely powerful tool, just take a look
at system make files of any Unix-like system.  A typical feature of such build
systems is that there is no documentation on how it works internally so you have
to dig in deep if you need to understand or modify it -- and that usually is not
for the faint-hearted.
\end{itemize}

%%%%%

\pdfbookmark[1]{dynamic linker}{ldso}

\begin{slide}
\sltitle{Dynamic linker (loader)}

\begin{itemize}
\item the compilation phase requires all needed dynamic libraries to check
accessibility of used symbols
\item \emsl{loading external shared libraries into a running process happens on
program execution}. That is what a \emsl{dynamic linker} does  (\emph{run-time
linker}, \emph{loader}).
\item list of required dynamic libraries is in the \texttt{.dynamic} section of
an ELF object
\item system by default looks for shared libs in certain locations
\item located libraries are mapped to the process address space via
\funnm{mmap}() (will be later)
\end{itemize}
\end{slide}

\label{RUNTIMELINKER}

\begin{itemize}
\item An ELF object format is explained on page \pageref{ELF}.
\item In the ELF \texttt{.dynamic} section, you can add additional paths to
search for the libraries using tags \texttt{RUNPATH}/\texttt{RPATH}.
\item The process of an execution of a dynamically linked program works like
this:
\begin{itemize}
\item The kernel in \texttt{exec()} maps the program to a newly created process
address space and finds out what a dynamic linker is used (see \texttt{.interp}
below).
\item The kernel maps the dynamic linker to the process address space as well
and calls the linker's \texttt{main()} function.  As a dynamic linker is an
executable program by itself, it has \texttt{main()}.  You can usually also run
a dynamic linker on a command line if you want to, that is mostly useful for
debugging and experimenting with a dynamic linker.
\item The linker gets the list of required libraries from the program ELF header,
maps those libraries to the process address space, and calls their initialization
functions if those exist.  All dependencies not set as 
\emph{lazy} (see page \pageref{DLOPEN}) are mapped recursively via breadth
search.
\item The linker's job is done at that point and calls the program
\texttt{main()} function.
\item A process may continue to use the dynamic linker during program execution
via calls like \texttt{dlopen()} etc.  See page \pageref{DLOPEN} for more
information.
\end{itemize}
\item Note that the dynamic linker does not run as a separate process (unless
you run it like that) even that it has its own \texttt{main()} function.  It is
used within an address space of an executed program.  The program, dynamic
linker, and dynamic libraries constitute a single process.

\item The following examples \emsl{are from Solaris}.  Finding equivalent
commands and/or options on Linux is left as an excercise to the reader.
\begin{itemize}
\item ELF sections are listed via \texttt{elfdump -c} (GNU has
\texttt{objdump} and \texttt{readelf}).  More on program sections on page
\pageref{ELF}.
\item What a dynamic linker is used is in section \texttt{.interp}, see
''\texttt{elf\-dump -i}'' and ``\texttt{ld -I}''.  It means you could write your
own dynamic linker and set it via the \texttt{-I} option for \texttt{ld} to your
program.  It is needed to say such an enterprise would not be an easy feat at
all.
\item To list the dynamic section, use \texttt{elfdump -d}, dynamic libraries
are set as \texttt{NEEDED}.
\item Finding out shared object dependencies is very easy via the
\texttt{ldd} command (Solaris, Linux, BSD).  It displays paths to the specific
libraries (ie. full paths) that will be used if the program is run in the
same environment (see right below for more information).  The command resolves
the dependencies recursively so you will also see dynamic libraries that are used
by other libraries and not directly by the program.  To find out what exactly
depends on what, use the \texttt{-v} option.  macOS does not have \texttt{ldd},
use \texttt{otool -L} instead.
\item What libraries are eventually used when running the program could be
different from what \texttt{ldd} shows.  For example, 
one could use the \texttt{LD\_PRELOAD} mechanism.  For that reasons,
Solarisu has a \texttt{pldd} command which provides for a running process
library dependencies.  Example on \texttt{LD\_PRELOAD} with \texttt{gcc}: use
already mentioned \texttt{Ma\-ke\-file01}, and compile
\example{basic-utils/preload.c} like this: ``\texttt{gcc -shared -o
lib\-pre\-load.so preload.c}''.  Run the program then which interposes a system
call \texttt{close()}: ``\verb#LD_PRELOAD=./libpreload.so ./a.out#''.
\item Most of the information listed here can be found in a manual page for the
Solaris dynamic linker, \texttt{ld.so.1(1)}, and much more then in an excellent
\emph{Linkers and Libraries Guide} on \texttt{docs.oracle.com}.  If you use
FreeBSD, its dynamic linker is \texttt{ld-elf.so.1}, on Linux distros it is
usually \texttt{ld-linux.so.1}, it is \texttt{rld} on SGI IRIX etc.
\item You can also configure the dynamic linker via setting environment
variables.  For example, try this on Solaris:
\begin{verbatim}
LD_LIBRARY_PATH=/tmp LD_DEBUG=libs,detail date
\end{verbatim}
and to find out what options you have to debug the dynamic linker there:
\begin{verbatim}
LD_DEBUG=help date
\end{verbatim}
\item To tell the linker to look for dynamic libraries also in directories other
than the default ones (paths from \texttt{LD\_LIBRARY\_PA\-TH} are searched
first), use it like the following:
\begin{verbatim}
$ cp /lib/libc.so.1 /tmp
$ LD_LIBRARY_PATH=/tmp sleep 100 &
[1] 104547
$ pldd 104547
104547: sleep 100
/tmp/libc.so.1
/usr/lib/locale/cs_CZ.ISO8859-2/cs_CZ.ISO8859-2.so.3
\end{verbatim}
\item You can also edit ELF objects via \texttt{elfedit(1)} on Solaris.  You can
change \texttt{RUNPATH}, for example.
\end{itemize}
\item \label{EVIL_LDLIBPATH} In general, you should not use
\texttt{LD\_LIBRARY\_PATH} for anything else then debugging during the
development or when moving libraries between directories.  You can find lots of
articles on ``why is \texttt{LD\_LIBRARY\_PATH} evil?'' etc.  For example,
\url{http://xahlee.org/UnixResource\_dir/\_/ldpath.html}.

\par
This varible is often misused in the start-up scripts because the command(s)
is/are incorrectly linked and the dynamic linker would not otherwise find the
correct libraries.  The typical side effect, however, is that the program(s)
subsequently start(s) additional programs that use the same libraries but as all
children inherit the environment, those programs are forced to use libraries
from non-default directories, and possibly those contain libraries of different
versions from those that the programs were initially built with.  Quite often
this might be hard to find when something goes bad and you start seeing
unexpected behavior.  Commands like \texttt{pldd} come in handy in such
situation.
\end{itemize}

%%%%%

\pdfbookmark[1]{API/ABI}{APIABI}

\begin{slide}
\sltitle{API versus ABI}

API -- Application Programming Interface

\begin{itemize}
\item rozhraní pou¾ité pouze ve zdrojovém kódu
\item rozhraní \emsl{zdrojáku} vùèi systému, knihovnì èi vlastnímu kódu, tj.
napø. \texttt{exit(1)}, \texttt{printf("hello\bs{}n")} nebo
\texttt{my\_function(1, 2)}
\item \dots{}aby se stejný \emsl{zdrojový kód} mohl pøelo¾it na v¹ech
systémech podporující dané API
\end{itemize}

ABI -- Application Binary Interface

\begin{itemize}
\item low-level rozhraní \emsl{aplikace} vùèi systému, knihovnì èi jiné èásti
sama sebe
\item \dots{}aby se \emsl{objektový modul} mohl pou¾ít v¹ude tam, kde
je podporováno stejné ABI
\end{itemize}
\end{slide}

\label{API_ABI}

\begin{itemize}
\item Pøíkladem API je tøeba API definované normou POSIX.1.
\item ABI definuje konvenci volání (to jak program pøedá parametry funkci
a jak od ní pøevezme návratovou hodnotu), jaká jsou èísla systémových volání,
jak se systémové volání provede èi formát objektového modulu
a pøijímaných argumentù, viz pøíklad dole.
\item API knihovny pak definuje mimo jiné mno¾inu volání která jsou knihovnou
definována, jejich parametry a typy tìchto parametrù.
\item následná ukázka je pøíklad na to, kdy vývojáø zmìní velikost argumentù v
bajtech (tj. zmìní ABI knihovny), a nahradí novou verzí tu starou. V¹imnìte
si, ¾e dynamický linker toto nezjistí; nemá toti¾ jak, øídí se podle jména
knihovny v dynamické sekci programu, a to se nezmìnilo. Uvedená zmìna je sice
i zmìna v API a problém by se odstranil, kdybychom \texttt{main.c} znovu
pøelo¾ili se zmìnìným øádkem deklarace funkce \texttt{add}. To je ale èasto
problém (pøe\-klá\-dej\-te celý systém jen kvùli tomu), proto je tak dùle¾ité
dodr¾ovat zpìtnou kompatibilitu v ABI u knihoven.

Výsledek následujícího pøekladu knihovny, programu a jeho spu¹tìní je jak
bychom oèekávali (pou¾it \texttt{cc} ze SunStudio, pro \texttt{gcc} pou¾ijte
místo \texttt{-G} volbu \texttt{-shared}; novìj¹í \texttt{gcc} navíc neznají
\texttt{-R} a je místo toho nutné pou¾ít \texttt{-Xlinker -R .}:

\begin{verbatim}
$ cat main.c 
int my_add(int a, int b);

int
main(void)
{
        printf("%d\n", my_add(1, 2));
        return (0);
}

$ cat add.c
int
my_add(int a, int b)
{
        return (a + b);
}

$ cc -G -o libadd.so add.c
$ cc -L. -ladd -R. main.c 
$ ./a.out 
3
\end{verbatim}

Nyní ale pøi¹la dal¹í verze knihovny se stejným jménem, a ve funkci
\texttt{my\_add}
nastala zmìna v typu argumentù, kde místo 4-bajtového integeru se pou¾ije
64-bitový celoèíselný typ. Program ale o nièem neví, nechá se spustit a vrátí
chybnou hodnotu:

\begin{verbatim}
$ cat add2.c
int64_t
my_add(int64_t a, int64_t b)
{
        return (a + b);
}

$ cc -G -o libadd.so add2.c 
$ ./a.out 
-1077941135
\end{verbatim}

\item \label{ABI_MAIN} pøíklad: \example{lib-abi/abi-main.c} (komentáø v
souboru napoví jak pou¾ít os\-tat\-ní soubory ve stejném adresáøi)


\item zde pak pøichází ke slovu verzování knihoven, tj. je nutné ``nìco''
zmìnit tak, aby po instalaci nové knihovny ne¹lo program spustit bez jeho
rekompilace.
\item \label{OPENSSL} binární nekompatibilita je napøíklad problém u OpenSSL.
Vìtve 0.9.x a 0.9.y nejsou ABI kompatibilní. Konkrétnì verze 0.9.7 a 0.9.8,
v roce 2009 stále obì pou¾ívané. Verze rozli¹ené písmeny, tj. napøíklad 0.9.8a a
0.9.8g, jsou ABI kompatibilní. Nìkteré systémy stále pou¾ívají pouze 0.9.7
(FreeBSD 6.x, Solaris 10), jiné jen 0.9.8 (Solaris 11 Express), dal¹í integrují 
obì vìtve (rùzné Linuxové distribuce). Problém je, máte-li napøíklad program pro
Solaris~10 pou¾ívající \texttt{libcrypto.so} knihovnu, který chcete pou¾ívat i
na Solaris 11 Express (to je jinak díky zpìtné binární kompatibilitì striktnì
dodr¾ované mezi "major" verzemi Solarisu mo¾né - napø. program který bì¾el
na Solarisu 2.6 z roku 1997 mù¾e bì¾et na Solarisu 10 z roku 2009 bez nutnosti
rekompilace - to se týká systému a knihoven s ním dodávaných).
Jediné správné re¹ení je zkompilovat pro nový systém, pøípadnì manuálnì
zkopírovat potøebné verze knihoven, co¾ ale zdaleka není ideální -- program
nebude fungovat s novì nainstalovaným systémem, ale nikdo najednou neví,
proè to funguje na stejném systému vedle, a kdy¾ se to zjistí tak je opìt
potøeba manuální zásah, a pochybuji o tom, ¾e autor ``øe¹ení'' bude instalovat
opravené verze pøi výskytu bezpeènostních chyb. Nekompatibilita 0.9.x verzí je
dùvodem, proè je v dynamické sekci knihovny i její celé èíslo (bez písmen, ta
jak ji¾ víme nejsou pro ABI kompatibilitu u OpenSSL dùle¾itá), a díky tomu je
pak toto èíslo uvedeno i v ka¾dém programu proti knihovnì slinkovanému:
\begin{verbatim}
$ elfdump -d /usr/sfw/lib/libcrypto.so.0.9.8 | grep SONAME
   [7]  SONAME            0x1               libcrypto.so.0.9.8

$ elfdump -d /usr/bin/ssh | grep NEEDED
   [1]  NEEDED            0x3c99            libsocket.so.1
   [3]  NEEDED            0x3cb1            libnsl.so.1
   [5]  NEEDED            0x3cc6            libz.so.1
   [7]  NEEDED            0x3d12            libcrypto.so.0.9.8
   [9]  NEEDED            0x3cd9            libgss.so.1
  [10]  NEEDED            0x3cfe            libc.so.1
\end{verbatim}
\begin{itemize}
\item pøíèinou zpìtné nekompatibility OpenSSL verzí je to, ¾e z historických
dùvodù jsou nìkteré pou¾ívané struktury v hlavièkových souborech. Tyto struktury
je ale nìkdy nutné roz¹íøit, napøíklad pøi vývoji nové funkcionality. Tím
nastane situace, ¾e program pøelo¾ený s verzí 0.9.7 by pøedal novìj¹í knihovnì
``men¹í'' strukturu, respektive nová knihovna by pøistupovala ve staré struktuøe
na polo¾ky, které neexistují -- a tedy by pøistupovala k pamìti, která programu
nebyla pøidìlena. To mù¾e zpùsobit pád programu (pøístup na nenamapovanou
stránku), mù¾e to fungovat dále (v dané pamìti je to, co se tam typicky oèekává,
napøíklad nula), nebo se to zaène chovat ``podivnì'' (v pamìti bylo nìco, co v
dané situaci oèekávané nebylo). Problém v OpenSSL je, ¾e nyní ji¾ není technicky
jednoduché z tìchto struktur udìlat interní a navenek pracovat jen s
transparentními referencemi objektovým pøístupem, co¾ by umo¾nilo dìlat
libovolné zmìny ve strukturách, ani¾ by to program ovlivnilo.
\item bì¾nì vidìné øe¹ení zpùsobené neznalostí vìci je vytvoøit symbolický link,
napøíklad na Solarisu 11 udìlat 0.9.7 symlink na existující knihovnu verze
0.9.8. Èastý výsledek je pak pád programu a údiv autora symlinku. Nìkdy to
naopak funguje, proto¾e program náhodou nepou¾ívá pøíslu¹né struktury, a to je
jasným dùkazem pro aktéra, ¾e øe¹ení musí být správné. Mù¾e se ale stát, ¾e
program struktury nepou¾ívá pøi konkrétním provedeném testu, ale zaène dìlat
problémy a¾ pøi ¾ivém nasazení. Tady je jediná rada -- pokud si opravdu nejste
jisti ¾e víte, co dìláte a nejste si jistí svoji detailní znalostí kódu programu
i knihoven, vyhnìte se tomu. Nebo riskujte, ale ji¾ víte jak to mù¾e skonèit.
\item zdánlivì jednoduché øe¹ení dodávat více verzí OpenSSL s jedním sys\-té\-mem
pøiná¹í zase jiné problémy -- obtí¾nìj¹í vývoj systému, obtí¾nìj¹í správu
systému (pøi výskytu bezpeènostní chyby je èasto nutné patchovat v¹echny
instalované verze), problémy s nepøímými závislostmi obsahující více verzí dané
knihovny apod.
\item upgrade verze OpenSSL v existujícím systému je také vìc, které je dobré se
vyhnout, respektive toto tì¾ko vyøe¹íte vydáním patche pro existující systémy --
uva¾te ¾e zákazník pou¾ívá své nebo jím koupené programy, které závisí na
existující verzi. A tu byste mu najednou upgradovali na verzi vy¹¹í, ABI
nekompatibilní.
\item typickým pøíkladem, kdy se pou¾ívá transparentní typ jako reference, co¾
umo¾òuje dal¹í roz¹iøování pod ní le¾ící struktury bez rizika vý¹e uvedených
problémù, je typ POSIX vláken. Struktura typu \texttt{pthread\_t} (strana
\pageref{PTHREAD_T}) je interní zále¾itostí knihovny. Typicky je to integer, ale
to by programátora nemìlo vùbec zajímat. Samozøejmì souborový deskriptor èi
èíslo procesu jsou podobné pøípady, ale na pøíkladu vláken je to lépe vidìt.
\end{itemize}
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Debugger \texttt{dbx}}
\begin{itemize}
\item Volání:\\
\texttt{dbx [ \emph{options} ] [ \emph{program} [ \emph{core} ] ]}
\item Nejbì¾nìj¹í pøíkazy:\\
\renewcommand{\arraystretch}{0.9}
\begin{tabular}{ll}
\texttt{run [\emph{arglist}]} & start programu\\
\texttt{where} & vypi¹ zásobník\\
\texttt{print \emph{expr}} & vypi¹ výraz\\
\texttt{set \emph{var} = \emph{expr}} & zmìò hodnotu promìnné\\
\texttt{cont} & pokraèování bìhu programu\\
\texttt{next}, \texttt{step} & proveï øádku (bez/s vnoøením do funkce)\\
\texttt{stop \emph{condition}} & nastavení breakpointu\\
\texttt{trace \emph{condition}} & nastavení tracepointu\\
\texttt{command \emph{n}} & akce na breakpointu (pøíkazy následují)\\
\texttt{help [\emph{name}]} & nápovìda\\
\texttt{quit} & ukonèení debuggeru
\end{tabular}
\end{itemize}
\end{slide}

\begin{itemize}
\item základní øádkový symbolický debugger, aby bylo mo¾né ho plnì vyu¾ít, musí
být program pøelo¾en s ladicími informacemi (\texttt{cc -g}). Ladìný program se
startuje z debuggeru pøíkazem \texttt{run}, nebo se debugger pøipojí k ji¾
bì¾ícímu procesu. Pomocí \texttt{dbx} lze analyzovat i havarovaný program, který
vygeneroval soubor \texttt{core}.
\item je mo¾né ho najít napø. na Solarisu, av¹ak na Linuxu a FreeBSD defaultnì
není.
\item pro debugging se zdrojovými kódy nestaèí pou¾ít volbu \texttt{-g}, je
zároveò nutné mít i zdrojáky a objektové moduly tam, kde byly pøi pøekladu. To
je typicky bì¾ná situace, proto¾e ladíte na stroji, kde zároveò i vyvíjíte.
Pokud tomu tak není, je nutné si zdrojáky a objektové moduly zajistit, pokud k
nim vede jiná cesta, lze pou¾ít dbx pøíkaz \texttt{pathmap}.
\item \texttt{gdb}-kompatibilní mód se spustí pøes \texttt{gdb on}. Pokud vás
zajímá, jaký má \texttt{dbx} ekvivalentní pøíkaz ke konkrétnímu \texttt{gdb}
pøíkazu, pomù¾e vám \texttt{help FAQ}; hned první otázka je ``A.1  Gdb does
$<$something$>$; how do I do it in dbx?''
\item pokud nepou¾ijete pøepínaè -g, bude vám dbx na Solarisu stále
platný, proto¾e zobrazí argumenty funkcí. U BSD systémù a linuxových distribucí
-g pou¾ít musíte, jinak vám debuggery moc nepomohou. Kdy je to na Solarisu
platné i bez -g je v vidìt v pøíkladu \example{debug/dbx.c}. Pøi kompilaci
s gcc a pou¾ití gdb neuká¾e pøíkaz \texttt{where} parametry funkce
\texttt{crash()} zatímco se Solaris Studio kompilerem a debuggerem dbx se
parametry funkce vypí¹í, tak¾e je vidìt hodnota která se pøiøazovala.
\item pøíklad: \example{debug/coredump.c}. Po pøelo¾ení a spu¹tìní program
spadne a zanechá core dump.

\begin{verbatim}
$ cc coredump.c
$ ./a.out 
Segmentation Fault (core dumped)
$ dbx ./a.out core
Reading a.out
core file header read successfully
Reading ld.so.1
Reading libc.so.1
program terminated by signal SEGV (no mapping at the fault address)
0x08050a05: bad_memory_access+0x0015:   movb     %al,0x00000000(%edx)
(dbx) where                                                                  
=>[1] bad_memory_access(0x8047ae8, 0x8047a44, ...
  [2] main(0x1, 0x8047a50, 0x8047a58, 0x8047a0c), at 0x8050a1b 
\end{verbatim}

Vidíme, ve které funkci to spadlo a je mo¾né se vypsat zásobník. Nevidíme ale
pøesnì øádku kódu, kde nastal problém. Pro to je nutné pøelo¾it program s
ladícími symboly, tj. ``\texttt{cc -g coredump.c}''. Zájemce o více informací o
debugging pod unixem odkazuji na navazující pøedná¹ku ``Programování v UNIXu
II.'' (NSWI138).

\begin{verbatim}
$ cc -g coredump.c
$ dbx ./a.out core
Reading a.out
core file header read successfully
Reading ld.so.1
Reading libc.so.1
program terminated by signal SEGV (no mapping at the fault address)
Current function is bad_memory_access
    8           x[0] = '\0';
(dbx) 
\end{verbatim}

\end{itemize}


%%%%%

\begin{slide}
\sltitle{GNU debugger \texttt{gdb}}
\begin{itemize}
\item Volání:\\
\texttt{gdb [ \emph{options} ] [ \emph{program} [ \emph{core} ] ]}
\item Nejbì¾nìj¹í pøíkazy:\\
\renewcommand{\arraystretch}{0.9}
\begin{tabular}{ll}
\texttt{run [\emph{arglist}]} & start programu\\
\texttt{bt} & vypi¹ zásobník\\
\texttt{print \emph{expr}} & vypi¹ výraz\\
\texttt{set \emph{var} = \emph{expr}} & zmìò hodnotu promìnné\\
\texttt{cont} & pokraèování bìhu programu\\
\texttt{next}, \texttt{step} & proveï øádku (bez/s vnoøením do funkce)\\
\texttt{break \emph{condition}} & nastavení breakpointu\\
\texttt{help [\emph{name}]} & nápovìda\\
\texttt{quit} & ukonèení debuggeru
\end{tabular}
\end{itemize}
\end{slide}

\begin{itemize}
\item GNU obdoba \texttt{dbx}. Mód kompatibilní s \texttt{dbx} spustíte pøes
\texttt{-dbx}.
\item na rùzných platformách existují i debuggery s grafickým
rozhraním, napø. \texttt{workshop} (Solaris), \texttt{cvd} (IRIX),
\texttt{xxgdb} (GNU), \texttt{ddd} (GNU). Èasto fungují jako
nadstavby nad \texttt{dbx}, \texttt{gdb}.

\item \begin{verbatim}
#include <stdio.h>
int main(void) {
  printf("hello, world\n");
  return (0);
}
$ cc -g main.c 
$ gdb -q a.out
(gdb) break main
Breakpoint 1 at 0x8048548: file main.c, line 4.
(gdb) run
Starting program: /share/home/jp/src/gdb/a.out 

Breakpoint 1, main () at main.c:4
4         printf("hello, world\n");
(gdb) next
hello, world
5         return (0);
(gdb) c
Continuing.
Program exited normally.
(gdb) q
\end{verbatim}
\item debuggery jsou výbornými pomocníky pokud vá¹ program konèí na chyby typu
``segmentation error'' -- tj. kdy¾ zkusíte nekorektnì pøistoupit do pamìti,
napøíklad tam kde nemáte co dìlat. Kdy¾ pøi pøekladu pou¾ijete option
\texttt{-g}, uká¾e vám pak debugger pøesnì èíslo øádku, kde nastal problém.
Konkrétní pøíklad (proè se vlastnì tento program chová jak se chová??? Hint:
zkuste pøelo¾it na Solarisu pøekladaèem \texttt{cc} a spustit):
\begin{verbatim}
$ cat -n main.c
     1  int
     2  main(void)
     3  {
     4          char *c = "hey world";
     5          c[0] = '\0';
     6          return (0);
     7  }
}
$ gcc -g main.c
$ ./a.out
Bus error (core dumped)
$ gdb a.out a.out.core
...
Core was generated by `a.out'.
Program terminated with signal 10, Bus error.
...
#0  0x080484e6 in main () at main.c:5
5               c[0] = '\0';
\end{verbatim}
\end{itemize}

%%%%%
\pagebreak
\pdfbookmark[0]{basic terms and conventions of UNIX and its API}{terms}

\begin{slide}
\sltitle{Contents}
\slidecontents{2}
\end{slide}

%%%%%

\pdfbookmark[1]{standard header files}{stdhdrs}

\begin{slide}
\sltitle{Standard header files (ANSI~C)}
\renewcommand{\arraystretch}{1}
\begin{tabular}{l@{\hspace{3ex}\dots\hspace{3ex}}l}
\texttt{stdlib.h} & basic macros and functions\\
\texttt{errno.h} & error handling\\
\texttt{stdio.h} & input and output\\
\texttt{ctype.h} & character handling\\
\texttt{string.h} & string handling\\
\texttt{time.h} & time and date handling\\
\texttt{math.h} & math functions\\
\texttt{setjmp.h} & far jumps\\
\texttt{assert.h} & debugging macros/functions\\
\texttt{stdarg.h} & variable arguments processing\\
\texttt{limits.h} & implementation dependent constants\\
\texttt{signal.h} & signal handling
\end{tabular}
\end{slide}

\begin{itemize}
\item The \emph{header file} is a file that contains declarations 
(\emph{forward declaration}) of functions, variables and macro definitions.
From preprocessor's point of view this is simple file in C language.
\item \emsl{These header files are not specific to UNIX. They are part of
the ANSI~C standard, that is included in POSIX.1 (page \pageref{C_LANGUAGE})
It is important to realize that every system that supports
ANSI~C has to have these files, notwithstanding whether it supports POSIX.1.}
\item Appropriate header file for given function can be looked up using the
function's man page, e.g. this is the beginning of \texttt{memcpy} man page
on Solaris:
\begin{verbatim}
Standard C Library Functions                         memory(3C)

NAME
   memory, memccpy, memchr, memcmp, memcpy, memmove,  memset  -
   memory operations

SYNOPSIS
   #include <string.h>
...
...
\end{verbatim}
\item Individual macros contained in these files are usually not explained,
their meaning can be looked up in relevant specifications which are on-line.
On some systems (Solaris) individual header files have their own manual page
(e.g. \texttt{man stdlib.h}).
\item The \texttt{assert} macro is possible to remove during the compilation
using the \texttt{NDEBUG} define. Example: \example{assert/assert.c}.

\begin{verbatim}
cat assert.c 
#include <assert.h>

int
main(void)
{
        assert(1 == 0);
        return (13);
}
$ cc assert.c 
$ ./a.out 
Assertion failed: 1 == 0, file assert.c, line 6
Abort (core dumped)
$ cc -DNDEBUG assert.c 
$ ./a.out 
$ echo $?
13
\end{verbatim}
\end{itemize}


%%%%%

\begin{slide}
\sltitle{Standard header files (2)}
\begin{tabular}{l@{\hspace{3ex}\dots\hspace{3ex}}l}
\texttt{unistd.h} & standard symbolic constants and types \\
\texttt{sys/types.h} & data types \\
\texttt{fcntl.h} & file control options \\
\texttt{sys/stat.h} & information on files \\
\texttt{dirent.h} & directory entry format \\
\texttt{sys/wait.h} & waiting for children \\
\texttt{sys/mman.h} & memory mapping \\
\texttt{regex.h} & working with regular expressions \\
\end{tabular}
\end{slide}

\begin{itemize}
\item These headers are part of the UNIX specification.
\item Looking into these header files may be worth your while.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Standard header files (3)}
\begin{tabular}{l@{\hspace{3ex}\dots\hspace{3ex}}l}
\texttt{sys/socket.h} & network communication \\
\texttt{arpa/inet.h} & definitions for internet operations \\
\texttt{pthread.h} & POSIX threads \\
\texttt{semaphore.h} & POSIX semaphores \\
\texttt{sys/ipc.h} & System~V IPC \\
\texttt{sys/shm.h} & System~V shared memory \\
\texttt{sys/msg.h} & System~V messages \\
\texttt{sys/sem.h} & System~V semaphores \\
\end{tabular}
\end{slide}

\begin{itemize}
\item There are also many other standard header files.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Konvence pøedávání parametrù a environmentových promìnných

\pdfbookmark[1]{argv, argc}{args}

\begin{slide}
\sltitle{Function \texttt{main()}}
\renewcommand{\baselinestretch}{0.4}
\begin{itemize}
\setlength{\itemsep}{-0.5ex}
\setlength{\topsep}{1\itemsep}
\item function \texttt{main()} is called upon program execution
\item \texttt{int \funnm{main} (int \emph{argc}, char *\emph{argv}[]);}
    \begin{itemize}
    \item \texttt{argc} \dots number of command line arguments
    \item \texttt{argv} \dots array of command line arguments
	\begin{itemize2}
	\item \texttt{argv[0]} is a executed program name (without path)
	\item the last item is \texttt{argv[argc] == NULL}
	\end{itemize2}
    \item returnin from \texttt{main()} or callin \texttt{exit()} terminates the
    process
    \item standard return values are \verb#EXIT_SUCCESS# (0) a
    \verb#EXIT_FAILURE# (1)
    \end{itemize}
\end{itemize}

\begin{center}
\input{img/tex/main.pstex_t}
\end{center}
\end{slide}

\begin{itemize}
\item The first argument (of type \texttt{int}) is the number of arguments on a
command line, including argument 0 -- the program name.  The second argument is
an array of strings representing such command line arguments.  There is a
terminating \texttt{NULL} as the last array item.  Note that \texttt{NULL} is
different from an empty string.
\item To go through all the command line arguments, you can either use
\emph{argc} or test for \texttt{NULL} in \texttt{argv[i]}.
\item \label{SHELL_ARGV0} \texttt{argv[0]} is sometimes a source of additional
information.  For example, commands \texttt{cp}, \texttt{mv} and \texttt{ln} may
be linked to the same executable (Solaris).  The value of \texttt{argv[0]} then
tells the process what function it is supposed to perform.  Another example -- if
the first character of a shell process \texttt{argv[0]} is set to ``-'' it means
the shell process is supposed to act as a login shell (check the \texttt{bash}
man page, section INVOCATION, for more information on what being a login shell
means).  In the process listing then you will see ``\texttt{-bash}''.  This
convention is not part of the UNIX specification for \texttt{sh} but it has been
already used in the Bourne shell on UNIX V7 (1979) and other shells followed the
suite. 
\item We already know that upon the program execution, the dynamic linker
eventually passes the control to function \texttt{main}, as explained on page
\pageref{RUNTIMELINKER}.  If the \texttt{main} function is missing, the
compilation fails during the linking phase.  When \texttt{main} finishes it
means the process finishes.  You can also use functions \texttt{exit()} or
\verb#_exit()# from anywhere in the program, ie. not just from function
\texttt{main}.
\item Passing the environment in the third parameter of type
\texttt{char**} is not part of the normative part of the C standard, only the
informative one.  C compilers typically support that though.
The \texttt{main} variant with the 3rd parameter looks like this:\\ \texttt{int
\funnm{main}(int \emph{argc}, char *\emph{argv}[], char *\emph{envp}[]);}
\item The return value type of \texttt{main} should be always \texttt{int}.
\emsl{Only lower 8 bits from that integer are only used though.}  It is always a
non-negative number.  Note that in contrast to the C convention, the \texttt{0}
return value means a success in a Unix shell, and a non-zero value means a
failure.  A typical construct in a shell looks like this:

\begin{verbatim}
if prog; then
        echo "success"
else
        echo "failure"
fi
\end{verbatim}

or:

\begin{verbatim}
prog && echo "success" || echo "failure"
\end{verbatim}
Example: \example{main/return-256.c}.
\item \label{RETURN255} Never use \texttt{return (-1)} in \texttt{main} and
neither \texttt{exit(-1)}.  Based on the information in the previous paragraph,
from \texttt{-1} you will get \texttt{255} as the return value you get in the
shell in \texttt{\$?}.  It just creates confusion.
\item It is very reasonable to use only \texttt{EXIT\_SUCCESS} (\texttt{0}) and
\texttt{EXIT\_FAILURE} (\texttt{1}) unless there is a valid reason for other
values.  Sometimes you might need more values to distinguish between failures.
For example, the \texttt{passwd} command on Solaris have quite a few of them, go
check its manual page if interested, section \texttt{EXIT STATUS}. Example:
\example{main/return-negative-1.c}.
\item The difference between function \texttt{exit()} and \verb#_exit()# is that
\texttt{exit} also flushes and closes streams (try it out with \texttt{printf()}
\emsl{without} printing a new line), and calls functions registered via
\texttt{atexit()}, and possibly other actions based on a specific system.
Example: \example{exit/exit.c}
\item \label{MAIN_C} Example on printing out commnd line arguments:
\example{main/print-argv.c}
\item If a process is killed by a signal, you can get the signal number from its
return value as presented by the shell.  See page
\pageref{SHELLRETVALUEFORSIGNALS}.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Environment variables}
\begin{itemize}
\item the list of \emph{environment
variables} is passed as\\ \texttt{extern char
**\funnm{environ};}
\item it is an array of strings terminated by \texttt{NULL} of the
format: \texttt{\emph{variable\_name}=\emph{value}}
\end{itemize}
\begin{center}
\input{img/tex/environ.pstex_t}
\end{center}
\end{slide}

\begin{itemize}
\item A shell passes an executed program those variables marked as exported
(in Bourne-like shells via an internal command \texttt{export \emph{variable}}).
After you export a variable, you do not need to export it again after its value
is changed.  The command \texttt{env} prints current enviroment variables.
You can also add a variable to the environment of an executed program without
changing the environment of your current shell:

\begin{verbatim}
$ date
Sun Oct  7 13:13:58 PDT 2007
$ LC_TIME=fr date
dimanche  7 octobre 2007 13 h 14 PDT
\end{verbatim}

It may not work like that in your shell as very probably your system will not
have a french localization package installed.
\item When replacing the current process image with a different program (page
\pageref{EXEC}), the child will by default get the full environment from its
parent.  You can pass a different array as an argument to the function
\texttt{exec()}, including passing an empty one.
\item Different commands use different environment variables.  That should be
documented in their respective manual pages, sometimes in a separate section
named \emph{ENVIRONMENT} or \emph{ENVIRONMENT VARIABLES}.
\item For example, the \texttt{man} command uses \texttt{PAGER}, \texttt{vipw}
uses \texttt{EDITOR} etc.  The variables are usually in caps but it is just a
convension.  \texttt{wget} does not follow that, for example, it uses
\texttt{http\_proxy} and \texttt{https\_proxy} as environment variables to set
the proxy to be used, and other lower case variables as well.
\item If \emph{envp} is the 3rd argument of \texttt{main} it is the same pointer
as is in the standard global variable \texttt{environ}.
\item Example: \example{main/print-env.c} (see below how to clear out inherited
environment from the shell using the \texttt{env} command):

\begin{verbatim}
$ cc print-env.c
$ env - XXX=yyy aaa=ABC ./a.out
aaa=ABC
XXX=yyy
\end{verbatim}
\end{itemize}


%%%%%

\pdfbookmark[1]{getenv, putenv, setenv}{envfuncs}

\begin{slide}
\sltitle{Manipulating the environment}
\begin{itemize}
\item it is possible to replace \texttt{environ} with a different array but in
general you should not do that
\item \texttt{char *\funnm{getenv} (const char *\emph{name});}
    \begin{itemize}
    \item return value of \emph{name}
    \end{itemize}
\item \texttt{int \funnm{putenv} (char *\emph{string});} 
    \begin{itemize}
    \item inserts a string \texttt{\emph{name}=\emph{value}} into the
    environment (adds a new or modifies an existing variable)
    \end{itemize}
\item changes are propagated into children upon their creation
\item there are also functions \funnm{setenv}() a \funnm{unsetenv}()
\end{itemize}
\end{slide}

\begin{itemize}
\item Read the description for \texttt{environ} in SUSv4 before assigning a new
value to the variable as there are important information there you should know.
\item When using \texttt{putenv}, the string will become part of the
environment, nothing is copied.  You must not use automatic variables for such
strings.  Use \texttt{setenv} to copy the value into the environment.  Example:
\example{main/putenv.c}.
\item Changes in a child never changes its parent environment as those arrays
reside in separate address spaces.
\item Another difference between \texttt{putenv} and \texttt{setenv} is that in
\texttt{setenv} one can say whether an existing variable should be overwritten
or not. Function \texttt{putenv} always overwrites an existing variable.
\item Example:

\begin{verbatim}
int
main(void)
{
        printf("%s\n", getenv("USER"));
        return (0);
}
$ ./a.out 
janp
\end{verbatim}

\item As \texttt{environ} is just an array of pointers, you may find code that
directly manipulates it.  However, any application that directly modifies the
pointers to which the environ variable points has undefined behavior according
to SUSv4, and that is possibly exacerbated if the functions introduced above are
used while doing that.  Do not write code like that.
\item Example: \example{main/getenv.c}
\item Note that there is a difference between setting a variable to an empty
string and removing the variable from the environment via \texttt{unsetenv}.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Command arguments processing}
\begin{itemize}
\item common notation for shell: \verb#program -option arguments#
\item options are in the form of \texttt{-x} or \texttt{-x \emph{value}},
where \texttt{x} is alphanumeric, \texttt{\emph{value}} is arbitrary string
\item multiple options can be unified: \texttt{ls -lRa}
\item '\texttt{--}' or first argument not starting with '\texttt{-}'
marks end of options, the following arguments are not considered options even
if they start with '\texttt{-}'.
\item this form of arguments is required by the standard and can be processed
using the \texttt{getopt} function.
\end{itemize}
\end{slide}

\begin{itemize}
\item The arguments can of course be processed using custom function however
the standard function is sufficient for the overwhelming majority of use cases.
\item The options can be repeated however it makes sense only in specific
cases.
\item The ordering of the options can be important and it depends on the
application to specify the ordering.
\item The UNIX standard defines 13 rules that very precisely define the naming
of commands and the format of options. For example the name of the command
should be lower case, 2--9 characters long and using only chracters from
portable character set. Arguments without options should be possible to group
after '--', etc.
\item Using numbers of options is old fashioned; reportedly SUSv3 mentions that.
\item Watch out for GNU command line utilities and its strange permutations
of options and arguments.
\item The \texttt{-W} option should be reserved for vendor options, i.e. for
non-portable extensions.
\end{itemize}

%%%%%

\pdfbookmark[1]{getopt}{getopt}

\begin{slide}
\setlength{\baselineskip}{0.8\baselineskip}
\sltitle{Options processing: \texttt{getopt()}}
\begin{tabbing}
\texttt{int \funnm{getopt}(}\=\texttt{int \emph{argc},
char *const \emph{argv}[],}\\
\>\texttt{const char *\emph{optstring});}\\
\texttt{extern char *\emph{optarg};}\\
\texttt{extern int \emph{optind}, \emph{opterr}, \emph{optopt};} 
\end{tabbing}
\begin{itemize}
\item the function receives command line parameters and processes and returns
one option. If given option has an argument, it is set in the
\texttt{optarg} variable.
\item when all options are processed, it returns -1 and the \texttt{optind} 
variable contains the index of first unprocessed argument of the program.
\item possible options are passed in the \texttt{optstring} string.
If an options has mandatory argument, its character is followed by '\texttt{:}'
in the string.
\item on error (unknown option, argument missing) the function returns
'\texttt{?}', saves the option character into the \texttt{optopt} variable.
\end{itemize}
\end{slide}

\begin{itemize}
\item Usually the \texttt{getopt} function is used first to process options
and then the rest is processed using custom functions; the remaining arguments
are often file names and such.
\item By convention the optinons in the \texttt{optstring} variable are sorted.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Example of using \texttt{getopt()}}
\setlength{\baselineskip}{0.8\baselineskip}
\begin{alltt}
struct \{
    int a, b; char c[128]; 
\} opts; 
int opt; char *arg1; 

while((opt = \emprg{getopt}(argc, argv, "abc:")) != -1) 
    switch(opt) \{ 
        case 'a': opts.a = 1; break; 
        case 'b': opts.b = 1; break; 
        case 'c': strncpy(opts.c, \emprg{optarg},
            sizeof (opts.c) - 1);
            opts.c[sizeof (opts.c) - 1] = '\textbackslash0'; break; 
        case '?': fprintf(stderr, 
            "usage: %s [-ab] [-c Carg] arg1 arg2 ...\bs{}n", 
            basename(argv[0])); break; 
    \} 
arg1 = argv[\emprg{optind}];
\end{alltt}
\end{slide}

\begin{itemize}
\item It is a good custom while detecting unknown switch or incorrect use
of options to write simple usage, optionally with a reference to documentation,
and exit the program with error, i.e. non zero return value.
\item Note how the \texttt{opts.c} string is properly terminated. Utmost care
is necessary when processing potentially unbound output, especially when
handling options of a program running with elevated privileges.
\item It is evident that \texttt{getopt} is stateful function. In order to
process next array of arguments or start from scratch, it is necessary to
set the \texttt{optreset} variable to 1.
\item Standard version of \texttt{getopt} retains the order of arguments when
processing.
\item When undefined option is used, \texttt{getopt} will print an error;
this can be suppressed by setting the \texttt{opterr} variable to 0.
\item \label{GETOPT} Example: shell script \example{getopt/getopts.sh}
rewritten to C language using the \texttt{getopt} function:
\example{getopt/getopt.c}
\end{itemize}

%%%%%

\pdfbookmark[1]{getopt\_long}{getoptlong}

\begin{slide}
\sltitle{Dlouhý tvar pøepínaèù}
\setlength{\baselineskip}{0.8\baselineskip}
\begin{itemize}
\item poprvé se objevilo v GNU knihovnì \texttt{libiberty}: 
\begin{verbatim}
      --jméno nebo --jméno=hodnota 
\end{verbatim}
\item argumenty se permutují tak, aby pøepínaèe byly na zaèátku, napø.
\verb#ls * -l# je toté¾ jako \verb#ls -l *#, standardní chování lze docílit
nastavením promìnné \verb#POSIXLY_CORRECT#.
\item zpracovávají se funkcí \texttt{\funnm{getopt\_long}()}, která pou¾ívá
pole struktur popisujících jednotlivé pøepínaèe: 
{\tt
\begin{tabbing}
stru\=ct \funnm{option} \{\\
\>const char *name; \textrm{/* jméno pøepínaèe */} \\
\>int has\_arg; \textrm{/* hodnota: ano, ne, \emsl{volitelnì} */} \\
\>int *flag; \textrm{/*~}\=\textrm{kdy¾ je \texttt{NULL}, funkce vrací
\texttt{val}, jinak vrací 0}\\\>\>\textrm{a dá \texttt{val} do \texttt{*flag}
*/} \\
\>int val; \textrm{/* návratová hodnota */} \\
\};
\end{tabbing}}
\end{itemize}
\end{slide}

verze jak se objevila ve FreeBSD (funkce \textrm{getopt\_long} není
standarizovaná), má následující vlastnosti:

\begin{itemize}
\item pokud v¹echny dlouhé pøepínaèe mají nastaveny krátkou variantu
ve \texttt{val}, je chování \texttt{getopt\_long} kompatibilní s
\texttt{getopt}
\item je mo¾né zadávat argument k dlouhému pøepínaèi i s mezerou
(na\-pøí\-klad \texttt{--color~green})
\item pokud je nastaven \texttt{flag}, tak \texttt{getopt\_long}
vrací 0, èím¾ se tyto dlouhé pøe\-pí\-na\-èe bez krátké varianty zpracují v
jedné vìtvi pøíkazu \texttt{case}
\item existuje i volání \texttt{getopt\_long\_only}, které povoluje
i dlouhé pøepínaèe uvozené jednou uvozovkou (\texttt{-option})
\item funkci \texttt{getopt\_long} je mo¾né pou¾ívat dvìmi zpùsoby.
První zpùsob je, ¾e ka¾dý dlouhý pøepínaè má korespondující krátký
-- takto lze jednodu¹e pøidat dlouhé pøepínaèe do existujícího
programu a je \emsl{kompatibilní s getopt}. Druhý zpùsob umo¾òuje
mít samostatné dlouhé pøepínaèe. V tom pøípadì funkce vrací v¾dy 0
(nekompatibilita s \texttt{getopt}) a promìnná \texttt{*flag} se
nastaví na \texttt{val}.
\item na konkrétním pøíkladu na následující stránce je vidìt, jak to
celé funguje
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Dlouhé pøepínaèe (pokraèování)}
{\tt\begin{tabbing}
int \funnm{getopt\_long}(\=int \emph{argc}, char * const \emph{argv}[],\\
\>const char *\emph{optstring},\\
\>const struct option *\emph{longopts},\\
\>int *\emph{longindex}); 
\end{tabbing}}
\begin{itemize}
\item \texttt{optstring} obsahuje jednopísmenné pøepínaèe,
\texttt{longopts} obsahuje adresu pole struktur pro dlouhé pøepínaèe
(poslední záznam pole obsahuje samé nuly) 
\item pokud funkce narazí na dlouhý pøepínaè, vrací odpovídající
\texttt{val} nebo nulu (pokud \texttt{flag} nebyl \texttt{NULL}),
jinak je chování shodné s \texttt{getopt}.
\item do \texttt{*longindex} (kdy¾ není \texttt{NULL}) dá navíc
in{}dex nalezeného pøepínaèe v \texttt{longopts}.
\end{itemize}
\end{slide}

\begin{itemize}
\item toto je upravený pøíklad z manuálové stránky na FreeBSD:
{\footnotesize
\begin{verbatim}
#include <stdio.h>
#include <getopt.h>
#include <fcntl.h>

int ch, fd, daggerset, bflag = 0;

static struct option longopts[] = {
       { "buffy",      no_argument,            NULL,           'b' },
       { "fluoride",   required_argument,      NULL,           'f' },
       { "daggerset",  no_argument,            &daggerset,     1 },
       { NULL,         0,                      NULL,           0 }};

int main(int argc, char **argv)
{
  while ((ch = getopt_long(argc, argv, "bf:", longopts, NULL)) != -1)
         switch (ch) {
         case 'b':
                 bflag = 1; break;
         case 'f':
                 if ((fd = open(optarg, O_RDONLY, 0)) == -1)
                         printf("unable to open %s", optarg);
                 break;
         case 0:
                 if (daggerset) {
                         printf("Buffy will use her dagger to "
                             "apply fluoride to dracula's teeth\n");
                 }
                 break;
         default: printf("usage: ...\n");
  }
  argc -= optind; argv += optind;
  return 0;
}
\end{verbatim}
}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Struktura systému, systémová volání

% (jp) tohle neni uplne klasicka struktura, je to jedna z moznosti.
% Nevidim moc duvod tu ten slajd mit. OSy uz koneckoncu meli...

%%%\begin{slide}
%%%\sltitle{Klasická struktura operaèního systému}
%%%\begin{center}
%%%\input{klasicky_os.tex}
%%%\end{center}
%%%\end{slide}
%%%
%%%Hardware poèítaèe je "obalen" jednotlivými vrstvami operaèního
%%%systému, kdy ka¾dá vrstva roz¹iøuje schopnosti vrstvy spodní.
%%%Programové rozhraní operaèního systému (API) pøedstavuje pro
%%%aplikace virtuální (logický) poèítaè, který skrývá detaily
%%%hardwarové architektury, poskytuje slu¾by vy¹¹í úrovnì a v
%%%neposlední øadì definuje pøístupová práva a navzájem chrání
%%%jednotlivé bì¾ící aplikace.

%%%%%

\begin{slide}
\sltitle{Struktura klasického OS UNIX}
\input{img/tex/struktura.pstex_t}
\end{slide}

\begin{itemize}
\item toto schéma je pøevzato z [Bach86], viz literatura. Zdùrazòuje dva
ústøední pojmy v modelu systému UNIX -- soubory a procesy. \emsl{V dne¹ní dobì
to vypadá velmi odli¹nì, ale pro nás staèí tato základní pøedstava.}
\item UNIX rozli¹uje dva re¾imy bìhu procesoru: \emph{u¾ivatelský re¾im} a
\emph{re¾im jádra}. V u¾ivatelském re¾imu nejsou pøístupné privilegované
instrukce (napø. mapování pamìti, I/O, maskování pøeru¹ení). Tyto dva re¾imy
musí být podporovány na hardwarové úrovni (procesorem).
\item procesy bì¾í obvykle v u¾ivatelském re¾imu, do re¾imu jádra pøechází buï
instrukcí synchronního pøeru¹ení (trap) pro volání slu¾by jádra, nebo na
základì asynchronních pøeru¹ení (hodiny, I/O). Dále se v~re¾imu jádra
o\-¹e\-tøu\-jí výjimeèné stavy procesoru (výpadek stránky, naru¹ení ochrany
pamìti, ne\-zná\-má instrukce apod.). Nìkteré speciální akce jsou zaji¹»ovány
systémovými procesy, které bì¾í celou dobu v re¾imu jádra.
\item klasické UNIXové jádro je tvoøeno monolitickým kódem. Pùvodnì bylo
po\-tøe\-ba vygenerovat (tj. pøelo¾it ze zdrojových textù a slinkovat) jádro pøi
zmìnì nìkterého parametru nebo pøidání ovladaèe zaøízení. V novìj¹ích
implementacích je mo¾no nastavovat parametry jádra, nìkdy i za bìhu, pomocí
systé\-mo\-vých utilit bez nutnosti rekompilace jádra. Moderní unixové systémy
umo¾òují roz¹iøovat kód jádra za bìhu pomocí tzv. modulù jádra (\emph{loadable
kernel modules}). Napøíklad systém FreeBSD 5.4-RELEASE má 392 takových modulù.
\item existují dva zpùsoby práce s perifériemi: bloková (\emph{block devices})
a znaková zaøízení (\emph{character, raw devices}). Data z blokových zaøízení
(napø. disky) procházejí pøes vyrovnávací pamìti (\emph{buffers}) po blocích,
znaková zaøízení (napø. terminály) umo¾òují pracovat s jednotlivými bajty a
nepou¾ívají vyrovnávací pamì».
\item \emsl{jádro není samostatný proces}, ale je èástí ka¾dého u¾ivatelského
procesu. Kdy¾ jádro nìco vykonává, tak vlastnì proces, bì¾ící v re¾imu jádra,
nì\-co provádí.
\end{itemize}


%%%%%

\begin{slide}
\sltitle{Procesy, vlákna, programy}
\begin{itemize}
\item \emsl{proces} je systémový objekt charakterizovaný svým
kontextem, identifikovaný jednoznaèným èíslem (\emsl{process ID},
\emsl{PID}); jinými slovy \uv{kód a data v pamìti} 
\item \emsl{vlákno (thread)} je systémový objekt, který existuje uvnitø
procesu a je charakterizován svým stavem. V¹echna vlákna jednoho procesu sdílí
stejný pamì»ový prostor kromì registrù procesoru a zásobníku; \uv{linie
výpoètu}, \uv{to, co bì¾í} 
\item \emsl{program} ... soubor pøesnì definovaného formátu obsahující
instrukce, data a slu¾ební informace nutné ke spu¹tìní; \uv{spustitelný soubor
na disku}
\end{itemize}

\begin{itemize}
\item[$\circ$] \emsl{pamì»} se pøidìluje \emsl{procesùm}. 
\item[$\circ$] \emsl{procesory} se pøidìlují \emsl{vláknùm}.
\item[$\circ$] vlákna jednoho procesu mohou bì¾et na rùzných procesorech.
\end{itemize}
\end{slide}

\begin{itemize}
\item \emsl{\emph{kontext}} je pamì»ový prostor procesu, obsah registrù a datové
struktury jádra týkající se daného procesu
\item jinak øeèeno -- kontext procesu je jeho stav. Kdy¾ systém
vykonává proces, øíká se, ¾e bì¾í v kontextu procesu. Jádro (klasické)
obsluhuje pøeru¹ení v kontextu pøeru¹eného procesu.
\item vlákna se dostala do UNIXu a¾ pozdìji, pùvodnì v nìm existovaly pouze
procesy, které mìly z dne¹ního pohledu pouze jedno vlákno. Mo¾nost pou¾ít v
procesu více vláken byla zavedena, proto¾e se ukázalo, ¾e je vhodné mít více
paralelních linií výpoètu nad sdíle{}nými daty.
\item pamì»ové prostory procesù jsou navzájem izolované, ale procesy spolu
mohou komunikovat. Pozdìji se dozvíme, ¾e mohou i èásteènì sdílet pamì».
\item procesy jsou entity na úrovni jádra, ale vlákna mohou být èásteènì nebo
zcela implementována knihovními funkcemi. V pøípadì implementace pomocí
knihovních fukncí to znamená, ¾e vlákna nemusí jádro vùbec podporovat. S vlákny
je spojena men¹í re¾ie ne¾ s~procesy.
\item systémový proces, který bì¾í na pozadí obvykle po celou dobu bìhu
systému a zaji¹»uje nìkteré systémové slu¾by (\texttt{inetd}, \texttt{cron},
\texttt{sendmail}\dots) se nazývá \emph{démon} (angl. \emph{daemon}). Systém
BSD tedy nemá ve znaku èerta, ale démona.
\end{itemize}

%%%%%


\begin{slide}
\sltitle{Jádro, re¾imy, pøeru¹ení (klasický UNIX)}
\begin{itemize}
\item procesy typicky bì¾í v u¾ivatelském re¾imu
\item systémové volání zpùsobí pøepnutí do re¾imu jádra
\item proces má pro ka¾dý re¾im samostatný zásobník
\item jádro je èástí ka¾dého u¾ivatelského procesu, není to samostný proces
(procesy)
\item pøepnutí na jiný proces se nazývá \emph{pøepnutí kontextu}
\item obsluha pøeru¹ení se provádí v kontextu pøeru¹eného procesu
\item klasické jádro je nepreemptivní
\end{itemize}
\end{slide}

\begin{itemize}
\item \emsl{jádro není oddìl{}ená mno¾ina procesù, bì¾ících paralelnì s
u\-¾i\-va\-tel\-ský\-mi procesy, ale je èástí ka¾dého u¾ivatelského procesu.}
\item pøechod mezi u¾ivatelským re¾imem a re¾imem jádra není pøepnutí kontextu
-- proces bì¾í poøád v tom samém
\item pøeru¹ený proces nemusel pøeru¹ení vùbec zpùsobit
\item v re¾imu jádra mù¾e proces pøistupovat i k adresám jádra, která z
u\-¾i\-va\-tel\-ské\-ho re¾imu pøístupná nejsou; takté¾ mù¾e pøistupovat k
instrukcím (napø. instrukce manipulující se stavovým registrem), jejich¾
vykonání v u¾ivatelském re¾imu vede k chybì
\item pøeru¹ovací rutina se nemù¾e zablokovat, proto¾e tím by zablokovala
proces; proces se toti¾ mù¾e zablokovat jen ze své vlastní vùle. Moderní unixy
dnes pou¾ívají interrupt vlákna, v jejich¾ kontextu se \emsl{mohou} drivery
zablokovat.
\item to, ¾e klasické unixové jádro je nepreemptivní znamená, ¾e \emsl{jeden
proces nemù¾e zablokovat jiný proces}
\item pøi obsluze pøeru¹ení se mù¾e stát, ¾e nastane dal¹í pøeru¹ení. Pokud je
jeho priorita vìt¹í, je procesorem pøijmuto. Posloupnost pøijmutých pøeru¹ení
je uchována v \emph{zásobníku kontextových vrstev}.
\item \emsl{u moderních kernelù je situace èasto velmi rozdílná -- obsluha
pøe\-ru\-¹e\-ní, preemptivnost kernelu atd.; k nìkterým vìcem se mo¾ná
dostaneme pozdìji bìhem semestru}
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Volání slu¾eb a komunikace mezi procesy}
\begin{itemize}
\item UNIX\vspace{1ex}

\input{img/tex/syscall_unx.tex}
\item distribuovaný OS\vspace{1ex}

\input{img/tex/syscall_dist.tex}
\end{itemize}
\end{slide}

\begin{itemize}
\item pokud unixový proces vy¾aduje provedení systémové slu¾by, pomocí
systé\-mo\-vé\-ho volání pøedá øízení jádru. Jádro je kus kódu sdíle{}ný v¹emi
procesy (ov¹em pøístupný jen pro ty, které jsou právì v re¾imu jádra). Jádro
tedy není samostatný privilegovaný proces, ale v¾dy bì¾í v rámci nìkterého
procesu (toho, který po¾ádal jádro o slu¾bu, nebo toho, který bì¾el v okam¾iku
pøíchodu pøeru¹ení).
\item komunikace mezi procesy v UNIXu je øe¹ena pomocí systémových volání, je
tedy zprostøedkovaná jádrem.
\item aby to nebylo tak jednoduché, mohou existovat systémové procesy
(o\-zna\-èo\-va\-né jako \emph{kernel threads}), které bì¾í celou dobu v
re¾imu jádra. Naprostá vìt¹ina systémových procesù v¹ak bì¾í v u¾ivatelském
re¾imu a li¹í se jen tím, ¾e mají vìt¹í pøístupová práva. Plánovaè procesù
pøepíná mezi procesy a tím umo¾òuje bìh více procesù souèasnì i na jednom
procesoru. Na multiprocesorových poèítaèích pak funguje skuteèný paralelismus
procesù a vláken (dokonce se proces mù¾e pøi pøeplánování dostat i na jiný
procesor).
\item v distribuovaném operaèním systému má jádro obvykle formu mikrojádra,
tj. zaji¹»uje pouze nejzákladnìj¹í slu¾by øízení procesoru, pøidìlování pamìti
a komunikace mezi procesy. Vy¹¹í systémové slu¾by, které jsou v UNIXu souèástí
jádra (napø. pøístup k systému souborù) jsou realizovány speciálními procesy
(servery) bì¾ícími v u¾ivatelském re¾imu procesoru. Jádro pøedá po¾adavek
u¾ivatelského procesu pøíslu¹nému serveru, který mù¾e bì¾et i na jiném uzlu
sítì.
\item dostupných mikrokernelù je v dne¹ní dobì mnoho. Mù¾ete zkusit napøíklad
Minix (u{}nix-like výukový systém), pøípadnì systém HURD, který bì¾í nad
mikrojádrem Mach.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Systémová volání, funkce}
\begin{itemize}
\item v UNIXu se rozli¹ují \emsl{systémová volání} a \emsl{knihovní
funkce}.  Toto rozli¹ení dodr¾ují i manuálové stránky: sekce
\emsl{2} obsahuje systémová volání (\emph{syscalls}), sekce \emsl{3}
knihovní funkce (\emph{library functions}). 
    \begin{itemize}
    \item knihovní funkce se vykonávají v u¾ivatelském re¾imu,
    stejnì jako ostatní kód programu. 
    \item systémová volání mají také tvar volání funkce. Pøíslu¹ná funkce ale
    pouze zpracuje argumenty volání a pøedá øízení jádru pomocí instrukce
    synchronního pøeru¹ení. Po návratu z jádra funkce upraví výsledek a pøedá ho
    volajícímu. 
    \end{itemize}
\item standardy tyto kategorie nerozli¹ují -- z hlediska programátora je jedno,
zda urèitou funkci provede jádro nebo knihovna.
\end{itemize}
\end{slide}

\begin{itemize}
\item zjednodu¹enì lze øíci, ¾e systémové volání je funkce, která
jen upraví své argumenty do vhodné podoby, pøepne re¾im procesoru a
skuteènou práci nechá na jádru. Nakonec zase upraví výsledek.
\emsl{Knihovní funkce mù¾e a nemusí volat jádro, ale v¾dy sama dìlá
nìjakou netriviální èinnost v u¾ivatelském re¾imu.}
\item v assembleru je mo¾né zavolat volání jádra pøímo
\item API jádra je definované na úrovni volání funkcí standardní
knihovny, nikoliv na úrovni pøeru¹ení a datových struktur
pou¾ívaných tìmito funkcemi pro pøedání øízení jádru. Mechanismus
pøepnutí mezi u¾ivatelským re¾imem a re¾imem jádra se toti¾ mù¾e
li¹it nejen v závislosti na hardwarové platformì, ale i mezi rùznými
verzemi systému na stejném hardwaru. 
\end{itemize}
%%%%%

\pdfbookmark[1]{syscall return values semantics}{syscallretvals}

\begin{slide}
\sltitle{Návratové hodnoty systémových volání}
\setlength{\baselineskip}{0.8\baselineskip}
\begin{itemize}
\item celoèíselná návratová hodnota (\texttt{int}, \texttt{pid\_t},
\texttt{off\_t}, apod.)
    \begin{itemize}
    \item \texttt{>= 0} \dots{} operace úspì¹nì provedena 
    \item \texttt{== -1} \dots{} chyba 
    \end{itemize}
\item návratová hodnota typu ukazatel 
    \begin{itemize}
    \item \texttt{!= NULL} \dots{} operace úspì¹nì provedena 
    \item \texttt{== NULL} \dots{} chyba 
    \end{itemize}
\item po neúspì¹ném systémovém volání je kód chyby v globální
promìnné \texttt{extern int \funnm{errno};}
\item úspì¹né volání nemìní hodnotu v \texttt{errno}! Je tedy tøeba
nejprve otestovat návratovou hodnotu a pak teprve \texttt{errno}. 
\item chybové hlá¹ení podle hodnoty v \texttt{errno} vypí¹e funkce\\
\texttt{void \funnm{perror}(const char *\emph{s});}
\item textový popis chyby s daným èíslem vrátí funkce\\
\texttt{char *\funnm{strerror}(int \emph{errnum});}
\end{itemize}
\end{slide}

%%%%%

\begin{itemize}
\item \label{ERRNO} v Solarisu je hodnota \texttt{errno} ve
skuteènosti knihovnou \texttt{libc} definovaná jako dereferencovaný
pointer na integer (specifický pro daný userland thread) a hodnota se
nastavuje ihned po výstupu z instrukce pro systémové volání. Napø. na i386
architektuøe je hodnota \texttt{errno} po návratu z kernelu (po dokonèení
instrukce \texttt{sysenter}) ulo¾ena v registru \texttt{eax} (pøed voláním
v ní bylo èíslo syscallu). Je to tedy knihovna \texttt{libc} kdo je
zodpovìdný za to, ¾e program uvidí správnou hodnotu \texttt{errno}.


\item funkce pro práci s vlákny \texttt{pthread\_*} nenastavují
\texttt{errno}, ale vrací buï nulu (úspìch) nebo pøímo kód chyby.
\item pro nìkterá volání mù¾e mít smysl i návratová hodnota
\texttt{-1}. Pak je tøeba nejprve nastavit \texttt{errno~=~0} a po
návratu zkontrolovat, zda se \texttt{errno} zmìnilo. Napø. funkce
\texttt{strtol} vrací pøi chybì 0, co¾ je platná hodnota i pro
správný výsledek (a $-1$ je samozøejmì platný výsledek také).
\item je tedy v¾dy nutné si pøeèíst manuálovou stránku pro pøí¹lu¹né
volání nebo knihovní funkci
\item pozn.: úspì¹nost funkcí ze \texttt{stdio.h} je tøeba testovat pomocí\\
\texttt{int \funnm{ferror}(FILE *\emph{stream})}, proto¾e jinak nelze rozli¹it
mezi chybou a koncem streamu. Vzhledem k tomu, ¾e tyto funkce nepou¾íváme (kromì
\texttt{printf} a \texttt{fprintf} na \texttt{stdout}, resp. \texttt{stderr}),
nemìli byste ji potøebovat.
\end{itemize}

\begin{slide}
\sltitle{Formatted error messages: \texttt{err(3)}}
\setlength{\baselineskip}{0.8\baselineskip}
\begin{itemize}
\item functions to display a formatted error message and optionally exit
\item instead of \funnm{perror}() and \funnm{exit}(), one function suffices
\item
\texttt{void \funnm{err}(int \emph{status}, const char *\emph{fmt}, ...);}
\begin{itemize}
\item prints a program name, formatted string, and error based on
\texttt{errno}
\item exits the program with \emph{status} return value
\end{itemize}
\item
\texttt{void \funnm{warn}(const char *\emph{fmt}, ...);}
\begin{itemize}
\item same as \funnm{err}() but does not exit
\end{itemize}
\item see the manual page for other functions from the same family
\item originated in 4.4BSD
\end{itemize}
\end{slide}

%%%%%

\begin{itemize}
\label{ERR}
\item The third widely used function is \funnm{errx}() which behaves as
\funnm{err}() but does not use \texttt{errno}.  Similarly, \funnm{warnx}().
\item These functions are very handy especially for smaller programs as they are
easy to work with and save you some lines of code.  More complex
app\-li\-ca\-tions often use their own logging functions.
\item Not part of the UNIX specification but in general you can find them almost
everywhere.
\item Example (and also in \example{err/err.c}):

\begin{verbatim}
#include <errno.h>
#include <err.h>

int
main(void)
{
        errno = 13;
        err(3, "ggr %s", "GRR");
        printf("after err()\n");
        return (0);
}

$ ./a.out 
a.out: ggr GRR: Permission denied
$ echo $?
3
\end{verbatim}

\end{itemize}

\endinput
