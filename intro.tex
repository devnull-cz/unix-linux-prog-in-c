% The title slide

changequote([[[, ]]])

\begin{slide}
\centerslidestrue
\begin{center}
\title{\LARGE Unix/Linux Programming in C}
\author{(NSWI015)}
\date{Version: \rm\today}
\maketitle

% \v{c} - hacek nad c
% \'{y} - carka nad y
% \'{\i} - carka nad i (\i je treba proto, aby nam zmizela tecka nad i)
% \accent23o{u} - krouzek nad u samozrejme

\vspace{2ex}
{\small (c) 2011 -- 2017 Vladim\'{i}r Kotal}\\
{\small (c) 2005 -- 2011, 2016 -- 2017 Jan Pechanec}\\
{\small (c) 1999 -- 2004 Martin Beran}

\vspace{2ex}
Department of SISAL\\
Faculty of Mathematics and Physics, Charles University\\
Malostransk\'{e} n\'{a}m. 25, 118 00 Praha 1 

\begin{figure}[htb!]
  \includegraphics[scale=0.75]{img/by-nc-sa-small}
\end{figure}
\end{center}
\end{slide}

\begin{itemize}
\item This is official material for the class \emph{Unix/Linux Programming in C}
(NSWI015) lectured at the Faculty of Mathematics and Physics, Charles University
in Prague.
\item The text is currently being translated to English.
\item This material is published under the
\href{http://creativecommons.org/licenses/by-nc-sa/3.0/cz/}{Creative Commons
BY-NC-SA 3.0} license and is always work in progress, see the history on
GitHub:\\
\url{https://github.com/devnull-cz/unix-linux-prog-in-c}
\item To download the latest version, go to the \emph{releases} tab on GitHub.
\item Source code referenced from this material is published in
\href{http://creativecommons.org/licenses/publicdomain/}{Public Domain} unless
specified otherwise in the files.
\item The source code files can be found on GitHub here:\\
\url{https://github.com/devnull-cz/unix-linux-prog-in-c-src}
\item In case you find any errors either in the text or in the example programs,
we appreciate if you let us know.
\end{itemize}

\pagebreak

\begin{slide}
\sltitle{Contents}
\slidecontents{0}
\end{slide}

\begin{itemize}
\item This lecture is mostly about Unix principles and Unix programming in the~C
language.
\item \emsl{The lecture is mostly about system calls, ie. an interface between a
user space and system kernel.}
\item For the API, we will follow the \emph{Single UNIX Specification,
version~4} (SUSv4). Systems that submit to the Open Group for certification and
pass conformance tests are termed to be compliant with the UNIX standard
UNIX~V7.  Some versions of Solaris, AIX, HP-UX a macOS on selected architectures
are compliant with the previous version SUSv3
(\url{http://www.opengroup.org/openbrand/register/xy.htm}).
\item The specific source code examples linked from this material are usually
tested on macOS and Linux.
\end{itemize}

%%%%%
\pdfbookmark[0]{intro, programming utilities}{intro}

\begin{slide}
\sltitle{Contents}
\slidecontents{1}
\end{slide}

\pdfbookmark[1]{Current UNIX and Unix-like Systems}{currentunix}

\begin{slide}
\sltitle{Proprietary UNIX and Unix-like Systems}

\begin{itemize}
\item Sun Microsystems, now Oracle: \emsl{SunOS} (defunct), \emsl{Solaris}
\item Apple: \emsl{macOS} (formerly Mac OS X, Mac OS)
\item SGI: \emsl{IRIX} (in maintenance mode)
\item IBM: \emsl{AIX}
\item HP: \emsl{HP-UX}, \emsl{Tru64 UNIX} (defunct, formerly by Compaq)
\item SCO: \emsl{SCO Unix} (discontinued)
\item BSD/OS: \emsl{BSDi} (discontinued)
\item Xinuos (formerly Novell): \emsl{UNIXware}
\end{itemize}
\end{slide}

\begin{slide}
\sltitle{Open source Unix-like Systems}

\begin{itemize}
\item rather extensive number of \emsl{Linux} distributions
\item \emsl{FreeBSD}
\item \emsl{NetBSD}
\item \emsl{OpenBSD}
\item \emsl{DragonflyBSD}
\begin{itemize}
\item all BSD variants have roots in the 4.4 BSD Lite source code
\end{itemize}
\item \emsl{Minix}, micro-kernel based
\item \emsl{OpenSolaris}, discontinued
\end{itemize}
\end{slide}

\begin{itemize}
\item Note that \emsl{Linux is a kernel only}, not the whole system.  In
contrast to FreeBSD, for example, which covers both the kernel and the userland.
It is better to say a ``Linux distribution'' if you discuss a whole system that
is built around the Linux kernel.
\item FreeBSD and NetBSD forked from 386BSD (now defunct) in 1993, OpenBSD was
forked from NetBSD in 1995, and DragonflyBSD was forked from FreeBSD in 2003.
\item Presently, the ``UNIX'' trademark can be only used by systems that passed
conformance tests defined in the Single UNIX Specification (SUS).
\item From those systems listed above, only Solaris, macOS, AIX, and HP-UX are
UNIX~03 compliant (\url{http://www.opengroup.org/openbrand/register/}).  Other,
not certified systems, are often described as ``Unix-like'', even that in many
cases they closely follow the standard.  However, word ``Unix'' is often used
for systems from either group.
\item The above list is a tiny fraction of the whole Unix world.  Every
proprietary Unix variant usually came from either UNIX~V or BSD, and added its
own features.  That is why there were quite a few standards as well, see page
\pageref{UNIXSTANDARDS}.  In the end vendors agreen upon a small set of those.
\item If you are interested in detailed and up-to-date Unix system version
history, go check \url{https://www.levenez.com/unix/}.
\end{itemize}

%%%%%

\pdfbookmark[1]{UNIX standards}{unixstd}

\begin{slide}
\sltitle{Standardy UNIXu}
\begin{itemize}
\renewcommand{\baselinestretch}{0.8}
\item \emsl{SVID} (System~V Interface Definition) 
    \begin{itemize2}
    \item \uv{fialová kniha}, kterou AT\&T vydala poprvé v roce 1985
    \item dnes ve verzi SVID3 (odpovídá SVR4) 
    \end{itemize2}
\item \emsl{POSIX} (Portable Operating System based on UNIX)
    \begin{itemize2}
    \item série standardù organizace IEEE znaèená P1003.xx, postupnì je
    pøejímá vrcholový nadnárodní orgán ISO 
    \end{itemize2}
\item \emsl{XPG} (X/Open Portability Guide) 
    \begin{itemize2}
    \item doporuèení konsorcia X/Open, které bylo zalo¾eno v r. 1984 pøedními
    výrobci platforem typu UNIX
    \end{itemize2}
\item \emsl{Single UNIX Specification}
    \begin{itemize2}
    \item standard organizace The Open Group, vzniklé v roce 1996 slouèením
    X/Open a OSF 
    \item dnes Version~4 (\emsl{SUSv4})
    \item splnìní je nutnou podmínkou pro u¾ití obchodního názvu UNIX
    \end{itemize2}
\end{itemize}
\end{slide}

\label{UNIXSTANDARDS}

\begin{itemize}
\item základní informace je, ¾e oblast standardù týkající se unixových systémù
je vìc znaènì slo¾itá a na první pohled velmi nepøehledná.
\item AT\&T dovolila výrobcùm nazývat svoji komerèní UNIX variantu ``System
V'' pouze pokud splòovala podmínky standardu SVID. AT\&T také publikovala
\emph{System~V Verification Suite} (SVVS), které ovìøilo, zda daný systém
odpovídá standardu. 
\item POSIX (Portable Operating System Interface) je standardizaèní snaha
organizace IEEE (Institute of Electrical and Electronics Engineers).
\item SUSv4 je spoleèný standard The Open Group, IEEE (Std. 1003.1, 2008
Edition) a ISO (ISO/IEC 9945-2008).
\item Pro certifikaci operaèního systému na Single Unix Specification
je nutné aby systém (na dané architektuøe, napø. 64-bit x86) pro¹el sadou
testù. Výsledky testù jsou pak vyhodnoceny. Testy samotné jsou sdru¾eny
do tzv. \emph{test suites}, co¾ jsou sady automatických testù, které
projdou systém a zjistí jestli splòuje rozhraní dané normou.
Pro SUSv3 je takových test suites cca 10.
\item Rozhraní specifikované normou POSIX.1-2008 se dìlí na 4
základní skupiny: XSH (System Interfaces), XCU (Shell and Utilities), XBD
(Base definitions). Z nich je co do poètu
rozhraní nejobsáhlej¹í XSH, která popisuje více ne¾ 1000 rozhraní.
\item Skupiny rozhraní POSIXu spolu se skupinou Xcurses, která je souèástí
Single Unix Specification (ale nikoliv souèást POSIX báze v normì IEEE Std
1003.1-2001) zahrnují celkem 1742 rozhraní, které tvoøí Single Unix
Specification (2003). Tabulky rozhraní SUS je mo¾né získat zde:
\url{http://www.unix.org/version3/inttables.pdf}
\item komerèní UNIXy vìt¹inou sledují Single UNIX Specification, splnìní této
normy je právì podmínkou pro u¾ití názvu UNIX (znaèka UNIX 98 odpovídá
SUSv2, znaèka UNIX 03 odpovídá SUSv3, SUSv4 je UNIX V7 - neplést s historickým
V7 UNIX). Je postavena na bázi POSIXu. My se budeme dr¾et SUSv4. Popis datových
struktur a algoritmù jádra v tomto materiálu bude vìt¹inou vycházet ze
System~V Rel.~4.
\item na Solarisu je obsáhlá manuálová stránka \texttt{standards(5)}, kde mù¾ete
na jednom místì nalézt mnoho informací týkající se standardù. Jednotlivé pøíkazy
splòující danou normu jsou navíc umístìny do vyhrazených adresáøù. Napø.
program \texttt{tr} je v adresáøích \texttt{/usr/xpg4/bin/} a
\texttt{/usr/xpg6/bin/}, v ka¾dém je verze pøíkazu splòující danou normu.
Na pøepínaèe a chování dané normou se pak lze spolehnout napø. pøi psaní
shellových skriptù.
\item opìt na Solarisu, podívejte se na hlavièkový soubor
\texttt{/usr/inc{}lude/sys/fea\-ture\-\_tests.h}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pdfbookmark[1]{POSIX}{POSIX}

\begin{slide}
\sltitle{POSIX}
\begin{itemize}
\renewcommand{\baselinestretch}{0.8}
\item tvrzení ``tento systém je POSIX kompatibilní'' nedává ¾ádnou konkrétní
informaci
\begin{itemize}
\item asi podporuje POSIX1990 a mo¾ná i nìco dal¹ího (co?)
\end{itemize}
\item dotyèný buï neví co je POSIX nebo si myslí, ¾e to nevíte vy
\item jediná rozumná reakce je otázka ``jaký POSIX?''
\item POSIX je \emsl{rodina standardù}
\item prvním dokumentem je \emph{IEEE Std POSIX1003.1-1988}, pozdìji po vzniku
dal¹ích roz¹íøení neformálnì odkazovaný jako POSIX.1
\item poslední verze POSIX.1 je \emph{IEEE Std 1003.1, 2004 Edition}
\begin{itemize}
\item obsahuje v sobì ji¾ i to, co døíve definoval POSIX.2 (Shell and Utilities)
a rùzná, døíve samostatná roz¹íøení
\end{itemize}
\end{itemize}
\end{slide}

\label{POSIX}

\begin{itemize}
\item prvním dokumentem je \emph{IEEE Std POSIX1003.1-1988}, døíve oznaèovaný
pros\-tì jako POSIX, pak odkazovaný jako \emph{POSIX.1}, proto¾e POSIXem se nyní
míní sada vzájemnì souvisejících standardù. POSIX.1 v té dobì obsahoval
programovací API, tj. práce s procesy, signály, soubory, èasovaèi atd. S malými
zmìnami byl pøevzat organizací ISO (\emph{ISO 9945-1:1990}), a je
oz\-na\-èo\-va\-ný i
jako POSIX1990. IEEE oznaèení je \emph{IEEE Std POSIX1003.1-1990}. Tento
standard byl sám o sobì velký úspìch, ale stále je¹tì nespojoval tábory System~V
a BSD, proto¾e v sobì napøíklad nezahrnoval BSD sockety nebo IPC (semafory,
zprávy, sdíl{}ená pamì») ze System~V. Souèástí standardu je i ``POSIX
conformance test suite (PCTS)'', který je volnì k dispozici.
\item oznaèení POSIX vymyslel Richard Stallman, tedy èlovìk, který v roce 1983
zalo¾il GNU projekt.
\item dùle¾itá ro¾¹íøení k IEEE Std 1003.1-1990 (jsou souèástí IEEE Std 1003.1,
2004 Edition):
\begin{itemize}
\item \emph{IEEE Std 1003.1b-1993 Realtime Extension}, neformálnì známý jako
POSIX.4, proto¾e to bylo jeho pùvodní oznaèení pøed pøeèíslováním; já budu toto
roz¹íøení nìkdy také nazývat POSIX.4. Vìt¹ina tohoto roz¹íøení je nepovinná,
tak¾e tvrzení ``systém podporuje POSIX.1b'' má je¹tì hor¹í vypovídací hodnotu
ne¾ ``systém je POSIX kompatibilní'', a to prakticky nulovou. Jediná povinná
èást POSIX.4 je malé doplnìní k signálùm oproti POSIX1990. Je proto nutné v¾dy
uvést, co z POSIX.4 je implementováno -- napø. sdíl{}ená pamì», semafory,
real-time signály, zamykání pamìti, asynchronní I/O, èasovaèe atd.
\item \emph{IEEE Std 1003.1c-1995 Threads}, viz strana \pageref{POSIXTHREADS}.
\item \emph{IEEE Std 1003.1d-1999 Additional Realtime Extensions}
\item \emph{IEEE Std 1003.1j-2000 Advanced Realtime Extensions}, viz strana
\pageref{RWLOCKS}.
\item \dots
\end{itemize}
\item standardy POSIX je mo¾né nalézt na \url{http://www.open-std.org/}.
HTML verze je volnì k prohlí¾ení, za PDF verzi se platí.
\end{itemize}


\pdfbookmark[1]{books}{books}

%%%%%

\begin{slide}
\sltitle{Books on Unix system principles and design}

\begin{enumerate}
\item Uresh Vahalia: \emsl{UNIX Internals: The New Frontiers}.
 Prentice Hall; 1st edition, 1995
\item Bach, Maurice J.: \emsl{The Design of the UNIX Operating System}.
Prentice Hall, 1986
\item McKusick, M. K., Neville-Neil, G. V.: \emsl{The Design and
Implementation of the FreeBSD Operating System}. Addison-Wesley, 2004
%\item Goodheart, B.; Cox, J.: \emsl{The Magic Garden Explained: the
%Internals of UNIX System~V Release 4}. Prentice Hall, 1994
\item McDougall, R.; Mauro, J.: \emsl{Solaris Internals}. Prentice Hall; 2nd
edition, 2006.
\item \emsl{Linux Documentation Project}. \url{http://tldp.org/}
\end{enumerate}
\end{slide}

\begin{itemize}
\item These books are about Unix internals, not about Unix system programming.
\end{itemize}

\begin{enumerate}
\item A great book on Unix in general and compares SVR4.2, 4.4BSD, Solarix~2.x
and Mach systems.  The 2nd edition scheduled for 2005 never happened,
unfortunately.
\item UNIX classic book. On UNIX System~V Rel.~2, and partially 3 as well.
While outdated, it is one of the best books ever written on Unix.  In 1993 a
Czech translation was released as \emsl{Principy opera\v{c}n\'{\i}ho syst\'{e}mu
UNIX}, SAS.
\item Structures, functions, and algorithms of the FreeBSD 5.2 kernel; it is
based on another Unix classic book \emsl{The Design and Implementation of the
4.4 BSD Operating System} by the same author.
\item The best book on the Solaris operating system.  The system version in the
book is Solaris~10.
\item Linux documentation project home page.
\end{enumerate}

%%%%%

\begin{slide}
\sltitle{Books on Unix programming}
\begin{enumerate}
\item Stevens, W. R., Rago, S. A.: \emsl{Advanced Programming in UNIX(r)
Environment}. Addison-Wesley, 2nd edition, 2005.
\item Rochkind, M. J.: \emsl{Advanced UNIX Programming},
Addison-Wesley; 2nd edition, 2004
\item Stevens, W. R., Fenner B., Rudoff, A. M.: \emsl{UNIX Network
Programming, Vol. 1 -- The Sockets Networking API}. Prentice Hall,
3rd edition, 2004
\item Butenhof, D. R.: \emsl{Programming with POSIX Threads},
Addison-Wesley; 1st edition, 1997
% I don't why but after I switched from FreeBSD to Solaris, I can't typeset
% word "unix" anymore. It's like it wasn't there. Using {} trick helps.
\item UNIX specifications, see \url{http://www.unix.org}
\item manual pages, mainly sections 2 and 3
\end{enumerate}
\end{slide}

\label{REF_PROGRAMMING}

\begin{enumerate}
\item One of the best book on programming in Unix environment.  Does not cover
net\-work\-ing, that is in 3.
\item Another classic book on programming in Unix environment.  Also covers
net\-work\-ing.  Not as detailed as books 1 and 3 but that could be to your
advantage.  We very much recommend this book, especially if you want just one.
The author can see the big picture which is quite rare.
\item Unix network programming classics, one of the best on the topic; there is
also volume 2, \emsl{UNIX Network Programming, Volume 2: Interprocess
Communications}, covering interprocess communication in great detail.
\item Great book on programming with threads using POSIX API.  Highly
recommended.
\item UNIX specifications.
\item Detailed descriptions of system calls and functions.
\item \label{POSIX4} A book that did not fit the slide and covers topics outside
of the scope of this class: Gall\-meis\-ter, B. R.: \emsl{POSIX.4 Programmers
Guide: Programming for the Real World}, O'Reilly; 1st edition, 1995.  A great
book on real-time POSIX extensions with a beatiful cover.  See also pages
\pageref{REALTIMEEXTENSIONS} a \pageref{SIGWAITINFO}.
\item[\ldots] Go to Amazon and search for ``unix''.  If you ever buy anything,
always check whether there is a newer edition of the same book.  Note that they
often still sell older releases as well.
\item[\ldots] You can also buy lots of these books on Amazon in a decent second
hand quality for a fraction of the original price.
\end{enumerate}

%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Jazyk C

\pdfbookmark[1]{The C Programming Language}{C}
\label{C_LANGUAGE}

\begin{slide}
\sltitle{The C Programming Language}
\begin{itemize}
\item virtually all Unix kernels are written in C.  Only some HW dependend parts
are written in assembler.
\item C came into existence in the years 1969-1973, by Dennis M. Ritchie (\dag
2011)
\item it evolved from B, designed by Ken Thomson
\item created as means to rewrite original Unix in a higher language.  It also
greatly helped \emsl{portability of the system.}
\item language variants
    \begin{itemize}
    \item original K\&R C (1978-1979)
    \item standard ANSI/ISO C (1989), then next C standard revisions
    \end{itemize}
\end{itemize}
\end{slide}

\begin{itemize}
\item The success of C eventually overcame the success of Unix itself.
\item CPL $\Rightarrow$ BCPL $\Rightarrow$ B (Thompson, interpret)
$\Rightarrow$ C.  Both Thompson and Ritchie worked for Bell Laboratories.
\item It took many years before C reached its first standard.  Most work on C
happened in 1972, another peak was in 1977-1979, then in the 1980s ANSI commitee
was established to provide the first standard on C.  For more information on the
early C history, see \emph{Dennis M. Ritchie, The Development of the C Language}
paper, available freely.
\item K\&R C refers to the C language as described in the first edition of
\emph{The C Prog\-ramm\-ing Language} classic book by Kernighan and Ritchie,
Prentice-Hall, 1978.
\item In 1983 ANSI (American National Standards Institute) formed a commitee
X3J11 to create the first C standard.  After a long and tedious process the
standard came to existence as ANSI X3.159-1989 ``Programming Language C,'' and
is mostly known as ``ANSI C'', or C89, and the command line name for the
compiler itself was \texttt{c89}.
\item The 2nd edition of the C book (1988) was updated for the upcoming
standard as it used one of its final drafts.  In 1990, ANSI C was adopted by ISO
as ISO/IEC 9899:1990; that standard is sometimes called C90.  It's the same as
C89 but it renumbered its sections and removed the rationale document which was
part of ANSI C.  That standard was adopted back by ANSI.  After C89, ANSI never
got involved in the C standardization anymore, it only adopted each ISO C
standard.
\item The next revision of the language was released in 1999 as ISO 9899:1999,
informally called C99.  After that, there were three technical corrigendums,
TC1, TC2, and TC3, so the current version of the C99 standard is the combined
C99+TC1+TC2+TC3, WG14~N1256, dated 2007-09-07.  It is a work in progress,
with its current final draft located here,
\url{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf}.
\item After C99, C11 came, officially ISO/IEC 9899:2011.
\item Some difference between C89 and C99 -- inline functions, variable
definitions intermixed with code, one-line comments using \texttt{//}, new
functions like \funnm{snprintf}() etc.
\item The ISO C standards are not free but the drafts are.  The latest draft for
each standard is virtually the standard itself, it just not does not say that.
See \url{http://www.open-std.org/}.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Byte ordering}
\begin{itemize}
\item byte ordering -- depends on the architecture
    \begin{itemize}
    \item \raisetab{
    \begin{tabular}[t]{r|c|c|c|c|}
    little endian: 0x11223344 =
    &44&33&22&11\\
    \multicolumn{1}{r}{\texttt{addr +}}&
    \multicolumn{1}{c}{0}&\multicolumn{1}{c}{1}&
    \multicolumn{1}{c}{2}&\multicolumn{1}{c}{3}
    \end{tabular}}
    \item \raisetab{
    \begin{tabular}[t]{r|c|c|c|c|}
    big endian: 0x11223344 =
    &11&22&33&44\\
    \multicolumn{1}{r}{\texttt{addr +}}&
    \multicolumn{1}{c}{0}&\multicolumn{1}{c}{1}&
    \multicolumn{1}{c}{2}&\multicolumn{1}{c}{3}
    \end{tabular}}
    \end{itemize}
\item little endian -- Intel, ARM (mostly, but it does support both)
\item big endian -- SPARC, MIPS, network byte ordering
\end{itemize}
\end{slide}

\label{BYTE_ORDERING}

\begin{itemize}
\item Be careful when using tools like \texttt{hexdump} that by default print
out a file as 16-bit numbers.  The ordering of individual bytes may not be how
they are stored in a file.  For example, take FreeBSD on i386.  The first number
in the file is character ``i'' which represents lower 8 bits of the first 16-bit
number, so when the first two bytes are printed out as a 16-bit number, the byte
representing ``i'', ie. ``69'', is shown as the second byte.  Similarly for
``kl''.

\begin{verbatim}
$ echo -n ijkl > test
$ hexdump test
0000000 6a69 6c6b
0000004
\end{verbatim}

You can use other output formats though, for example as hexa bytes and
characters in the same output:

\begin{verbatim}
$ hexdump -C test 
00000000 69 6a 6b 6c            |ijkl|
00000004
\end{verbatim}

\item The UNIX spec does not list \texttt{hexdump} but defines \texttt{od}
(octal dump).  The equivalent output for the \texttt{hexdump} default output is
as follows.  Note that since we did that on SPARC, the output is different from
the i386 output above!

\begin{verbatim}
$ od -tx2 test
0000000 696a 6b6c
0000004
\end{verbatim}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}
\sltitle{New line character(s)}
\begin{itemize}
\item in Unix, a text file line ends with a single character \emsl{LF}
\item in Windows (and MS~DOS), a new line ends with two characters, \emsl{CR+LF}
\item on Unix, calling \verb.putc('\n'). thus prints only one character
\item ``classic'' Mac~OS used \emsl{CR}
\end{itemize}
\end{slide}

\label{NEWLINECHAR}

\begin{itemize}
\item \emsl{LF}, \emph{line feed}, sometimes also referred to as \emph{new
line}, is a character 0x0A (10).  \emsl{CR}, \emph{carriage return}, or simply
\emph{return}, is a character 0x0D (13).
\item To further confuse the enemy, ``classic'' Mac OS used a single \emsl{CR}
as line breaks.  As present time macOS comes from the Unix world, it also uses
\emsl{LF} now.
\item When you open a text file in classic \texttt{vi} and you see strange
\verb|^M| characters at the end of every line, it is that \emsl{CR} character
from a line separator in a file brought over from a Windows system.  Just get
rid of them via \verb|:%s/^V^M//g| where \verb|^X| means Ctrl+X.  ViM by default
tries to be smarter in such situations but not always to your benefit.
\item See the \texttt{ascii} man page for the octal, hexadecimal, and decimal
ASCII character sets (ie. up to character 127 as ASCII table has only 128
characters).
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pdfbookmark[1]{C style}{cstyle}

\begin{slide}
\sltitle{C style}
\begin{itemize}
\item C style of the source code files is extremely important
\item there are quite a few ways how to do it:

\begin{verbatim}
int
main(void)
{
        int i;
        char c = 'X';

        for (i = 0; i < 10; ++i)
                printf("%c%d\n", c, i);
        return (0);
}
\end{verbatim}
\end{itemize}
\end{slide}

\begin{itemize}
\item One of the most important thing of a C style (well, any style) is
consistency.  And often it is not that important what an exact C style a group
of coders is going to pick as it is that one specific style is chosen and then
religiously followed by all in the group.  A good and rigorously followed cstyle
leads to a smaller number of bugs in code.
\item A pre-push hook that runs a C style check script and refuses to accept any
changesets not following the chosen C style is a working solution to avoid C
style violations.
\item \url{http://mff.devnull.cz/cstyle.html}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}
\sltitle{C style (cont.)}
\begin{itemize}
\item many ways how \emsl{NOT} to do it (so called assembler style):

\begin{verbatim}
int main(void) {
int i = 0; char c;
printf("%d\n", i);
return (0);
}
\end{verbatim}

\item or a schizophrenic style:
\begin{verbatim}
int main(void) {
        int i = 0; char c;
        if (1)
        printf("%d\n", i);i=2;
return (0); }
\end{verbatim}

\end{itemize}
\end{slide}

\begin{itemize}
\item A good C style of of the source code you write represents you.  You will
be judged by other people by the way your source code looks.  Always try to
write beautiful code.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Standard Utilities}
\begin{tabular}{ll}
\emsl{cc}, \emsl{c99}$^*$, \emsl{gcc}$^\dagger$& pøekladaè C\\
\emsl{CC}, \emsl{g++}$^\dagger$& pøekladaè C++\\
\emsl{ld}& spojovací program (linker)\\
\emsl{ldd}& pro zjistìní závislostí dynamického objektu\\
\emsl{cxref}$^*$& køí¾ové odkazy ve zdrojových textech v C\\
\emsl{sccs}$^*$, \emsl{rcs},\emsl{cvs}& správa verzí zdrojového kódu\\
\emsl{make}$^*$& øízení pøekladu podle závislostí\\ 
\emsl{ar}$^*$& správa knihoven objektových modulù\\
\emsl{dbx}, \emsl{gdb}$^\dagger$& debuggery\\
\emsl{prof}, \emsl{gprof}$^\dagger$& profilery\\
\end{tabular}

\hspace{0.5cm}$^*$ SUSv3 $^\dagger$ GNU
\end{slide}

SUSv3
\begin{itemize}
\item standardní pøíkaz volání kompilátoru a linkeru C je \texttt{c99} (podle
ISO normy pro C z roku 1999)
\item \texttt{cb} (C program beautifier) není
\item pro správu verzí je \texttt{sccs}
\item debuggery a profilery nejsou
\end{itemize}


%%%%%

\begin{slide}
\sltitle{Konvence pro jména souborù}
\begin{tabular}{ll}
\texttt{*.c} & jména zdrojových souborù programù v C\\
\texttt{*.cc} & jména zdrojových souborù programù v C++\\
\texttt{*.h} & jména hlavièkových souborù (headerù)\\
\texttt{*.o} & pøelo¾ené moduly (object files)\\
\texttt{a.out} & jméno spustitelného souboru (výsledek úspì¹né kompilace)
\end{tabular}

\begin{tabular}{ll}
\texttt{/usr/inc{}lude} & koøen stromu systémových headerù\\
\texttt{/usr/lib/lib*.a} & statické knihovny objektových modulù\\
\texttt{/usr/lib/lib*.so} & umístìní dynamických sdíle{}ných knihoven\\&
      objektových modulù
\end{tabular}
\end{slide}

\begin{description}
\item[statické knihovny] -- pøi linkování se kód funkcí pou¾itých z knihovny
stane souèástí výsledného spustitelného programu. Dnes se u¾ moc nepou¾ívá.
\item[sdíle{}né knihovny] -- program obsahuje pouze odkaz na knihovnu, pøi
spu¹tìní programu se potøebné knihovny naètou do pamìti ze souborù \texttt{*.so}
a pøilinkují.
\end{description}

\begin{itemize}
\item dnes se vìt¹inou pou¾ívají sdíle{}né knihovny, proto¾e
nezabírají tolik diskového prostoru (knihovna je na disku jednou,
není souèástí ka¾dého spustitelného souboru) a snadnìji se upgradují
(staèí instalovat novou verzi knihovny, není tøeba pøelinkovat
programy).  Poslední verze Solarisu u¾ napøíklad vùbec neobsahuje
\texttt{libc.a}, díky èemu¾ ji¾ programátor nemù¾e vytvoøit
statickou binárku, ani¾ by mìl dostateèné znalosti systému.
\item nìkdy se bez statických knihoven neobejdeme. V nìkterých
situacích není mo¾né pou¾ít knihovny dynamické, spustitelné soubory
jsou takzvané \emph{standalone binaries} a pou¾ití naleznou
napøíklad pøi bootování operaèního systému.
\end{itemize}


%%%%%

\begin{slide}
\sltitle{Princip pøekladu}
\begin{center}
\input{img/tex/princip_prekladu.tex}
\end{center}
\end{slide}

\begin{itemize}
\item u slo¾itìj¹ích programù bývá zvykem rozdìlit zdrojový text
programu do nìkolika modulù, které obsahují pøíbuzné funkce a tyto
moduly se pak mohou pøekládat zvlá¹» (dokonce ka¾dý modul mù¾e být v
jiném jazyce a pøekládán jiným pøekladaèem). Výhodou je jednak
urychlení pøekladu (pøekládají se v¾dy jen moduly zmìnìné od
posledního pøekladu) a jednak flexibilita (nìk\-te\-ré moduly se mohou
pou¾ívat v rùzných programech). Pro øízení pøekladu se obvykle
pou¾ívá utilita \texttt{make}.
\item \emph{pøekladaè} jednotlivé zdrojové moduly pøelo¾í do tvaru
tzv. \emph{objektových modulù}, je¾ obsahují kód programu (vèetnì
volání lokálních funkcí), ale namísto volání externích funkcí
obsahují jen tabulku jejich jmen.
\item po fázi pøekladu nastupuje \emph{spojovací program} (té¾
\emph{linker} editor nebo \emph{loader}), který zkompletuje výsledný
program vèetnì vyøe¹ení externích odkazù mezi moduly a systémovými
knihovnami resp. mezi moduly navzájem.
\item pou¾ité statické knihovny jsou zkopírovány do spustitelného
souboru. Na sdíle{}né knihovny jsou ve spustitelném souboru pouze
odkazy a linkuje je runtime linker pøi ka¾dém spu¹tìní programu. Více viz
dynamický linker na stranì \pageref{RUNTIMELINKER}.
\item pomocí parametrù linkeru lze urèit, zda se budou pou¾ívat
statické nebo dynamické knihovny. Zdrojový kód je v obou pøípadech
stejný. Existuje i mechanismus (\texttt{dlopen},
\texttt{dlsym}\dots), pomocí kterého se za bìhu programu vybere
sdíle{}ná knihovna a dají se volat její funkce.  Tímto zpùsobem mù¾ete
také zjistit, zda v systému je pøítomna pøíslu¹ná funkcionalita a
pokud ne, zachovat se podle toho. Více na stranì \pageref{DLOPEN}.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Pøeklad jednoho modulu (preprocesor)}
\begin{center}
\input{img/tex/preprocesor.pstex_t}
\end{center}
\end{slide}

\begin{itemize}
\item preprocesor provádí expanzi maker, ètení vlo¾ených (inc{}lude) souborù a
vynechává komentáøe.
\item výstup preprocesoru lze získat pomocí \texttt{cc -E} pøípadnì pøímo
zavoláním \texttt{cpp}, nemusí to být ale v¾dy toté¾ proto¾e nìkteré
pøekladaèe mají preprocesor integrován v sobì. Preprocesor mù¾ete samozøejmì
pou¾ívat i pro jiné projekty, které s pøe\-kla\-dem zdrojových souborù v
jazyce C nemusí mít vùbec nic spoleèného.
\item pou¾ití preprocesoru se mù¾e velmi hodit v situaci, kdy potøebujete
zasáhnout do cizího kódu, plného podmíneèných vkládání rùzných hlavièkových
souborù a rùzných definic závislých na daných podmínkách. Pøi hledání pùvodce
chyby vám právì mù¾e hodnì pomoci samostatného zpracování vstupního souboru
pomocí preprocesuru, kde problém ji¾ vìt¹inou rozpoznáte snadno.
\item \texttt{cpp} (nebo \texttt{cc -E} vám doká¾e na standardní chybový výstup
zobrazit i celý strom vklá\-da\-ných souborù, co¾ opìt pøi podmíneèných
pøekladech mù¾e být velmi u¾iteèná vìc. Staèí pro to pou¾ít volbu \texttt{-H} a
pøesmìrovat výstup do \texttt{/dev/null} èím¾ dostanete pouze hierarchii
vkládaných hlavièkových souborù.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Pøeklad jednoho modulu (kompilátor)}
\begin{center}
\input{img/tex/kompilator.tex}
\end{center}
\end{slide}

\begin{itemize}
\item obrázek vý¹e je pøíklad výstupu pro i386 platformu (32-bit, AT\&T syntax).
\item pøeklad z C do assembleru
\item výstup této fáze pøekladu lze získat pomocí \texttt{cc -S}.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Pøeklad jednoho modulu (assembler)}
\begin{center}
\input{img/tex/assembler.pstex_t}
\end{center}
\end{slide}

\begin{itemize}
\item opìt pøíklad výstupu pro i386 platformu (32-bit).
\item pøeklad z assembleru do strojového kódu
\item objektový modul je výsledkem pøíkazu \texttt{cc -c}.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Kompilátor}
\renewcommand{\arraystretch}{1.1}
\begin{itemize}
\item volání:\\
\texttt{cc [\emph{options}] \emph{soubor} \dots}
\item nejdùle¾itìj¹í pøepínaèe:\\
\begin{tabular}{ll}
\texttt{-o \emph{soubor}} & jméno výsledného souboru\\
\texttt{-c} & pouze pøeklad (nelinkovat)\\
\texttt{-E} & pouze preprocesor (nepøekládat)\\ 
\texttt{-l} & slinkuj s pøíslu¹nou knihovnou\\
\texttt{-L\emph{jméno}} & pøidej adresáø pro hledání knihoven z \texttt{-l}\\
\texttt{-O\emph{level}} & nastavení úrovnì optimalizace\\
\texttt{-g} & pøeklad s ladicími informacemi\\
\texttt{-D\emph{jméno}} & definuj makro pro preprocesor\\
\texttt{-I\emph{adresáø}} & umístìní \texttt{\#include} souborù
\end{tabular}
\end{itemize}
\end{slide}

\begin{itemize}
\item \texttt{-l}/\texttt{-L} jsou pøepínaèe linker editoru, tj.
kompilátor pøíslu¹né informace pøedá, ale jsou pou¾ívány tak èasto,
¾e jsou vlo¾eny i do tohoto slajdu.
\item kompilátor a linker mají mnoho dal¹ích pøepínaèù ovlivòujících
generovaný kód, vypisování varovných hlá¹ení nebo variantu jazyka
(K\&R/ANSI). Je tøeba nastudovat dokumentaci konkrétního produktu.
\end{itemize}

%%%%%

\pdfbookmark[1]{standard macros}{stdmacros}

\begin{slide}
\sltitle{UNIX standard macros}
\begin{tabbing}
\hskip 11em \= \kill
\verb#__FILE__#, \verb#__LINE__#, \verb#__DATE__#, \verb#__TIME__#,
\verb#__cplusplus#, apod.\\
\> jsou standardní makra kompilátoru C/C++\\
\verb#unix# \> v¾dy definováno v Unixu\\
\verb#mips#, \verb#i386#, \verb#sparc# \> hardwarová architektura\\
\verb#linux#, \verb#sgi#, \verb#sun#, \verb#bsd# \> klon operaèního systému\\
\verb#_POSIX_SOURCE#, \verb#_XOPEN_SOURCE# \\
\> pøeklad podle pøíslu¹né normy\\
\end{tabbing}

pro pøeklad podle urèité normy by pøed prvním \verb.#include. mìl
být øádek s definicí následujícího makra. Pak naètìte \texttt{unistd.h}.

\begin{tabular}{l@{\hspace{3em}}l}
\emsl{UNIX 98} &\verb.#define _XOPEN_SOURCE 500.\\
\emsl{SUSv3} &\verb.#define _XOPEN_SOURCE 600.\\
\emsl{SUSv4} &\verb.#define _XOPEN_SOURCE 700.\\
\emsl{POSIX1990} &\verb.#define _POSIX_SOURCE.
\end{tabular}
\end{slide}

\begin{itemize}
\item funguje to tak, ¾e pomocí konkrétních maker definujete co chcete (napø.
\texttt{\_POSIX\_SOURCE}) a podle nastavení jiných maker (napø.
\texttt{\_POSIX\_VERSION}) pak zjistíte, co jste dostali. Musíte ale v¾dy po
nastavení maker nainkludovat \texttt{unistd.h} a pou¾ít správný pøekladaè.
Napøíklad se pokusíme pøelo¾it program \example{basic-utils/standards.c}, který
vy\-¾a\-du\-je SUSv3, na systému podporujícím SUSv3 (Solaris 10), ale
pøekladaèem, který podporuje pouze SUSv2 (SUSv3 pøekladaè je \texttt{c99}).
Pozor, ¾e defaultní chování va¹eho pøekladaèe mù¾e být klidnì právì to z
\texttt{c89}.

\begin{verbatim}
$ cat standards.c 
#define _XOPEN_SOURCE   600
/* you must #include at least one header !!! */
#include <stdio.h>
int main(void)
{
        return (0);
}
$ c89 basic-utils/standards.c 
"/usr/include/sys/feature_tests.h", line 336: #error: "Compiler or
options invalid; UNIX 03 and POSIX.1-2001 applications require
the use of c99"
cc: acomp failed for standards.c
\end{verbatim}
\item zdroj maker pro standard tedy mù¾e být ji¾ na stranì
\pageref{UNIXSTANDARDS} zmiòovaný hla\-viè\-ko\-vý soubor
\texttt{feature\_tests.h} na Solarisu.
\item v dokumentaci konkrétního kompilátoru je mo¾né najít, která dal¹í makra
se pou¾ívají. Mno¾ství maker je definováno také v systémových hlavièkových
souborech.
\item POSIX.1 v sobì zahrnuje ANSI C; tedy C89, ne C99 (o C standardech více
na stranì \pageref{C_LANGUAGE}).
\item co se týèe maker k jednotlivým standardùm, velmi dobrá je kapitola 1.5 v
[Rochkind]. Viz také \example{basic-utils/suvreq.c}.
\begin{verbatim}
int
main(void)
{
#ifdef unix
        printf("yeah\n");
#else
        printf("grr\n");
#endif
        return (0);
}
\end{verbatim}
\item For an example on using \texttt{\_\_LINE\_\_}, see
\example{basic-utils/main\_\_LINE\_\_.c}
\end{itemize}

%%%%%

\pdfbookmark[1]{link editor}{linker}

\begin{slide}
\sltitle{Link editor (linker)}
\begin{itemize}
\item Volání:\\
\texttt{ld [\emph{options}] \emph{soubor} \dots}\\
\texttt{cc [\emph{options}] \emph{soubor} \dots}
\item Nejdùle¾itìj¹í pøepínaèe:\\
\begin{tabular}{ll}
\texttt{-o \emph{soubor}} & jméno výsledného souboru (default \texttt{a.out})\\
\texttt{-l\emph{lib}} & linkuj s knihovnou \texttt{lib\emph{lib}.so} nebo
\texttt{lib\emph{lib}.a}\\ 
\texttt{-L\emph{path}} & cesta pro knihovny (\texttt{-l\emph{lib}})\\
\texttt{-shared} & vytvoøit sdíle{}nou knihovnu\\
\texttt{-non\_shared} & vytvoøit statický program
\end{tabular}
\end{itemize}
\end{slide}

\begin{itemize}
\item linker je program, který vezme typicky více objektù vygenerovaných
pøe\-kla\-da\-èem a vytvoøí z nich binární program, knihovnu nebo dal¹í objekt
vhodný pro dal¹í fázi linkování.
\item pozor na to, ¾e na rùzných systémech se nìkteré pøepínaèe
mohou li¹it, napøíklad \texttt{ld} na Solarisu nezná pøepínaèe
\texttt{-shared} a \texttt{-non\_shared}, je nutné pou¾ít jiné.
\item existuje pøepínaè \texttt{-R}, který umo¾òuje specifikovat
cestu pro hledání knihoven za bìhu (runtime). Tato cesta se mù¾e
li¹it od cesty specifikované pøepínaèem \texttt{-L}.
\item u malých programù (v jednom souboru) lze provést pøeklad a
linkování jedním pøíkazem \texttt{cc}. U vìt¹ích programù
skládajících se z mnoha zdrojových souborù a knihoven se obvykle
oddìluje pøeklad a linkování a celý proces je øízen utilitou
\texttt{make} (strana \pageref{MAKE}).
\end{itemize}


% (jp) archiv jsem vyhodil, ja ho treba za ty roky nikdy nepouzil
%
%\begin{slide}
%\sltitle{Práce s archivem (\texttt{ar})}
%\begin{itemize}
%\item manipulace s archivy souborù (napø. staticky linkované knihovny)
%\item soubory ulo¾eny bez cesty
%\item volání:\\\hspace{8em}
%\texttt{ar [-dmpqrtx] [-abuv] [\emph{pos}] \emph{archive}
%[\emph{file} \dots]}
%\item operace:
%    \begin{itemize2}
%    \item \emsl{r}(eplace) -- pøepis souboru v archivu, pøepínaèe:
%	\begin{itemize2}
%	\item \emsl{a}(fter), \emsl{b}(ehind) -- umístìní za/pøed soubor
%	\texttt{\emph{pos}}
%	\item \emsl{u}(pdate) -- pøepis jen novìj¹ích
%	\end{itemize2}
%    \item \emsl{q}(uick) -- rychlé pøidání na konec (nekontroluje duplicitu)
%    \item \emsl{m}(ove), \emsl{d}(elete) -- pøesun/smazání souboru v archivu 
%    \item \emsl{p}(rint), \emsl{t}(able) -- výpis obsahu souboru/archivu 
%    \item \emsl{x}(tract) -- výpis z archivu do normálního souboru 
%    \end{itemize2}
%\end{itemize}
%\end{slide}
%
%Tímto pøíkazem se vytváøí statické knihovny objektových modulù. Dynamické
%knihovny vytváøí linker pøi pou¾ití pøepínaèe \texttt{-shared}.

%%%%%

\pdfbookmark[1]{make}{make}

\begin{slide}
\sltitle{Øízení pøekladu a linkování (\texttt{make})}
\renewcommand{\baselinestretch}{1}
\begin{itemize}
\item \emsl{zdrojové texty}\\
\begin{minipage}[t]{3.3cm}
main.c\\
\setbox0=\hbox{\begin{minipage}[t]{3.1cm}
\begin{verbatim}
#include "util.h"
main()
{
  msg();
}
\end{verbatim}
\end{minipage}}
\framebox{\box0}
\end{minipage}\hfill
\begin{minipage}[t]{2.2cm}
util.h\\
\setbox1=\hbox{\begin{minipage}[t]{2cm}
\begin{verbatim}
void msg();
\end{verbatim}
\end{minipage}}
\framebox{\vphantom{\texttt{\#include"}}\box1}
\end{minipage}\hfill
\begin{minipage}[t]{3.3cm}
util.c\\
\setbox0=\hbox{\begin{minipage}[t]{3.2cm}
\begin{verbatim}
#include "util.h"
msg()
{
  puts();
}
\end{verbatim}
\end{minipage}}
\framebox{\box0}
\end{minipage}
\end{itemize}
\begin{minipage}[t]{3.7cm}
\begin{itemize}
\item \emsl{závislosti}\\\vskip-1ex
\renewcommand{\arraystretch}{0.1}
\setlength{\tabcolsep}{0.25ex}
\begin{tabular}{lclcl}
\texttt{main.c} &            &                 &            & \\
                & $\searrow$ &                 &            & \\
		&            & \texttt{main.o} &            & \\
		& $\nearrow$ &                 & $\searrow$ & \\
\texttt{util.h} &            &                 &            & \texttt{prog} \\
                & $\searrow$ &                 & $\nearrow$ & \\
		&            & \texttt{util.o} &            & \\
		& $\nearrow$ &                 &            & \\
\texttt{util.c} &            &                 &            & \\
\end{tabular}
\end{itemize}
\end{minipage}\hfill
\begin{minipage}[t]{6.5cm}
\begin{itemize}
\item \emsl{soubor} \texttt{Makefile}\\
\setbox0=\hbox{\begin{minipage}[t]{5.9cm}
\begin{verbatim}
prog : main.o util.o
        cc -o prog main.o util.o
main.o : main.c util.h
        cc -c main.c
util.o : util.c util.h
        cc -c util.c
\end{verbatim}
\end{minipage}}
\framebox{\box0}
\end{itemize}
\end{minipage}
\end{slide}

\label{MAKE}.

\begin{itemize}
\item program je mo¾né také pøelo¾it a slinkovat jedním voláním kompilátoru,
nebo definovat postup pøekladu a linkování pomocí shellového skriptu. Dùvodem
pro pou¾ití \texttt{make} je to, ¾e vyhodnocuje závislosti mezi soubory a po
zmìnì nìkterého zdrojového souboru pøekládá jenom to, co na nìm závisí. Èastý
zpùsob pøekladu softwaru po aplikování zmìn zpùsobem ``\texttt{make clean; make
all}'' je v situaci, kdy celý pøeklad trvá minuty (desítky minut, hodiny\dots),
trochu nevhodný -- právì proto je dùle¾ité mít dobøe napsaný \texttt{Makefile}.
\item øádek ``\verb#prog : main.o util.o#'' definuje, ¾e se má nejprve
rekurzivnì zajistit existence a aktuálnost souborù \texttt{main.o} a
\texttt{util.o}. Pak se zkontroluje, zda soubor (cíl) \texttt{prog} existuje a
je aktuální (datum poslední modifikace souboru je mlad¹í ne¾ \texttt{main.o} a
\texttt{util.o}). Pokud ano, nedìlá se nic. Kdy¾ ne, provede se pøíkaz na
následujícím øádku.
\item \texttt{make} se spou¹tí typicky s parametrem urèující pøí¹lu¹ný cíl
(\emph{target}); pøi spu¹tìní bez parametrù se vezme první target.  To bývá
\texttt{all}, co¾ vìt¹inou podle unixové konvence pøelo¾í v¹e, co se pøelo¾it
má. Následuje pak tøeba spu¹tìní \texttt{make} s parametrem \texttt{install}
apod.
\item \texttt{make} je samozøejmì univerzální nástroj, pou¾itelný i jinde ne¾ u
pøekladù zdrojových kódù
\item pøíklad: \example{basic-utils/Makefile01}. Pozor na to, ¾e pro nestandardní
jmé\-no vstup\-ní\-ho souboru je nutné pou¾ít pøepínaè \texttt{-f}:
``\texttt{make -f Makefile01}''.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Syntaxe vstupního souboru (\texttt{make})}
\begin{itemize}
\item \makebox[4cm][l]{popis závislostí cíle:}
\texttt{\emph{targets} : [\emph{files}]}
\item \makebox[4cm][l]{provádìné pøíkazy:} \verb#<Tab>#\texttt{\emph{command}}
\item \makebox[4cm][l]{komentáø:} \texttt{\#\emph{comment}}
\item \makebox[4cm][l]{pokraèovací øádek:}
\texttt{\emph{line-begin}}\verb#\#\\
\makebox[4cm][l]{~} \texttt{\emph{line-continuation}}
\end{itemize}
\end{slide}

\begin{itemize}
\item \emsl{Pozor na to, ¾e øádek s pøíkazem zaèíná tabulátorem, nikoliv
mezerami.} Ka¾dý pøíkazový øádek se provádí samostatným shellem, pokud je
potøeba provést více øádkù pomocí jednoho shellu, musí se v¹echny a¾ na poslední
ukonèit backslashem (shell je dostane jako jeden øádek). Viz pøíklad, ve kterém
dva poslední \texttt{echo} pøíkazy jsou souèástí jednoho \texttt{if} pøíkazu,
který je spu¹tìn samostatným shellem. Dále si v¹imnìte, ¾e pokud máte pøíkaz na
více øádkù, musíte ka¾dý øádek ukonèit zpìtným lomítkem.

\begin{verbatim}
$ cat basic-utils/Makefile02
all:
        @echo $$$$
        @echo $$$$
        @if true; then \
                echo $$$$; \
                echo $$$$; \
        fi
$ make -f Makefile02
5513
5514
5515
5515
\end{verbatim}

\item co se týká pou¾ití zpìtného lomítka, tak to funguje jako oddìlovaè slov, a
\texttt{make} místo nìj vlo¾í mezeru. Pøíklad: \example{basic-utils/Makefile07}.
\item zdvojením \texttt{\$} se potlaèí speciální význam dolaru (viz
následující slajd)
\item znak \texttt{@} na zaèátku øádku potlaèí jeho výpis --
\texttt{make} jinak standardnì vypisuje nejdøíve to, co bude
vykonávat.
\item vypsání v¹ech pøikazù které bude make provádìt bez toho aby je skuteènì
provedl lze dosáhnout pou¾itím pøepínaèe \texttt{-n}.
\item znak \texttt{-} na zaèátku øádku zpùsobí ignorování nenulové
návratové hodnoty; jinak \texttt{make} v¾dy v takové situaci zahlásí
chyby a okam¾itì skonèí. Pøíklad: \example{basic-utils/Makefile04}.
\item 
\begin{verbatim}
test1:
        false
        echo "OK"

test2:
        -false
        echo "OK"
\end{verbatim}
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Makra (\texttt{make})}
\begin{itemize}
\item definice makra:\\
\hspace*{5em}\texttt{name = string}
\item pokraèování vkládá mezeru 
\item nedefinovaná makra jsou prázdná 
\item nezále¾í na poøadí definic rùzných maker
\item definice na pøíkazové øádce: \\
\hspace*{5em}\texttt{make \emph{target} \emph{name}=\emph{string}}
\item vyvolání makra: \\
\hspace*{5em}\texttt{\$\emph{name}} (pouze jednoznakové
\texttt{\emph{name}}), \\
\hspace*{5em}\texttt{\$\{\emph{name}\}} nebo \texttt{\$(\emph{name})}
\item systémové promìnné jsou pøístupné jako makra
\end{itemize}
\end{slide}

\begin{itemize}
\item kdy¾ je stejné makro definováno vícekrát, platí jeho poslední definice,
viz pøíklad \example{basic-utils/Makefile03}.
\item makra není mo¾né definovat rekurzivnì, viz
\example{basic-utils/Makefile05}:

\begin{alltt}
\$ cat basic-utils/Makefile05
M=value1
M=\$(M) value2
all:
        echo \$(M)
\$ make -f Makefile05
Variable M is recursive.
\end{alltt}
\item èasto se pou¾ívají rùzné roz¹íøené verze \texttt{make} (napø. GNU, BSD),
které umí, podmínìné sekce v \texttt{Makefile}, redefinice pro\-mìn\-ných, apod.
\item napsat \texttt{Makefile} který bude fungovat najednou pro rùzné verze
\texttt{make} nemusí být jednoduché, proto existují projekty jako je napø. GNU
automake. Pro jednoduchý podmíneèný pøeklad v závislosti na systému a kde se
dají oèekávat rùzné verze pøíkazu make, je mo¾né pou¾ít napøíklad následující
kód, který mi fungoval na v¹ech v nìm zmínìných systémech (znak ` je zpìtný
apostrof, a ' je normální apostrof):

\begin{verbatim}
CFLAGS=`x=\`uname\`; \
        if [ $${x} = FreeBSD ]; then \
          echo '-Wall'; \
        elif [ $${x} = SunOS ]; then \
          echo '-v'; \
        elif [ $${x} = Linux ]; then \
          echo '-Wall -g'; \
        fi`

all:
        @echo "$(CFLAGS)"
\end{verbatim}

\item v ostatních situacích je vhodné, pøípadnì nezbytné pou¾ít programy typu
\texttt{autoconf} nebo \texttt{automake}. Nìkteré \texttt{make} implementace
mají pøímo direktivy pro podmínìné zpracování vstupního souboru, napøíklad make
na BSD. Pøíklad: \example{basic-utils/Makefile08.bsd}.
\item pøepínaèem \texttt{-e} mù¾eme \texttt{make} donutit, aby ignoroval
nastavení promìnných ve vstupním souboru v pøípadì, ¾e je definována promìnná
prostøedí stejného jména. Normálnì \texttt{make} pøebírá aktuální nastavení
promìnných prostøedí jen v pøípadì, ¾e dané promìnné nejsou nastavené ve
vstupním souboru. Pøíklad: \example{basic-utils/Makefile06}.
\item \texttt{make} je velmi silný nástroj, staèí se podívat do systémových
\texttt{Makefile} souborù jakéhokoli un{}ix-like systému (najdìte si na
Wikipedii, co to znamená ``un{}ix-like'', pokud to nevíte). Typickou spoleènou
vlastností je to, ¾e neexistuje dokumentace, jak je daný makefile framework
postaven.
\end{itemize}

%%%%%

\pdfbookmark[1]{dynamic linker}{ldso}

\begin{slide}
\sltitle{Dynamický linker (loader)}

\begin{itemize}
\item pøeklad vy¾aduje v¹echny potøebné dynamické knihovny pro kontrolu
dosa¾itelnosti pou¾itých symbolù
\item \emsl{sestavení kompletního programu v pamìti se ale provede
a¾ pøi spu¹tìní}. To je úkol pro \emsl{dynamický linker}
(\emph{run-time linker}, \emph{loader})
\item seznam dynamických knihoven zjistí ze sekce \texttt{.dynamic}
\item systém má nastaveno nìkolik cest, kde se automaticky tyto knihovny hledají
\item v sekci \texttt{.dynamic} je mo¾né dal¹í cesty ke knihovnám pøidat pomocí
tagù \texttt{RUNPATH}/\texttt{RPATH}
\item nalezené knihovny se pøipojí do pamì»ového procesu pomocí volání
\funnm{mmap}() (bude pozdìji)
\end{itemize}
\end{slide}

\label{RUNTIMELINKER}

\begin{itemize}
\item proces spu¹tìní dynamicky slinkovaného programu probíhá takto:

\begin{itemize}
\item kernel ve volání \texttt{exec} namapuje program do pamìti a zjistí, jaký
dynamický linker se má pou¾ít (viz dále)
\item kernel namapuje linker do pamì»ového prostoru spou¹tìného programu a pak
linkeru pøedá kontrolu. Linker je program sám o sobì -- na Solarisu je ho mo¾né
normálnì spustit (má tedy funkci \texttt{main}) a jako parametr mu dát jméno
programu. Mo¾nost spou¹tìt dynamický linker z pøíkazového øádku je ale hlavnì
pro experimentovaní s linkerem pøi jeho vývoji.
\item linker z hlavièky programu zjistí, jaké dynamické knihovny program
pou¾ívá, namapuje je do pamìti a zavolá jejich inicializaèní funkce, pokud
existují. Mapují se v¹echny nalezené závislosti které nejsou nastavené jako
\emph{lazy} (strana \pageref{DLOPEN}), rekurzívnì prohledáváním do ¹íøky. V
tomto poøadí se pak také objekty prohledávají pøi hledání jednotlivých symbolù.
\item linker programu pøedá øízení (tj. zavolá funkci \texttt{main})
\item proces mù¾e i za bìhu dále vyu¾ívat dynamický linker pomocí volání
\texttt{dlopen} a spol.; k tomu se dostaneme na stranì \pageref{DLOPEN}
\end{itemize}

\item je potøeba si uvìdomit, ¾e dynamický linker zde nepracuje jako samostatný
proces pøesto¾e má svoji vlastní \texttt{main} funkci, jeho kód se pou¾ívá v
rámci pamì»ového prostoru procesu; \emsl{program, linker a knihovny dohromady
tvoøí jeden proces}.

\item \emsl{následující pøíkazy a pøíklady se týkají Solarisu}. Pokud to nebude
fungovat na jiných systémech, tak mají ekvivaletní nástroje s podobnou
funkcionalitou.

\begin{itemize}
\item seznam sekcí se zjistí pomocí \texttt{elfdump -c} (GNU má pøíkazy
\texttt{objdump} a \texttt{readelf}). O programových sekcích bude více na stranì
\pageref{ELF}.
\item to, jaký dynamický linker se pou¾ije, kernel zjistí ze sekce
\texttt{.interp}, viz ''\texttt{elf\-dump -i}'' a ``\texttt{ld -I}''. To
znamená, ¾e si mù¾ete napsat vlastní linker a pomocí \texttt{-I} pro \texttt{ld}
ho pak nastavit jako dynamický linker pro vá¹ program.
\item dynamická sekce se vypí¹e pomocí \texttt{elfdump -d}, dynamické knihovny
jsou o\-zna\-èe\-né tagem \texttt{NEEDED}
\item Finding out shared object dependencies is very easy via the
\texttt{ldd} command (Solaris, Linux, BSD).  It displays paths to the libraries
that will be used if the program is run in the same environment (see right
below for more information).  The command resolves the depencides recursively so
you will also see dynamic libraries that are used by other libraries and not
directly by the program.  To find out what exactly depends on what, use the
\texttt{-v} option.  macOS does not have \texttt{ldd}, use \texttt{otool -L}
instead.
\item jaké knihovny byly pøi spu¹tìní nakonec pou¾ity mù¾e být jiné ne¾ co uká¾e
pøíkaz \texttt{ldd}, a to tøeba díky mechanismu \texttt{LD\_PRELOAD}. Na
Solarisu proto existuje pøíkaz \texttt{pldd}, který pomocí èísla procesu uká¾e
závislosti konkrétního procesu. Pøíklad na \texttt{LD\_PRELOAD}: pou¾ijte ji¾
zmínìný \texttt{Ma\-ke\-file01}, a pøelo¾te \example{basic-utils/preload.c}
takto:
``\texttt{cc -shared -o lib\-pre\-load.so preload.c}''. Pak spus»te
program, který zachytí
systémové volání \texttt{close}: ``\verb#LD_PRELOAD=./libpreload.so ./a.out#''.
\item vìt¹inu zde uvedených informací naleznete v manuálové stránce pro
dynamický linker v Solarisu, \texttt{ld.so.1(1)}, a více pak v \emph{Linkers
and Libraries Guide} na \texttt{docs.oracle.com}. Na FreeBSD se dynamický
linker nazývá \texttt{ld-elf.so.1}, v linuxových distribucích vìt¹inou
\texttt{ld-linux.so.1}, na IRIXu \texttt{rld} atd.
\item dynamický linker se typicky dá konfigurovat pomocí nastavení
pro\-mìn\-ných, napøíklad si zkuste na Solarisu spustit toto:
\begin{verbatim}
LD_LIBRARY_PATH=/tmp LD_DEBUG=libs,detail date
\end{verbatim}
a pro zji¹tìní v¹ech mo¾ností jak debugovat dynamický linker pou¾ijte:
\begin{verbatim}
LD_DEBUG=help date
\end{verbatim}
\item pøíklad na to, kdy je potøeba, aby linker hledal knihovny i jinde ne¾ v
defaultních adresáøích (adresáøe specifikované promìnnou
\texttt{LD\_LIBRARY\_PA\-TH} se prohledávají jako první):
\begin{verbatim}
$ cp /lib/libc.so.1 /tmp
$ LD_LIBRARY_PATH=/tmp sleep 100 &
[1] 104547
$ pldd 104547
104547: sleep 100
/tmp/libc.so.1
/usr/lib/locale/cs_CZ.ISO8859-2/cs_CZ.ISO8859-2.so.3
\end{verbatim}
\item Solaris má velmi zajímavý pøíkaz \texttt{elfedit(1)}, pomocí kterého
mù¾ete editovat metadata ELF objektu, napøíklad pøepsat jméno závislé
kni\-hov\-ny, zmìnit nastavení \texttt{RUNPATH} atd.
\end{itemize}
\item \label{EVIL_LDLIBPATH} Obecnì platí, ¾e pou¾ívat
\texttt{LD\_LIBRARY\_PATH} k ovlivnìní bìhu dynamického linkeru pro nìco
jiného ne¾ ladìní dynamických knihoven pøi vývoji nebo pøesunech knihoven
mezi adresáøi není dobrý nápad. Na internetu lze najít mno¾ství èlánkù
typu "why is \texttt{LD\_LIBRARY\_PATH} evil ?" apod., napø.
\url{http://xahlee.org/UnixResource\_dir/\_/ldpath.html}.
\par
Tato promìnná je typicky zneu¾ívaná ve startovacích skriptech programù, aby
pøedsunuly alternativní seznam adresáøù kde hledat dynamické knihovny na
kterých program závisí. To vìt¹inou proto, ¾e byl program nesprávnì
slinkován a dynamický linker by podle informací v ELFu nedokázal jinak
knihovny najít. Typický nechtìný side effect je, ¾e program dále spustí
jiný program, který pou¾ívá knihovnu stejného jména, ale "díky" tomu, ¾e
se promìnné prostøedí dìdí, tak dynamický linker najde tuto knihovnu
jako první v aresáøi specifikovaném pomocí \texttt{LD\_LIBRARY\_PATH}.
Tato knihovna mù¾e být ale jiné verze, ne¾ ten druhý program oèekává, a
pak snadno mù¾e dojít k nìèemu, co se vìt¹inou nazývá "nedefinované
chování" (viz pøíklad u dal¹ího slide o ABI).
\end{itemize}


%%%%%

\pdfbookmark[1]{API/ABI}{APIABI}

\begin{slide}
\sltitle{API versus ABI}

API -- Application Programming Interface

\begin{itemize}
\item rozhraní pou¾ité pouze ve zdrojovém kódu
\item rozhraní \emsl{zdrojáku} vùèi systému, knihovnì èi vlastnímu kódu, tj.
napø. \texttt{exit(1)}, \texttt{printf("hello\bs{}n")} nebo
\texttt{my\_function(1, 2)}
\item \dots{}aby se stejný \emsl{zdrojový kód} mohl pøelo¾it na v¹ech
systémech podporující dané API
\end{itemize}

ABI -- Application Binary Interface

\begin{itemize}
\item low-level rozhraní \emsl{aplikace} vùèi systému, knihovnì èi jiné èásti
sama sebe
\item \dots{}aby se \emsl{objektový modul} mohl pou¾ít v¹ude tam, kde
je podporováno stejné ABI
\end{itemize}
\end{slide}

\label{API_ABI}

\begin{itemize}
\item Pøíkladem API je tøeba API definované normou POSIX.1.
\item ABI definuje konvenci volání (to jak program pøedá parametry funkci
a jak od ní pøevezme návratovou hodnotu), jaká jsou èísla systémových volání,
jak se systémové volání provede èi formát objektového modulu
a pøijímaných argumentù, viz pøíklad dole.
\item API knihovny pak definuje mimo jiné mno¾inu volání která jsou knihovnou
definována, jejich parametry a typy tìchto parametrù.
\item následná ukázka je pøíklad na to, kdy vývojáø zmìní velikost argumentù v
bajtech (tj. zmìní ABI knihovny), a nahradí novou verzí tu starou. V¹imnìte
si, ¾e dynamický linker toto nezjistí; nemá toti¾ jak, øídí se podle jména
knihovny v dynamické sekci programu, a to se nezmìnilo. Uvedená zmìna je sice
i zmìna v API a problém by se odstranil, kdybychom \texttt{main.c} znovu
pøelo¾ili se zmìnìným øádkem deklarace funkce \texttt{add}. To je ale èasto
problém (pøe\-klá\-dej\-te celý systém jen kvùli tomu), proto je tak dùle¾ité
dodr¾ovat zpìtnou kompatibilitu v ABI u knihoven.

Výsledek následujícího pøekladu knihovny, programu a jeho spu¹tìní je jak
bychom oèekávali (pou¾it \texttt{cc} ze SunStudio, pro \texttt{gcc} pou¾ijte
místo \texttt{-G} volbu \texttt{-shared}; novìj¹í \texttt{gcc} navíc neznají
\texttt{-R} a je místo toho nutné pou¾ít \texttt{-Xlinker -R .}:

\begin{verbatim}
$ cat main.c 
int my_add(int a, int b);

int
main(void)
{
        printf("%d\n", my_add(1, 2));
        return (0);
}

$ cat add.c
int
my_add(int a, int b)
{
        return (a + b);
}

$ cc -G -o libadd.so add.c
$ cc -L. -ladd -R. main.c 
$ ./a.out 
3
\end{verbatim}

Nyní ale pøi¹la dal¹í verze knihovny se stejným jménem, a ve funkci
\texttt{my\_add}
nastala zmìna v typu argumentù, kde místo 4-bajtového integeru se pou¾ije
64-bitový celoèíselný typ. Program ale o nièem neví, nechá se spustit a vrátí
chybnou hodnotu:

\begin{verbatim}
$ cat add2.c
int64_t
my_add(int64_t a, int64_t b)
{
        return (a + b);
}

$ cc -G -o libadd.so add2.c 
$ ./a.out 
-1077941135
\end{verbatim}

\item \label{ABI_MAIN} pøíklad: \example{lib-abi/abi-main.c} (komentáø v
souboru napoví jak pou¾ít os\-tat\-ní soubory ve stejném adresáøi)


\item zde pak pøichází ke slovu verzování knihoven, tj. je nutné ``nìco''
zmìnit tak, aby po instalaci nové knihovny ne¹lo program spustit bez jeho
rekompilace.
\item \label{OPENSSL} binární nekompatibilita je napøíklad problém u OpenSSL.
Vìtve 0.9.x a 0.9.y nejsou ABI kompatibilní. Konkrétnì verze 0.9.7 a 0.9.8,
v roce 2009 stále obì pou¾ívané. Verze rozli¹ené písmeny, tj. napøíklad 0.9.8a a
0.9.8g, jsou ABI kompatibilní. Nìkteré systémy stále pou¾ívají pouze 0.9.7
(FreeBSD 6.x, Solaris 10), jiné jen 0.9.8 (Solaris 11 Express), dal¹í integrují 
obì vìtve (rùzné Linuxové distribuce). Problém je, máte-li napøíklad program pro
Solaris~10 pou¾ívající \texttt{libcrypto.so} knihovnu, který chcete pou¾ívat i
na Solaris 11 Express (to je jinak díky zpìtné binární kompatibilitì striktnì
dodr¾ované mezi "major" verzemi Solarisu mo¾né - napø. program který bì¾el
na Solarisu 2.6 z roku 1997 mù¾e bì¾et na Solarisu 10 z roku 2009 bez nutnosti
rekompilace - to se týká systému a knihoven s ním dodávaných).
Jediné správné re¹ení je zkompilovat pro nový systém, pøípadnì manuálnì
zkopírovat potøebné verze knihoven, co¾ ale zdaleka není ideální -- program
nebude fungovat s novì nainstalovaným systémem, ale nikdo najednou neví,
proè to funguje na stejném systému vedle, a kdy¾ se to zjistí tak je opìt
potøeba manuální zásah, a pochybuji o tom, ¾e autor ``øe¹ení'' bude instalovat
opravené verze pøi výskytu bezpeènostních chyb. Nekompatibilita 0.9.x verzí je
dùvodem, proè je v dynamické sekci knihovny i její celé èíslo (bez písmen, ta
jak ji¾ víme nejsou pro ABI kompatibilitu u OpenSSL dùle¾itá), a díky tomu je
pak toto èíslo uvedeno i v ka¾dém programu proti knihovnì slinkovanému:
\begin{verbatim}
$ elfdump -d /usr/sfw/lib/libcrypto.so.0.9.8 | grep SONAME
   [7]  SONAME            0x1               libcrypto.so.0.9.8

$ elfdump -d /usr/bin/ssh | grep NEEDED
   [1]  NEEDED            0x3c99            libsocket.so.1
   [3]  NEEDED            0x3cb1            libnsl.so.1
   [5]  NEEDED            0x3cc6            libz.so.1
   [7]  NEEDED            0x3d12            libcrypto.so.0.9.8
   [9]  NEEDED            0x3cd9            libgss.so.1
  [10]  NEEDED            0x3cfe            libc.so.1
\end{verbatim}
\begin{itemize}
\item pøíèinou zpìtné nekompatibility OpenSSL verzí je to, ¾e z historických
dùvodù jsou nìkteré pou¾ívané struktury v hlavièkových souborech. Tyto struktury
je ale nìkdy nutné roz¹íøit, napøíklad pøi vývoji nové funkcionality. Tím
nastane situace, ¾e program pøelo¾ený s verzí 0.9.7 by pøedal novìj¹í knihovnì
``men¹í'' strukturu, respektive nová knihovna by pøistupovala ve staré struktuøe
na polo¾ky, které neexistují -- a tedy by pøistupovala k pamìti, která programu
nebyla pøidìlena. To mù¾e zpùsobit pád programu (pøístup na nenamapovanou
stránku), mù¾e to fungovat dále (v dané pamìti je to, co se tam typicky oèekává,
napøíklad nula), nebo se to zaène chovat ``podivnì'' (v pamìti bylo nìco, co v
dané situaci oèekávané nebylo). Problém v OpenSSL je, ¾e nyní ji¾ není technicky
jednoduché z tìchto struktur udìlat interní a navenek pracovat jen s
transparentními referencemi objektovým pøístupem, co¾ by umo¾nilo dìlat
libovolné zmìny ve strukturách, ani¾ by to program ovlivnilo.
\item bì¾nì vidìné øe¹ení zpùsobené neznalostí vìci je vytvoøit symbolický link,
napøíklad na Solarisu 11 udìlat 0.9.7 symlink na existující knihovnu verze
0.9.8. Èastý výsledek je pak pád programu a údiv autora symlinku. Nìkdy to
naopak funguje, proto¾e program náhodou nepou¾ívá pøíslu¹né struktury, a to je
jasným dùkazem pro aktéra, ¾e øe¹ení musí být správné. Mù¾e se ale stát, ¾e
program struktury nepou¾ívá pøi konkrétním provedeném testu, ale zaène dìlat
problémy a¾ pøi ¾ivém nasazení. Tady je jediná rada -- pokud si opravdu nejste
jisti ¾e víte, co dìláte a nejste si jistí svoji detailní znalostí kódu programu
i knihoven, vyhnìte se tomu. Nebo riskujte, ale ji¾ víte jak to mù¾e skonèit.
\item zdánlivì jednoduché øe¹ení dodávat více verzí OpenSSL s jedním sys\-té\-mem
pøiná¹í zase jiné problémy -- obtí¾nìj¹í vývoj systému, obtí¾nìj¹í správu
systému (pøi výskytu bezpeènostní chyby je èasto nutné patchovat v¹echny
instalované verze), problémy s nepøímými závislostmi obsahující více verzí dané
knihovny apod.
\item upgrade verze OpenSSL v existujícím systému je také vìc, které je dobré se
vyhnout, respektive toto tì¾ko vyøe¹íte vydáním patche pro existující systémy --
uva¾te ¾e zákazník pou¾ívá své nebo jím koupené programy, které závisí na
existující verzi. A tu byste mu najednou upgradovali na verzi vy¹¹í, ABI
nekompatibilní.
\item typickým pøíkladem, kdy se pou¾ívá transparentní typ jako reference, co¾
umo¾òuje dal¹í roz¹iøování pod ní le¾ící struktury bez rizika vý¹e uvedených
problémù, je typ POSIX vláken. Struktura typu \texttt{pthread\_t} (strana
\pageref{PTHREAD_T}) je interní zále¾itostí knihovny. Typicky je to integer, ale
to by programátora nemìlo vùbec zajímat. Samozøejmì souborový deskriptor èi
èíslo procesu jsou podobné pøípady, ale na pøíkladu vláken je to lépe vidìt.
\end{itemize}
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Debugger \texttt{dbx}}
\begin{itemize}
\item Volání:\\
\texttt{dbx [ \emph{options} ] [ \emph{program} [ \emph{core} ] ]}
\item Nejbì¾nìj¹í pøíkazy:\\
\renewcommand{\arraystretch}{0.9}
\begin{tabular}{ll}
\texttt{run [\emph{arglist}]} & start programu\\
\texttt{where} & vypi¹ zásobník\\
\texttt{print \emph{expr}} & vypi¹ výraz\\
\texttt{set \emph{var} = \emph{expr}} & zmìò hodnotu promìnné\\
\texttt{cont} & pokraèování bìhu programu\\
\texttt{next}, \texttt{step} & proveï øádku (bez/s vnoøením do funkce)\\
\texttt{stop \emph{condition}} & nastavení breakpointu\\
\texttt{trace \emph{condition}} & nastavení tracepointu\\
\texttt{command \emph{n}} & akce na breakpointu (pøíkazy následují)\\
\texttt{help [\emph{name}]} & nápovìda\\
\texttt{quit} & ukonèení debuggeru
\end{tabular}
\end{itemize}
\end{slide}

\begin{itemize}
\item základní øádkový symbolický debugger, aby bylo mo¾né ho plnì vyu¾ít, musí
být program pøelo¾en s ladicími informacemi (\texttt{cc -g}). Ladìný program se
startuje z debuggeru pøíkazem \texttt{run}, nebo se debugger pøipojí k ji¾
bì¾ícímu procesu. Pomocí \texttt{dbx} lze analyzovat i havarovaný program, který
vygeneroval soubor \texttt{core}.
\item je mo¾né ho najít napø. na Solarisu, av¹ak na Linuxu a FreeBSD defaultnì
není.
\item pro debugging se zdrojovými kódy nestaèí pou¾ít volbu \texttt{-g}, je
zároveò nutné mít i zdrojáky a objektové moduly tam, kde byly pøi pøekladu. To
je typicky bì¾ná situace, proto¾e ladíte na stroji, kde zároveò i vyvíjíte.
Pokud tomu tak není, je nutné si zdrojáky a objektové moduly zajistit, pokud k
nim vede jiná cesta, lze pou¾ít dbx pøíkaz \texttt{pathmap}.
\item \texttt{gdb}-kompatibilní mód se spustí pøes \texttt{gdb on}. Pokud vás
zajímá, jaký má \texttt{dbx} ekvivalentní pøíkaz ke konkrétnímu \texttt{gdb}
pøíkazu, pomù¾e vám \texttt{help FAQ}; hned první otázka je ``A.1  Gdb does
$<$something$>$; how do I do it in dbx?''
\item pokud nepou¾ijete pøepínaè -g, bude vám dbx na Solarisu stále
platný, proto¾e zobrazí argumenty funkcí. U BSD systémù a linuxových distribucí
-g pou¾ít musíte, jinak vám debuggery moc nepomohou. Kdy je to na Solarisu
platné i bez -g je v vidìt v pøíkladu \example{debug/dbx.c}. Pøi kompilaci
s gcc a pou¾ití gdb neuká¾e pøíkaz \texttt{where} parametry funkce
\texttt{crash()} zatímco se Solaris Studio kompilerem a debuggerem dbx se
parametry funkce vypí¹í, tak¾e je vidìt hodnota která se pøiøazovala.
\item pøíklad: \example{debug/coredump.c}. Po pøelo¾ení a spu¹tìní program
spadne a zanechá core dump.

\begin{verbatim}
$ cc coredump.c
$ ./a.out 
Segmentation Fault (core dumped)
$ dbx ./a.out core
Reading a.out
core file header read successfully
Reading ld.so.1
Reading libc.so.1
program terminated by signal SEGV (no mapping at the fault address)
0x08050a05: bad_memory_access+0x0015:   movb     %al,0x00000000(%edx)
(dbx) where                                                                  
=>[1] bad_memory_access(0x8047ae8, 0x8047a44, ...
  [2] main(0x1, 0x8047a50, 0x8047a58, 0x8047a0c), at 0x8050a1b 
\end{verbatim}

Vidíme, ve které funkci to spadlo a je mo¾né se vypsat zásobník. Nevidíme ale
pøesnì øádku kódu, kde nastal problém. Pro to je nutné pøelo¾it program s
ladícími symboly, tj. ``\texttt{cc -g coredump.c}''. Zájemce o více informací o
debugging pod unixem odkazuji na navazující pøedná¹ku ``Programování v UNIXu
II.'' (NSWI138).

\begin{verbatim}
$ cc -g coredump.c
$ dbx ./a.out core
Reading a.out
core file header read successfully
Reading ld.so.1
Reading libc.so.1
program terminated by signal SEGV (no mapping at the fault address)
Current function is bad_memory_access
    8           x[0] = '\0';
(dbx) 
\end{verbatim}

\end{itemize}


%%%%%

\begin{slide}
\sltitle{GNU debugger \texttt{gdb}}
\begin{itemize}
\item Volání:\\
\texttt{gdb [ \emph{options} ] [ \emph{program} [ \emph{core} ] ]}
\item Nejbì¾nìj¹í pøíkazy:\\
\renewcommand{\arraystretch}{0.9}
\begin{tabular}{ll}
\texttt{run [\emph{arglist}]} & start programu\\
\texttt{bt} & vypi¹ zásobník\\
\texttt{print \emph{expr}} & vypi¹ výraz\\
\texttt{set \emph{var} = \emph{expr}} & zmìò hodnotu promìnné\\
\texttt{cont} & pokraèování bìhu programu\\
\texttt{next}, \texttt{step} & proveï øádku (bez/s vnoøením do funkce)\\
\texttt{break \emph{condition}} & nastavení breakpointu\\
\texttt{help [\emph{name}]} & nápovìda\\
\texttt{quit} & ukonèení debuggeru
\end{tabular}
\end{itemize}
\end{slide}

\begin{itemize}
\item GNU obdoba \texttt{dbx}. Mód kompatibilní s \texttt{dbx} spustíte pøes
\texttt{-dbx}.
\item na rùzných platformách existují i debuggery s grafickým
rozhraním, napø. \texttt{workshop} (Solaris), \texttt{cvd} (IRIX),
\texttt{xxgdb} (GNU), \texttt{ddd} (GNU). Èasto fungují jako
nadstavby nad \texttt{dbx}, \texttt{gdb}.

\item \begin{verbatim}
#include <stdio.h>
int main(void) {
  printf("hello, world\n");
  return (0);
}
$ cc -g main.c 
$ gdb -q a.out
(gdb) break main
Breakpoint 1 at 0x8048548: file main.c, line 4.
(gdb) run
Starting program: /share/home/jp/src/gdb/a.out 

Breakpoint 1, main () at main.c:4
4         printf("hello, world\n");
(gdb) next
hello, world
5         return (0);
(gdb) c
Continuing.
Program exited normally.
(gdb) q
\end{verbatim}
\item debuggery jsou výbornými pomocníky pokud vá¹ program konèí na chyby typu
``segmentation error'' -- tj. kdy¾ zkusíte nekorektnì pøistoupit do pamìti,
napøíklad tam kde nemáte co dìlat. Kdy¾ pøi pøekladu pou¾ijete option
\texttt{-g}, uká¾e vám pak debugger pøesnì èíslo øádku, kde nastal problém.
Konkrétní pøíklad (proè se vlastnì tento program chová jak se chová??? Hint:
zkuste pøelo¾it na Solarisu pøekladaèem \texttt{cc} a spustit):
\begin{verbatim}
$ cat -n main.c
     1  int
     2  main(void)
     3  {
     4          char *c = "hey world";
     5          c[0] = '\0';
     6          return (0);
     7  }
}
$ gcc -g main.c
$ ./a.out
Bus error (core dumped)
$ gdb a.out a.out.core
...
Core was generated by `a.out'.
Program terminated with signal 10, Bus error.
...
#0  0x080484e6 in main () at main.c:5
5               c[0] = '\0';
\end{verbatim}
\end{itemize}

%%%%%
\pagebreak
\pdfbookmark[0]{basic terms and conventions of UNIX and its API}{terms}

\begin{slide}
\sltitle{Contents}
\slidecontents{2}
\end{slide}

%%%%%

\pdfbookmark[1]{standard header files}{stdhdrs}

\begin{slide}
\sltitle{Standardní hlavièkové soubory (ANSI~C)}
\renewcommand{\arraystretch}{1}
\begin{tabular}{l@{\hspace{3ex}\dots\hspace{3ex}}l}
\texttt{stdlib.h} & základní makra a funkce \\
\texttt{errno.h} & o¹etøení chyb \\
\texttt{stdio.h} & vstup a výstup \\
\texttt{ctype.h} & práce se znaky \\
\texttt{string.h} & práce s øetìzci \\
\texttt{time.h} & práce s datem a èasem \\
\texttt{math.h} & matematické funkce \\
\texttt{setjmp.h} & dlouhé skoky \\
\texttt{assert.h} & ladicí funkce \\
\texttt{stdarg.h} & práce s promìnným poètem parametrù \\
\texttt{limits.h} & implementaènì závislé konstanty \\
\texttt{signal.h} & o¹etøení signálù
\end{tabular}
\end{slide}

\begin{itemize}
\item hlavièkový soubor (\emph{header file}) je soubor s deklaracemi funkcí
(\emph{forward declaration}), pro\-mìn\-ných a maker. Z pohledu preprocesoru
je to obyèejný soubor napsaný v jazyce C.
\item \emsl{tyto hlavièkové soubory nejsou specifické pro UNIX. Jsou souèástí
standardu ANSI~C, který jak ji¾ víme (strana \pageref{C_LANGUAGE}), je zahrnut v
POSIX.1. Je ale dùle¾ité si uvìdomit, ¾e tyto hlavièkové soubory musí podporovat
ka¾dý systém, který podporuje ANSI~C, a» ji¾ podporuje POSIX.1 nebo ne.}
\item pøíslu¹ný hlavièkový soubor pro konkrétní funkci najdete v manuálové
stránce dané funkce, toto je zaèátek manuálové stránky na Solarisu pro
\texttt{memcpy}:
\begin{verbatim}
Standard C Library Functions                         memory(3C)

NAME
   memory, memccpy, memchr, memcmp, memcpy, memmove,  memset  -
   memory operations

SYNOPSIS
   #include <string.h>
...
...
\end{verbatim}
\item jednotlivá makra obsa¾ená v tìchto souborech vìt¹inou nejsou
vysvìt\-le\-na, význam jednotlivých maker je ale mo¾né si vyhledat v
pøíslu¹ných specifikacích, které jsou on-line. Na nìkterých systémech
(Solaris) mají jednotlivé hlavièkové soubory svoji vlastní manuálovou stránku
(\texttt{man stdlib.h}).
\item makro \texttt{assert} je mo¾né z bìhem kompilace odstranit pomocí makra
\texttt{NDEBUG}. Pøíklad: \example{assert/assert.c}.

\begin{verbatim}
cat assert.c 
#include <assert.h>

int
main(void)
{
        assert(1 == 0);
        return (13);
}
$ cc assert.c 
$ ./a.out 
Assertion failed: 1 == 0, file assert.c, line 6
Abort (core dumped)
$ cc -DNDEBUG assert.c 
$ ./a.out 
$ echo $?
13
\end{verbatim}
\end{itemize}


%%%%%

\begin{slide}
\sltitle{Standardní hlavièkové soubory (2)}
\begin{tabular}{l@{\hspace{3ex}\dots\hspace{3ex}}l}
\texttt{unistd.h} & symbolické konstanty, typy a základní funkce \\
\texttt{sys/types.h} & datové typy \\
\texttt{fcntl.h} & øídící operace pro soubory \\
\texttt{sys/stat.h} & informace o souborech \\
\texttt{dirent.h} & procházení adresáøù \\
\texttt{sys/wait.h} & èekání na synovské procesy \\
\texttt{sys/mman.h} & mapování pamìti \\
\texttt{curses.h} & ovládání terminálu \\
\texttt{regex.h} & práce s regulárními výrazy\\
\end{tabular}
\end{slide}

\begin{itemize}
\item tyto headery u¾ patøí do UNIXu.
\item zajímavé mù¾e být podívat se do \texttt{sys/types.h}
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Standardní hlavièkové soubory (3)}
\begin{tabular}{l@{\hspace{3ex}\dots\hspace{3ex}}l}
\texttt{semaphore.h} & semafory (POSIX) \\
\texttt{pthread.h} & vlákna (POSIX threads) \\
\texttt{sys/socket.h} & sí»ová komunikace \\
\texttt{arpa/inet.h} & manipulace se sí»ovými adresami\\
\texttt{sys/ipc.h} & spoleèné deklarace pro System~V IPC \\
\texttt{sys/shm.h} & sdíle{}ná pamì» (System~V) \\
\texttt{sys/msg.h} & fronty zpráv (System~V)\\
\texttt{sys/sem.h} & semafory (System~V) \\
\end{tabular}
\end{slide}

\begin{itemize}
\item dokonèení nejdùle¾itìj¹ích UNIXových headerù. Existují samozøejmì
je¹\-tì dal\-¹í.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Konvence pøedávání parametrù a environmentových promìnných

\pdfbookmark[1]{argv, argc}{args}

\begin{slide}
\sltitle{Funkce \texttt{main()}}
\renewcommand{\baselinestretch}{0.4}
\begin{itemize}
\setlength{\itemsep}{-0.5ex}
\setlength{\topsep}{1\itemsep}
\item pøi spu¹tìní programu je pøedáno øízení funkci \texttt{main()}.
\item \texttt{int \funnm{main} (int \emph{argc}, char *\emph{argv}[]);}
    \begin{itemize}
    \item \texttt{argc} \dots poèet argumentù pøíkazové øádky
    \item \texttt{argv} \dots pole argumentù
	\begin{itemize2}
	\item podle konvence je \texttt{argv[0]} jméno programu (bez cesty)
	\item poslední prvek je \texttt{argv[argc] == NULL}
	\end{itemize2}
    \item návrat z \texttt{main()} nebo volání \texttt{exit()} ukonèí program
    \item standardní návratové hodnoty \verb#EXIT_SUCCESS# (0) a
    \verb#EXIT_FAILURE# (1)
    \end{itemize}
\end{itemize}

\begin{center}
\input{img/tex/main.pstex_t}
\end{center}
\end{slide}

\begin{itemize}
\item první parametr (typu \texttt{int}) udává poèet argumentù na pøíkazovém
øádku (vèet\-nì argumentu 0 -- jména programu) a druhý parametr (typu
\texttt{char**}) je pole ukazatelù na tyto øetìzce. Za posledním øetìzcem je
je¹tì ukonèovací \texttt{NULL} pointer -- pozor na to, ¾e to je nìco jiného ne¾
prázdný øetìzec.
\item \label{SHELL_ARGV0} \texttt{argv[0]} nìkdy bývá dùle¾itým zdrojem pøidané
informace. Na Solarisu jsou napøíklad pøíkazy \texttt{cp}, \texttt{mv} a
\texttt{ln} nalinkované na stejný soubor. Hodnota \texttt{argv[0]} pak urèuje,
jakou funkci vlastnì proces má. Jiný pøíklad -- pokud má shell první znak z
\texttt{argv[0]} nastaven na ``-'', znamená to, ¾e se má chovat jako login shell
(podívejte se tøeba do manuálové stránky pro \texttt{bash} na sekci INVOCATION,
pokud nevíte, co to je login shell). Ve výpisu procesù pak uvidíte ``-bash''.
Toto není souèást UNIX specifikace pro \texttt{sh}, ale pou¾íval to ji¾ Bourne
shell na UNIXu V7 (1979) a ostatní shelly to pøevzaly.
\item pøi spu¹tìní programu pøedá kód dynamického linkeru øízení funkci
\texttt{main}, viz strana \pageref{RUNTIMELINKER}. Staticky slinkovanému
programu se øízení pøedá pøímo. Ne\-pøí\-tom\-nost \texttt{main} v programu
zpùsobí chybu pøi pøekladu na úrovni linkeru. Této funkci se pøedá jméno
spu¹tìného programu, argumenty z pøíkazové øádky a pøípadnì i pro\-mìn\-né
prostøedí. Ukonèení této funkce znamená konec programu a návratová hodnota se
pou¾ije jako kód ukonèení programu pro OS. Jinou mo¾ností ukonèení programu je
pou¾ití funkce \texttt{exit} nebo \verb#_exit#, kterou lze pou¾ít
kdykoliv, nejen ve funkci \texttt{main}. V C lze pou¾ívat obì metody
ukonèení programu.
\item pøedání promìnných prostøedí tøetím parametrem typu \texttt{char**}
není souèástí normativní èásti C standardu, pouze informativní. Pøekladaèe to
ale typicky podporují. Varianta \texttt{main} s pro\-mìn\-ný\-mi prostøedí
pak vypadá takto:\\ \texttt{int \funnm{main}(int \emph{argc}, char
*\emph{argv}[], char *\emph{envp}[]);}
\item návratový typ funkce \texttt{main} by mìl být v¾dy \texttt{int}; pøekladaè
si jinak bude stì¾ovat. \emsl{Z této hodnoty se ale pou¾ije pouze nejni¾¹ích 8
bitù}, a je to nezáporné èíslo. Pozor na to, ¾e na rozdíl od konvence jazyka C
návratová hodnota 0 má v shellu význam true (úspìch) a nenula význam false
(neúspìch). Typická konstrukce v shellu vypadá takto:
\begin{verbatim}
if ! prog; then
        echo "failure"
else
        echo "success"
fi
\end{verbatim}
Pøíklad: \example{main/return-256.c}.
\item \label{RETURN255} nepou¾ívejte proto ve funkci \texttt{main}
\texttt{return (-1)} a nikde pak ani
\texttt{exit(-1)}, z toho vznikne návratová hodnota \texttt{255} a kód je
matoucí. Je vùbec velmi vhodné pou¾ívat pouze \texttt{0} a \texttt{1}, pokud
není
zá\-sad\-ní dùvod pro jiné hodnoty, tøeba ten ¾e jich potøebujete více -- mù¾ete
se podívat napøíklad na manuálovou stránku pro \texttt{passwd} na Solarisu,
sekce \texttt{EXIT STATUS}. Pøíklad: \example{main/return-negative-1.c}.


\item rozdíl mezi funkcemi \texttt{exit} a \verb#_exit# je v tom, ¾e
\texttt{exit} pøed ukonèením programu je¹tì vyprázdní (pomocí knihovní
funkce \texttt{fflush}) a zavøe streamy a volá funkce
zaregistrované pomocí \texttt{atexit}. V závislosti na systému to mohou být i
dal¹í akce.

Pro zajímavost, napøíklad ve FreeBSD je \texttt{\_exit} systémové
volání a \texttt{exit} knihovní funkce, ale na Solarisu jsou obì systémovými
voláními. Pøíklad: \example{exit/exit.c}
\item \label{MAIN_C} pøíklad: \example{main/print-argv.c}
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Promìnné prostøedí}
\begin{itemize}
\item seznam v¹ech promìnných prostøedí (\emph{environment
variables}) se pøedává jako promìnná\\ \texttt{extern char
**\funnm{environ};}
\item je to pole ukazatelù (ukonèené NULL) na øetìzce ve tvaru:\\
\texttt{\emph{promìnná}=\emph{hodnota}}
\end{itemize}
\begin{center}
\input{img/tex/environ.pstex_t}
\end{center}
\end{slide}

\begin{itemize}
\item shell pøedává spu¹tìnému programu ty promìnné, které jsou oznaèeny jako
exportované (Bourne-like shellech pøíkazem \texttt{export \emph{variable}}). Po
zmìnì obsahu ji¾ jednou exportované promìnné samozøejmì není potøeba promìnnou
znovu exportovat. Pøíkaz \texttt{env} vám vypí¹e aktuální promìnné
prostøedí.
Abyste pøidali promìnnou do prostøedí spou¹tìného programu staèí provést
pøiøazení na pøíkazové øádce, ani¾ byste museli mìnit prostøedí va¹eho
shellu:
\begin{verbatim}
$ date
Sun Oct  7 13:13:58 PDT 2007
$ LC_TIME=fr date
dimanche  7 octobre 2007 13 h 14 PDT
\end{verbatim}

nedivte se, pokud to na va¹em systému takto fungovat nebude, v tom pøípadì
nemáte instalovaný balík s francouzskou lokalizací (co¾ je pravdìpodobné).
\item pøi nahrazení aktuálního obrazu procesu obrazem jiným se pøedává, pokud
se neøekne jinak, synovským procesùm celé pole \texttt{environ} automaticky.
Je mo¾né ve volání pøíslu¹né varianty funkce \texttt{exec} pøedat pole jiné.
\item jaké promìnné prostøedí konkrétní pøíkaz pou¾ívá (a jak je pou¾ívá) by
mìlo být v manuálové stránce. Typicky v sekci nazvané \emph{ENVIRONMENT} nebo
\emph{ENVIRONMENT VARIABLES}
\item \texttt{man} napøíklad pou¾ívá \texttt{PAGER}, \texttt{vipw} pak
promìnnou \texttt{EDITOR} apod.
\item pokud je \texttt{envp} tøetím parametrem funkce \texttt{main}, tak je to
stejná hodnota co je v ukazateli \texttt{environ}.
\item pøíklad: \example{main/print-env.c} (vèetnì pou¾ití
\texttt{env} pøíkazu zpùsobem, který vyèistí zdìdìné promìnné prostøedí).
\begin{verbatim}
$ cc print-env.c
$ env - XXX=yyy aaa=ABC ./a.out
aaa=ABC
XXX=yyy
\end{verbatim}
\end{itemize}


%%%%%

\pdfbookmark[1]{getenv, putenv, setenv}{envfuncs}

\begin{slide}
\sltitle{Manipulace s promìnnými prostøedí}
\begin{itemize}
\item je mo¾né pøímo mìnit promìnnou \texttt{environ}, SUSv3 to ale nedoporuèuje
\item \texttt{char *\funnm{getenv} (const char *\emph{name});}
    \begin{itemize}
    \item vrátí hodnotu promìnné name
    \end{itemize}
\item \texttt{int \funnm{putenv} (char *\emph{string});} 
    \begin{itemize}
    \item vlo¾í string ve tvaru \texttt{\emph{jméno}=\emph{hodnota}} do
    prostøedí (pøidá novou nebo modifikuje existující promìnnou)
    \end{itemize}
\item zmìny se pøená¹ejí do synovských procesù
\item zmìny v prostøedí syna samozøejmì prostøedí otce neovlivní
\item existují i funkce \funnm{setenv}() a \funnm{unsetenv}()
\end{itemize}
\end{slide}

\begin{itemize}
\item u \texttt{putenv} se vlo¾ený øetìzec stane souèástí prostøedí (jeho
pozdìj¹í zmìna tak zmìní prostøedí) a nesmíte proto pou¾ívat retìzce v
automatických pro\-mìn\-ných, toto øe¹í \texttt{setenv}, který hodnotu promìnné
zkopíruje. Viz pøíklad \example{main/putenv.c}.
\item dùle¾ité je zapamatovat si, ¾e synovský proces zdìdí v okam¾iku svého
vzniku od rodièe v¹echny promìnné prostøedí, ale jakákoliv manipulace s nimi v
synovi je lokální a do otce se nepøená¹í. Ka¾dý proces má svou kopii
pro\-mìn\-ných, proto ani následná zmìna prostøedí otce nezmìní promìnné
ji¾ existujícího potomka.
\item dal¹í rozdíl mezi \texttt{putenv} a \texttt{setenv} je ten, ¾e v
\texttt{setenv} mohu definovat, zda existující promìnnou chci nebo nechci
pøepsat. \texttt{putenv} v¾dy pøepisuje.
\item
\begin{verbatim}
int
main(void)
{
        printf("%s\n", getenv("USER"));
        return (0);
}
$ ./a.out 
jp
\end{verbatim}
\item jeliko¾ promìnná \texttt{environ} je obyèejné pole ukazatelù na øetìzce,
není nebì¾né narazit na kód, který s tímto polem pracuje pøímo. Pozor v¹ak na
to, ¾e v takovém pøípadì pak ji¾ nesmíte pou¾ívat zde uvedené funkce, jinak se
mù¾ete dostat do problémù s jejich konkrétní implementací. A hlavnì, nový kód
takto nepi¹te, proto¾e norma SUSv3 pøímou práci s tímto polem nedoporuèuje.
\item pøíklad: \example{main/getenv.c}
\item pozor na to, ¾e je rozdíl mezi nastavením hodnoty promìnné na
prázdný string a odmazáním promìnné ze seznamu promìnných (pomocí
\texttt{unsetenv}).
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Zpracování argumentù programu}
\begin{itemize}
\item obvyklý zápis v shellu: \verb#program -pøepínaèe argumenty#
\item pøepínaèe tvaru \texttt{-x} nebo \texttt{-x \emph{hodnota}}, kde
\texttt{x} je jedno písmeno nebo èíslice, \texttt{\emph{hodnota}} je libovolný
øetìzec
\item nìkolik pøepínaèù lze slouèit dohromady: \texttt{ls -lRa}
\item argument '\texttt{--}' nebo první argument nezaèínající '\texttt{-}'
ukonèuje pøepínaèe, následující argumenty nejsou pova¾ovány za pøepínaèe, i
kdy¾ zaèínají znakem '\texttt{-}'.
\item tento tvar argumentù po¾aduje norma a lze je zpracovávat automaticky
funkcí \texttt{getopt}.
\end{itemize}
\end{slide}

\begin{itemize}
\item argumenty lze samozøejmì zpracovávat vlastní funkcí, ale standardní
funkce je pohodlnìj¹í.
\item argumenty se typicky mohou opakovat, ale to má smysl jen v nìkterých
situacích
\item poøadí pøepínaèù mù¾e být dùle¾ité a je na aplikaci, aby toto
specifikovala
\item UNIX norma definuje pomocí 13 pravidel velmi pøesnì, jak by mìly vypadat
názvy pøíkazù a formát pøepínaèù. Napøíklad jméno pøíkazu by mìlo být pouze
malými písmeny, dlouhé 2--9 znakù, z pøenositelné znakové sady. Pøepínaèe bez
argumentù by mìlo být mo¾né dát do skupiny za jedním znakem '--'. Atd.
\item pou¾ívat èíslice jako pøepínaèe je zastaralé; je to nìkde v normì
SUSv3, i kdy¾ já to v ní nena¹el.
\item pozor na Linux a jeho (ponìkud zvlá¹tní a nestandardní) permutování
argumentù
\item pøepínaè \texttt{-W} by mìl být rezervovaný pro vendor options, tj. pro
nepøenositelná roz¹íøení
\end{itemize}

%%%%%

\pdfbookmark[1]{getopt}{getopt}

\begin{slide}
\setlength{\baselineskip}{0.8\baselineskip}
\sltitle{Zpracování pøepínaèù: \texttt{getopt()}}
\begin{tabbing}
\texttt{int \funnm{getopt}(}\=\texttt{int \emph{argc},
char *const \emph{argv}[],}\\
\>\texttt{const char *\emph{optstring});}\\
\texttt{extern char *\emph{optarg};}\\
\texttt{extern int \emph{optind}, \emph{opterr}, \emph{optopt};} 
\end{tabbing}
\begin{itemize}
\item funkce dostane parametry z pøíkazového øádku, pøi ka¾dém
volání zpracuje a vrátí dal¹í pøepínaè. Pokud má pøepínaè hodnotu,
vrátí ji v \texttt{optarg}. 
\item kdy¾ jsou vyèerpány v¹echny pøepínaèe, vrátí -1 a v
\texttt{optind} je èíslo prvního nezpracovaného argumentu. 
\item mo¾né pøepínaèe jsou zadány v \texttt{optstring}, kdy¾ za
znakem pøepínaèe následuje '\texttt{:}', má pøepínaè povinnou
hodnotu. 
\item pøi chybì (neznámý pøepínaè, chybí hodnota) vrátí
'\texttt{?}', ulo¾í znak pøepínaèe do \texttt{optopt} a kdy¾
\texttt{opterr} nebylo nastaveno na nulu, vypí¹e chybové hlá¹ení.
\end{itemize}
\end{slide}

\begin{itemize}
\item obvykle se nejprve pomocí \texttt{getopt} naètou pøepínaèe a pak se
vlastními pro\-støed\-ky zpracují ostatní argumenty; èasto jsou to jména
souborù.
\item je konvencí, ¾e volby v parametru \texttt{optstring} jsou setøídìné.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Pøíklad pou¾ití \texttt{getopt()}}
\setlength{\baselineskip}{0.8\baselineskip}
\begin{alltt}
struct \{
    int a, b; char c[128]; 
\} opts; 
int opt; char *arg1; 

while((opt = \emprg{getopt}(argc, argv, "abc:")) != -1) 
    switch(opt) \{ 
        case 'a': opts.a = 1; break; 
        case 'b': opts.b = 1; break; 
        case 'c': \sout{strcpy}(opts.c, \emprg{optarg}); break; 
        case '?': fprintf(stderr, 
            "usage: %s [-ab] [-c Carg] arg1 arg2 ...\bs{}n", 
            basename(argv[0])); break; 
    \} 
arg1 = argv[\emprg{optind}];
\end{alltt}
\end{slide}

\begin{itemize}
\item dobrým zvykem je pøi detekování neznámého pøepínaèe nebo ¹patného
zá\-pi\-su parametrù programu vypsat struènou nápovìdu, pøípadnì s odkazem na
podrobnìj¹í dokumentaci, a ukonèit program s chybou, tj. s nenulovou
ná\-vra\-to\-vou hodnotou.
\item pøíklad také ukazuje nebezpeèné pou¾ití funkce \texttt{strcpy}
\item z pou¾ití funkce \texttt{getopt} je vidìt, ¾e je stavová. Zpracovat dal¹í
pole argumentù, pøípadnì zaèít opìt od zaèátku, je mo¾né nastavením externí
pro\-mìn\-né \texttt{optreset} na 1.
\item standardní \texttt{getopt} zachová poøadí pøepínaèù pøi zpracování
\item pøi pou¾ití nedefinovaného pøepínaèe funkce vypí¹e chybu; to lze potlaèit
na\-sta\-ve\-ním \texttt{opterr} na 0.
\item \label{GETOPT} pøíklad: shellový skript \example{getopt/getopts.sh}
pøepsaný do jazyka C pomocí \texttt{getopt} funkce, \example{getopt/getopt.c}
\end{itemize}

%%%%%

\pdfbookmark[1]{getopt\_long}{getoptlong}

\begin{slide}
\sltitle{Dlouhý tvar pøepínaèù}
\setlength{\baselineskip}{0.8\baselineskip}
\begin{itemize}
\item poprvé se objevilo v GNU knihovnì \texttt{libiberty}: 
\begin{verbatim}
      --jméno nebo --jméno=hodnota 
\end{verbatim}
\item argumenty se permutují tak, aby pøepínaèe byly na zaèátku, napø.
\verb#ls * -l# je toté¾ jako \verb#ls -l *#, standardní chování lze docílit
nastavením promìnné \verb#POSIXLY_CORRECT#.
\item zpracovávají se funkcí \texttt{\funnm{getopt\_long}()}, která pou¾ívá
pole struktur popisujících jednotlivé pøepínaèe: 
{\tt
\begin{tabbing}
stru\=ct \funnm{option} \{\\
\>const char *name; \textrm{/* jméno pøepínaèe */} \\
\>int has\_arg; \textrm{/* hodnota: ano, ne, \emsl{volitelnì} */} \\
\>int *flag; \textrm{/*~}\=\textrm{kdy¾ je \texttt{NULL}, funkce vrací
\texttt{val}, jinak vrací 0}\\\>\>\textrm{a dá \texttt{val} do \texttt{*flag}
*/} \\
\>int val; \textrm{/* návratová hodnota */} \\
\};
\end{tabbing}}
\end{itemize}
\end{slide}

verze jak se objevila ve FreeBSD (funkce \textrm{getopt\_long} není
standarizovaná), má následující vlastnosti:

\begin{itemize}
\item pokud v¹echny dlouhé pøepínaèe mají nastaveny krátkou variantu
ve \texttt{val}, je chování \texttt{getopt\_long} kompatibilní s
\texttt{getopt}
\item je mo¾né zadávat argument k dlouhému pøepínaèi i s mezerou
(na\-pøí\-klad \texttt{--color~green})
\item pokud je nastaven \texttt{flag}, tak \texttt{getopt\_long}
vrací 0, èím¾ se tyto dlouhé pøe\-pí\-na\-èe bez krátké varianty zpracují v
jedné vìtvi pøíkazu \texttt{case}
\item existuje i volání \texttt{getopt\_long\_only}, které povoluje
i dlouhé pøepínaèe uvozené jednou uvozovkou (\texttt{-option})
\item funkci \texttt{getopt\_long} je mo¾né pou¾ívat dvìmi zpùsoby.
První zpùsob je, ¾e ka¾dý dlouhý pøepínaè má korespondující krátký
-- takto lze jednodu¹e pøidat dlouhé pøepínaèe do existujícího
programu a je \emsl{kompatibilní s getopt}. Druhý zpùsob umo¾òuje
mít samostatné dlouhé pøepínaèe. V tom pøípadì funkce vrací v¾dy 0
(nekompatibilita s \texttt{getopt}) a promìnná \texttt{*flag} se
nastaví na \texttt{val}.
\item na konkrétním pøíkladu na následující stránce je vidìt, jak to
celé funguje
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Dlouhé pøepínaèe (pokraèování)}
{\tt\begin{tabbing}
int \funnm{getopt\_long}(\=int \emph{argc}, char * const \emph{argv}[],\\
\>const char *\emph{optstring},\\
\>const struct option *\emph{longopts},\\
\>int *\emph{longindex}); 
\end{tabbing}}
\begin{itemize}
\item \texttt{optstring} obsahuje jednopísmenné pøepínaèe,
\texttt{longopts} obsahuje adresu pole struktur pro dlouhé pøepínaèe
(poslední záznam pole obsahuje samé nuly) 
\item pokud funkce narazí na dlouhý pøepínaè, vrací odpovídající
\texttt{val} nebo nulu (pokud \texttt{flag} nebyl \texttt{NULL}),
jinak je chování shodné s \texttt{getopt}.
\item do \texttt{*longindex} (kdy¾ není \texttt{NULL}) dá navíc
in{}dex nalezeného pøepínaèe v \texttt{longopts}.
\end{itemize}
\end{slide}

\begin{itemize}
\item toto je upravený pøíklad z manuálové stránky na FreeBSD:
{\footnotesize
\begin{verbatim}
#include <stdio.h>
#include <getopt.h>
#include <fcntl.h>

int ch, fd, daggerset, bflag = 0;

static struct option longopts[] = {
       { "buffy",      no_argument,            NULL,           'b' },
       { "fluoride",   required_argument,      NULL,           'f' },
       { "daggerset",  no_argument,            &daggerset,     1 },
       { NULL,         0,                      NULL,           0 }};

int main(int argc, char **argv)
{
  while ((ch = getopt_long(argc, argv, "bf:", longopts, NULL)) != -1)
         switch (ch) {
         case 'b':
                 bflag = 1; break;
         case 'f':
                 if ((fd = open(optarg, O_RDONLY, 0)) == -1)
                         printf("unable to open %s", optarg);
                 break;
         case 0:
                 if (daggerset) {
                         printf("Buffy will use her dagger to "
                             "apply fluoride to dracula's teeth\n");
                 }
                 break;
         default: printf("usage: ...\n");
  }
  argc -= optind; argv += optind;
  return 0;
}
\end{verbatim}
}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Struktura systému, systémová volání

% (jp) tohle neni uplne klasicka struktura, je to jedna z moznosti.
% Nevidim moc duvod tu ten slajd mit. OSy uz koneckoncu meli...

%%%\begin{slide}
%%%\sltitle{Klasická struktura operaèního systému}
%%%\begin{center}
%%%\input{klasicky_os.tex}
%%%\end{center}
%%%\end{slide}
%%%
%%%Hardware poèítaèe je "obalen" jednotlivými vrstvami operaèního
%%%systému, kdy ka¾dá vrstva roz¹iøuje schopnosti vrstvy spodní.
%%%Programové rozhraní operaèního systému (API) pøedstavuje pro
%%%aplikace virtuální (logický) poèítaè, který skrývá detaily
%%%hardwarové architektury, poskytuje slu¾by vy¹¹í úrovnì a v
%%%neposlední øadì definuje pøístupová práva a navzájem chrání
%%%jednotlivé bì¾ící aplikace.

%%%%%

\begin{slide}
\sltitle{Struktura klasického OS UNIX}
\input{img/tex/struktura.pstex_t}
\end{slide}

\begin{itemize}
\item toto schéma je pøevzato z [Bach86], viz literatura. Zdùrazòuje dva
ústøední pojmy v modelu systému UNIX -- soubory a procesy. \emsl{V dne¹ní dobì
to vypadá velmi odli¹nì, ale pro nás staèí tato základní pøedstava.}
\item UNIX rozli¹uje dva re¾imy bìhu procesoru: \emph{u¾ivatelský re¾im} a
\emph{re¾im jádra}. V u¾ivatelském re¾imu nejsou pøístupné privilegované
instrukce (napø. mapování pamìti, I/O, maskování pøeru¹ení). Tyto dva re¾imy
musí být podporovány na hardwarové úrovni (procesorem).
\item procesy bì¾í obvykle v u¾ivatelském re¾imu, do re¾imu jádra pøechází buï
instrukcí synchronního pøeru¹ení (trap) pro volání slu¾by jádra, nebo na
základì asynchronních pøeru¹ení (hodiny, I/O). Dále se v~re¾imu jádra
o\-¹e\-tøu\-jí výjimeèné stavy procesoru (výpadek stránky, naru¹ení ochrany
pamìti, ne\-zná\-má instrukce apod.). Nìkteré speciální akce jsou zaji¹»ovány
systémovými procesy, které bì¾í celou dobu v re¾imu jádra.
\item klasické UNIXové jádro je tvoøeno monolitickým kódem. Pùvodnì bylo
po\-tøe\-ba vygenerovat (tj. pøelo¾it ze zdrojových textù a slinkovat) jádro pøi
zmìnì nìkterého parametru nebo pøidání ovladaèe zaøízení. V novìj¹ích
implementacích je mo¾no nastavovat parametry jádra, nìkdy i za bìhu, pomocí
systé\-mo\-vých utilit bez nutnosti rekompilace jádra. Moderní unixové systémy
umo¾òují roz¹iøovat kód jádra za bìhu pomocí tzv. modulù jádra (\emph{loadable
kernel modules}). Napøíklad systém FreeBSD 5.4-RELEASE má 392 takových modulù.
\item existují dva zpùsoby práce s perifériemi: bloková (\emph{block devices})
a znaková zaøízení (\emph{character, raw devices}). Data z blokových zaøízení
(napø. disky) procházejí pøes vyrovnávací pamìti (\emph{buffers}) po blocích,
znaková zaøízení (napø. terminály) umo¾òují pracovat s jednotlivými bajty a
nepou¾ívají vyrovnávací pamì».
\item \emsl{jádro není samostatný proces}, ale je èástí ka¾dého u¾ivatelského
procesu. Kdy¾ jádro nìco vykonává, tak vlastnì proces, bì¾ící v re¾imu jádra,
nì\-co provádí.
\end{itemize}


%%%%%

\begin{slide}
\sltitle{Procesy, vlákna, programy}
\begin{itemize}
\item \emsl{proces} je systémový objekt charakterizovaný svým
kontextem, identifikovaný jednoznaèným èíslem (\emsl{process ID},
\emsl{PID}); jinými slovy \uv{kód a data v pamìti} 
\item \emsl{vlákno (thread)} je systémový objekt, který existuje uvnitø
procesu a je charakterizován svým stavem. V¹echna vlákna jednoho procesu sdílí
stejný pamì»ový prostor kromì registrù procesoru a zásobníku; \uv{linie
výpoètu}, \uv{to, co bì¾í} 
\item \emsl{program} ... soubor pøesnì definovaného formátu obsahující
instrukce, data a slu¾ební informace nutné ke spu¹tìní; \uv{spustitelný soubor
na disku}
\end{itemize}

\begin{itemize}
\item[$\circ$] \emsl{pamì»} se pøidìluje \emsl{procesùm}. 
\item[$\circ$] \emsl{procesory} se pøidìlují \emsl{vláknùm}.
\item[$\circ$] vlákna jednoho procesu mohou bì¾et na rùzných procesorech.
\end{itemize}
\end{slide}

\begin{itemize}
\item \emsl{\emph{kontext}} je pamì»ový prostor procesu, obsah registrù a datové
struktury jádra týkající se daného procesu
\item jinak øeèeno -- kontext procesu je jeho stav. Kdy¾ systém
vykonává proces, øíká se, ¾e bì¾í v kontextu procesu. Jádro (klasické)
obsluhuje pøeru¹ení v kontextu pøeru¹eného procesu.
\item vlákna se dostala do UNIXu a¾ pozdìji, pùvodnì v nìm existovaly pouze
procesy, které mìly z dne¹ního pohledu pouze jedno vlákno. Mo¾nost pou¾ít v
procesu více vláken byla zavedena, proto¾e se ukázalo, ¾e je vhodné mít více
paralelních linií výpoètu nad sdíle{}nými daty.
\item pamì»ové prostory procesù jsou navzájem izolované, ale procesy spolu
mohou komunikovat. Pozdìji se dozvíme, ¾e mohou i èásteènì sdílet pamì».
\item procesy jsou entity na úrovni jádra, ale vlákna mohou být èásteènì nebo
zcela implementována knihovními funkcemi. V pøípadì implementace pomocí
knihovních fukncí to znamená, ¾e vlákna nemusí jádro vùbec podporovat. S vlákny
je spojena men¹í re¾ie ne¾ s~procesy.
\item systémový proces, který bì¾í na pozadí obvykle po celou dobu bìhu
systému a zaji¹»uje nìkteré systémové slu¾by (\texttt{inetd}, \texttt{cron},
\texttt{sendmail}\dots) se nazývá \emph{démon} (angl. \emph{daemon}). Systém
BSD tedy nemá ve znaku èerta, ale démona.
\end{itemize}

%%%%%


\begin{slide}
\sltitle{Jádro, re¾imy, pøeru¹ení (klasický UNIX)}
\begin{itemize}
\item procesy typicky bì¾í v u¾ivatelském re¾imu
\item systémové volání zpùsobí pøepnutí do re¾imu jádra
\item proces má pro ka¾dý re¾im samostatný zásobník
\item jádro je èástí ka¾dého u¾ivatelského procesu, není to samostný proces
(procesy)
\item pøepnutí na jiný proces se nazývá \emph{pøepnutí kontextu}
\item obsluha pøeru¹ení se provádí v kontextu pøeru¹eného procesu
\item klasické jádro je nepreemptivní
\end{itemize}
\end{slide}

\begin{itemize}
\item \emsl{jádro není oddìl{}ená mno¾ina procesù, bì¾ících paralelnì s
u\-¾i\-va\-tel\-ský\-mi procesy, ale je èástí ka¾dého u¾ivatelského procesu.}
\item pøechod mezi u¾ivatelským re¾imem a re¾imem jádra není pøepnutí kontextu
-- proces bì¾í poøád v tom samém
\item pøeru¹ený proces nemusel pøeru¹ení vùbec zpùsobit
\item v re¾imu jádra mù¾e proces pøistupovat i k adresám jádra, která z
u\-¾i\-va\-tel\-ské\-ho re¾imu pøístupná nejsou; takté¾ mù¾e pøistupovat k
instrukcím (napø. instrukce manipulující se stavovým registrem), jejich¾
vykonání v u¾ivatelském re¾imu vede k chybì
\item pøeru¹ovací rutina se nemù¾e zablokovat, proto¾e tím by zablokovala
proces; proces se toti¾ mù¾e zablokovat jen ze své vlastní vùle. Moderní unixy
dnes pou¾ívají interrupt vlákna, v jejich¾ kontextu se \emsl{mohou} drivery
zablokovat.
\item to, ¾e klasické unixové jádro je nepreemptivní znamená, ¾e \emsl{jeden
proces nemù¾e zablokovat jiný proces}
\item pøi obsluze pøeru¹ení se mù¾e stát, ¾e nastane dal¹í pøeru¹ení. Pokud je
jeho priorita vìt¹í, je procesorem pøijmuto. Posloupnost pøijmutých pøeru¹ení
je uchována v \emph{zásobníku kontextových vrstev}.
\item \emsl{u moderních kernelù je situace èasto velmi rozdílná -- obsluha
pøe\-ru\-¹e\-ní, preemptivnost kernelu atd.; k nìkterým vìcem se mo¾ná
dostaneme pozdìji bìhem semestru}
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Volání slu¾eb a komunikace mezi procesy}
\begin{itemize}
\item UNIX\vspace{1ex}

\input{img/tex/syscall_unx.tex}
\item distribuovaný OS\vspace{1ex}

\input{img/tex/syscall_dist.tex}
\end{itemize}
\end{slide}

\begin{itemize}
\item pokud unixový proces vy¾aduje provedení systémové slu¾by, pomocí
systé\-mo\-vé\-ho volání pøedá øízení jádru. Jádro je kus kódu sdíle{}ný v¹emi
procesy (ov¹em pøístupný jen pro ty, které jsou právì v re¾imu jádra). Jádro
tedy není samostatný privilegovaný proces, ale v¾dy bì¾í v rámci nìkterého
procesu (toho, který po¾ádal jádro o slu¾bu, nebo toho, který bì¾el v okam¾iku
pøíchodu pøeru¹ení).
\item komunikace mezi procesy v UNIXu je øe¹ena pomocí systémových volání, je
tedy zprostøedkovaná jádrem.
\item aby to nebylo tak jednoduché, mohou existovat systémové procesy
(o\-zna\-èo\-va\-né jako \emph{kernel threads}), které bì¾í celou dobu v
re¾imu jádra. Naprostá vìt¹ina systémových procesù v¹ak bì¾í v u¾ivatelském
re¾imu a li¹í se jen tím, ¾e mají vìt¹í pøístupová práva. Plánovaè procesù
pøepíná mezi procesy a tím umo¾òuje bìh více procesù souèasnì i na jednom
procesoru. Na multiprocesorových poèítaèích pak funguje skuteèný paralelismus
procesù a vláken (dokonce se proces mù¾e pøi pøeplánování dostat i na jiný
procesor).
\item v distribuovaném operaèním systému má jádro obvykle formu mikrojádra,
tj. zaji¹»uje pouze nejzákladnìj¹í slu¾by øízení procesoru, pøidìlování pamìti
a komunikace mezi procesy. Vy¹¹í systémové slu¾by, které jsou v UNIXu souèástí
jádra (napø. pøístup k systému souborù) jsou realizovány speciálními procesy
(servery) bì¾ícími v u¾ivatelském re¾imu procesoru. Jádro pøedá po¾adavek
u¾ivatelského procesu pøíslu¹nému serveru, který mù¾e bì¾et i na jiném uzlu
sítì.
\item dostupných mikrokernelù je v dne¹ní dobì mnoho. Mù¾ete zkusit napøíklad
Minix (u{}nix-like výukový systém), pøípadnì systém HURD, který bì¾í nad
mikrojádrem Mach.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Systémová volání, funkce}
\begin{itemize}
\item v UNIXu se rozli¹ují \emsl{systémová volání} a \emsl{knihovní
funkce}.  Toto rozli¹ení dodr¾ují i manuálové stránky: sekce
\emsl{2} obsahuje systémová volání (\emph{syscalls}), sekce \emsl{3}
knihovní funkce (\emph{library functions}). 
    \begin{itemize}
    \item knihovní funkce se vykonávají v u¾ivatelském re¾imu,
    stejnì jako ostatní kód programu. 
    \item systémová volání mají také tvar volání funkce. Pøíslu¹ná funkce ale
    pouze zpracuje argumenty volání a pøedá øízení jádru pomocí instrukce
    synchronního pøeru¹ení. Po návratu z jádra funkce upraví výsledek a pøedá ho
    volajícímu. 
    \end{itemize}
\item standardy tyto kategorie nerozli¹ují -- z hlediska programátora je jedno,
zda urèitou funkci provede jádro nebo knihovna.
\end{itemize}
\end{slide}

\begin{itemize}
\item zjednodu¹enì lze øíci, ¾e systémové volání je funkce, která
jen upraví své argumenty do vhodné podoby, pøepne re¾im procesoru a
skuteènou práci nechá na jádru. Nakonec zase upraví výsledek.
\emsl{Knihovní funkce mù¾e a nemusí volat jádro, ale v¾dy sama dìlá
nìjakou netriviální èinnost v u¾ivatelském re¾imu.}
\item v assembleru je mo¾né zavolat volání jádra pøímo
\item API jádra je definované na úrovni volání funkcí standardní
knihovny, nikoliv na úrovni pøeru¹ení a datových struktur
pou¾ívaných tìmito funkcemi pro pøedání øízení jádru. Mechanismus
pøepnutí mezi u¾ivatelským re¾imem a re¾imem jádra se toti¾ mù¾e
li¹it nejen v závislosti na hardwarové platformì, ale i mezi rùznými
verzemi systému na stejném hardwaru. 
\end{itemize}
%%%%%

\pdfbookmark[1]{syscall return values semantics}{syscallretvals}

\begin{slide}
\sltitle{Návratové hodnoty systémových volání}
\setlength{\baselineskip}{0.8\baselineskip}
\begin{itemize}
\item celoèíselná návratová hodnota (\texttt{int}, \texttt{pid\_t},
\texttt{off\_t}, apod.)
    \begin{itemize}
    \item \texttt{>= 0} \dots{} operace úspì¹nì provedena 
    \item \texttt{== -1} \dots{} chyba 
    \end{itemize}
\item návratová hodnota typu ukazatel 
    \begin{itemize}
    \item \texttt{!= NULL} \dots{} operace úspì¹nì provedena 
    \item \texttt{== NULL} \dots{} chyba 
    \end{itemize}
\item po neúspì¹ném systémovém volání je kód chyby v globální
promìnné \texttt{extern int \funnm{errno};}
\item úspì¹né volání nemìní hodnotu v \texttt{errno}! Je tedy tøeba
nejprve otestovat návratovou hodnotu a pak teprve \texttt{errno}. 
\item chybové hlá¹ení podle hodnoty v \texttt{errno} vypí¹e funkce\\
\texttt{void \funnm{perror}(const char *\emph{s});}
\item textový popis chyby s daným èíslem vrátí funkce\\
\texttt{char *\funnm{strerror}(int \emph{errnum});}
\end{itemize}
\end{slide}

%%%%%

\begin{itemize}
\item \label{ERRNO} v Solarisu je hodnota \texttt{errno} ve
skuteènosti knihovnou \texttt{libc} definovaná jako dereferencovaný
pointer na integer (specifický pro daný userland thread) a hodnota se
nastavuje ihned po výstupu z instrukce pro systémové volání. Napø. na i386
architektuøe je hodnota \texttt{errno} po návratu z kernelu (po dokonèení
instrukce \texttt{sysenter}) ulo¾ena v registru \texttt{eax} (pøed voláním
v ní bylo èíslo syscallu). Je to tedy knihovna \texttt{libc} kdo je
zodpovìdný za to, ¾e program uvidí správnou hodnotu \texttt{errno}.


\item funkce pro práci s vlákny \texttt{pthread\_*} nenastavují
\texttt{errno}, ale vrací buï nulu (úspìch) nebo pøímo kód chyby.
\item pro nìkterá volání mù¾e mít smysl i návratová hodnota
\texttt{-1}. Pak je tøeba nejprve nastavit \texttt{errno~=~0} a po
návratu zkontrolovat, zda se \texttt{errno} zmìnilo. Napø. funkce
\texttt{strtol} vrací pøi chybì 0, co¾ je platná hodnota i pro
správný výsledek (a $-1$ je samozøejmì platný výsledek také).
\item je tedy v¾dy nutné si pøeèíst manuálovou stránku pro pøí¹lu¹né
volání nebo knihovní funkci
\item pozn.: úspì¹nost funkcí ze \texttt{stdio.h} je tøeba testovat pomocí\\
\texttt{int \funnm{ferror}(FILE *\emph{stream})}, proto¾e jinak nelze rozli¹it
mezi chybou a koncem streamu. Vzhledem k tomu, ¾e tyto funkce nepou¾íváme (kromì
\texttt{printf} a \texttt{fprintf} na \texttt{stdout}, resp. \texttt{stderr}),
nemìli byste ji potøebovat.
\end{itemize}

\begin{slide}
\sltitle{Formatted error messages: \texttt{err(3)}}
\setlength{\baselineskip}{0.8\baselineskip}
\begin{itemize}
\item functions to display a formatted error message and optionally exit
\item instead of \funnm{perror}() and \funnm{exit}(), one function suffices
\item
\texttt{void \funnm{err}(int \emph{status}, const char *\emph{fmt}, ...);}
\begin{itemize}
\item prints a program name, formatted string, and error based on
\texttt{errno}
\item exits the program with \emph{status} return value
\end{itemize}
\item
\texttt{void \funnm{warn}(const char *\emph{fmt}, ...);}
\begin{itemize}
\item same as \funnm{err}() but does not exit
\end{itemize}
\item see the manual page for other functions from the same family
\item originated in 4.4BSD
\end{itemize}
\end{slide}

%%%%%

\begin{itemize}
\label{ERR}
\item The third widely used function is \funnm{errx}() which behaves as
\funnm{err}() but does not use \texttt{errno}.  Similarly, \funnm{warnx}().
\item These functions are very handy especially for smaller programs as they are
easy to work with and save you some lines of code.  More complex
app\-li\-ca\-tions often use their own logging functions.
\item Not part of the UNIX specification but in general you can find them almost
everywhere.
\item Example (and also in \example{err/err.c}):

\begin{verbatim}
#include <errno.h>
#include <err.h>

int
main(void)
{
        errno = 13;
        err(3, "ggr %s", "GRR");
        printf("after err()\n");
        return (0);
}

$ ./a.out 
a.out: ggr GRR: Permission denied
$ echo $?
3
\end{verbatim}

\end{itemize}

\endinput
