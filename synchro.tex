
\pagebreak
\pdfbookmark[0]{process synchronization and communication}{synchro}

\begin{slide}
\sltitle{Contents}
\slidecontents{6}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

changequote([[[, ]]])

\pdfbookmark[1]{shared data conflict}{conflict}

\begin{slide}
\sltitle{Problem: conflict while sharing data}
\begin{itemize}
\item \texttt{struct \{ int a, b; \} \emph{shared};}
\item
\begin{alltt}
for( ; ; ) \{
    \emprg{/* non-atomic operation */
    a = shared.a; b = shared.b;}
    if (a != b) printf("NON-CONSISTENT STATE");
    \emprg{/* non-atomic operation */
    shared.a = val; shared.b = val;}
\} 
\end{alltt}
\item if the cycle is run in 2 proceses running in parallel (or threads)
that share the same structure and have different values of the
\texttt{val} variable, it will lead to conflicts due to non-atomic operations.
\end{itemize}
\end{slide}

\label{SYNCHRONIZATION}

\begin{itemize}
\item operations that can be expressed in C with single statement does not
have to be atomic. e.g. on RISC processors the command \verb.a++.
is typically translated into:

\begin{verbatim}
load reg,[a]
inc reg
store [a],reg
\end{verbatim}

due to the fact that on this architecture numbers cannot be incremented
directly in memory. For such cases there are sets of functions for atomic
arithmetic operations (e.g. \texttt{atomic\_add(3c)} on Solaris) that are
much faster than classic synchronization mechanisms.
More on page \pageref{ATOMIC_ADD}.
\item in general similar problem happens when multiple processes share a 
system resource.
\item \label{RACE_C} example \example{race/race.c}
\end{itemize}


%%%%%

\begin{slide}
\sltitle{Conflict scenario}
\begin{tabular}{rl@{\hspace{2cm}}|c|c|}
\multicolumn{2}{l}{Processes \emsl{A}\texttt{(val==1)} and
\emsl{B}\texttt{(val==2)}} & \multicolumn{1}{c}{\texttt{a}} &
\multicolumn{1}{c}{\texttt{b}}\\
% \cline{3-4}
1. & initial structure state & ? & ? \\
% \cline{3-4}
2. & process \emsl{A} writes to member \texttt{a} & 1 & ? \\
% \cline{3-4}
3. & process \emsl{B} writes to member \texttt{a} & 2 & ? \\
% \cline{3-4}
4. & process \emsl{B} writes to member \texttt{b} & 2 & 2 \\
% \cline{3-4}
5. & process \emsl{A} writes to member \texttt{b} & 2 & 1 \\
% \cline{3-4}
6. & \multicolumn{1}{l}{\parbox[t]{5cm}{the structure is in inconsistent state
and one of the processes will find out.}}
\end{tabular}
\end{slide}

\begin{itemize}
\item more possibilities:
\begin{enumerate}
\item structure is in inconsistent state, e.g. \texttt{(1, 1)}
\item process \texttt{B} writes \texttt{2} into member \texttt{a}
\item process \texttt{A} reads the value of the structure \texttt{(2, 1)}
earlier than process \texttt{B} writes member \texttt{b}
\end{enumerate}
\item note that synchronization problems surface only after when the program
is running on multiprocessor(core) machine or on more processors than
what is used when development. Something to think about when testing.
\end{itemize}

%%%%%

\pdfbookmark[1]{mutual exclusion}{mutexcl}

\begin{slide}
\sltitle{Solution: mutual process exlusion}
\begin{itemize}
\item it is necessary to ensure atomic operation on the structure, i.e.
while one processes modifies the structure, the other cannot manipulate it. 
\end{itemize}
\begin{tabular}{rl@{\hspace{2cm}}|c|c|}
\multicolumn{2}{l}{Processes \emsl{A}\texttt{(val==1)} and
\emsl{B}\texttt{(val==2)}} & \multicolumn{1}{c}{\texttt{a}} &
\multicolumn{1}{c}{\texttt{b}}\\
% \cline{3-4}
1. & initial structure state & ? & ? \\
% \cline{3-4}
2. & process \emsl{A} writes to member \texttt{a} & 1 & ? \\
% \cline{3-4}
\setbox0=\hbox{$\left\{\vphantom{\begin{tabular}{c}\hline1\\
\hline1\\ \hline1\\ \hline \end{tabular}}\right.$}
\ht0=0pt\dp0=0pt\box0
3. & process \emsl{B} must wait & 1 & ? \\
% \cline{3-4}
4. & process \emsl{A} writes to member \texttt{b} & 1 & 1 \\
% \cline{3-4}
\setbox0=\hbox{$\left\{\vphantom{\begin{tabular}{c}\hline1\\
\hline1\\ \hline \end{tabular}}\right.$}
\dimen0=\ht0 \advance\dimen0 by \dp0 \dimen0=0.25\dimen0
\ht0=0pt\dp0=0pt \raisebox{-\dimen0}{\box0}%
5. & proces \emsl{B} writes to member \texttt{a} & 2 & 1 \\ 
% \cline{3-4}
6. & proces \emsl{B} writes to member \texttt{b} & 2 & 2 \\ 
% \cline{3-4}
7. & \multicolumn{1}{l}{the structure is consistent.}\\
\end{tabular}
\end{slide}

\label{CRITICALSECTION}

\begin{itemize}
\item it is necessary to ensure mutual exclusion also when reading,
so that the process that is reading cannot read inconsistent state while
another process is changing it. While writing it is necessary to exclude
all other processes. While reading it is sufficient to exlude only writers.
\item \emsl{\emph{critical section}} is piece of code that can be executed
only in one process (or thread), otherwise the operations can lead to
inconsistent state, e.g. wrongly connected linked list, mismatched database
indexes etc. It is possible to say that critical section is code which accesses
or modifies resource shared with multiple processes (or threads) and therefore
access to such code should be synchronized. Critical section should be as
short as possible to limit contention. The second definition is more generic,
it can also include situations where only one process (or thread) can change
the state however if this is not happening, more processes can read
simultaneously.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Problem: readers and writers conflict}
\begin{itemize}
\item several processes running in parallel write protocol with operations
to common log file. Each new record is appended to the end of the file.
\item if the record writing operation is not atomic, the contents of multiple
records can be interleaved.
\item only single process can write.
\item other processes read data from the log file.
\item while reading record that is being written inconsitent data is retrived.
\item while writing, it is not possible to read. If no process is writing,
multiple processes can read simultaneously.
\end{itemize}
\end{slide}

\begin{itemize}
\item 2 situations are permitted: one writer or multiple readers
\item on local disk the synchronization of writers can be archived via the
\texttt{O\_APPEND} flag, however this is not going to work on network file
systems such as NFS or in case it is necessary to perform multiple
\texttt{write()} operations for single record. Moreover this does not solve
the situation of readers -- it is still possible to read while writing.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Solution: file locking}
\begin{itemize}
\item writer process locks the file for writing. Other processes
(readers and writers) cannot work with the file and have to wait for the lock
to be unlocked.
\item reader process locks the file for reading. Writers have to wait
for the lock, other readers can also lock the file for reading and read data.
\item in each moment there can be at most active lock for writing or multiple
locks for reading. Both locks cannot be locked simultaneously.
\item for efficiency each process should hold the lock for shortest time
possible and if possible do not lock the whole file -- only the section that 
is being worked with. Passive waiting is preferred, active waiting is
suitable for very short time.
\end{itemize}
\end{slide}

\begin{itemize}
\item 2 ways of waiting:
\begin{description}
\item[active (busy waiting)] -- process test a condition in a cycle while it
is not true.
\item[passive] -- processer registers itself in the kernel as a waiting for
the condition and goes asleep. The kernel wakes it up if the condition becomes
true.
\end{description}
\item \label{BUSYWAITING} active waiting is justifiable only in special
situations.
\end{itemize}

%%%%%

\pdfbookmark[1]{synchronization mechanisms}{synchromechs}

\begin{slide}
\sltitle{Synchronization mechanisms}
\begin{itemize}
\item theoretical solution -- mutual exclusive algorithms (Dekker
1965, Peterson 1981) 
\item interrupt disable (1 CPU), special \emph{test-and-set} instructions
\item \emsl{lock-files}
\item tools offered by the operating system:
    \begin{itemize}
    \item \emsl{semaphores} (POSIX, System V IPC) 
    \item \emsl{file level locking} (\texttt{fcntl()}, \texttt{flock()}) 
    \item thread synchronization: \emsl{mutexes} (surround critical sections,
    only one thread can hold the mutex), \emsl{condition variables}
    (the thread is blocked until another thread signals condition change)
    \emsl{read-write locks} (shared and exclusive locks, simular semantics
    to file level locking)
    \end{itemize}
\end{itemize}
\end{slide}

\begin{itemize}
\item both Dekker and Peterson need to achieve the result only shared memory,
i.e. several variables shared by processes.
\item Dekker's solution is presented as a first solution to the problem of
mutual exlusion of 2 processes, without having to apply the mechanism of
strict alternation, i.e. if second process does not express will to enter
critical section, the first can enter how many times it wants (and vice versa).
Dekker's solution is not trivial, compare it with 16 year younger
Peterson solution, e.g. on \texttt{en.wikipedia.org}.
\item we are not going to deal with theoretical algorithms or compare hardware
mechanisms used by the kernel. Instead we are going to focus on the use of 
file level locking (which use the atomicity of some file operations)
and special synchronization primitives offered by the kernel.
\end{itemize}

%%%%%

\pdfbookmark[1]{lock files}{lockfiles}

\begin{slide}
\sltitle{Lock files}
\begin{itemize}
\item for each shared resource there exists previously agreed file path.
Locking is done by creating the file, unlocking by removing the file.
Each process must check if the file exists and if yes, has to wait.
\end{itemize}
\begin{alltt}
void \funnm{lock}(char *lockfile) \{ 
    while( (fd = open(lockfile, 
                      O\_RDWR|O\_CREAT|\emprg{O\_EXCL}, 0600)) == -1) 
        sleep(1); {\rm /* waiting in a loop for unlock */}
    close(fd); 
\} 

void \funnm{unlock}(char *lockfile) \{ 
    unlink(lockfile); 
\}
\end{alltt}
\end{slide}

\begin{itemize}
\item \label{LOCK_UNLOCK} The key is the \texttt{O\_EXCL} flag.
\item example: \example{file-locking/lock-unlock.c} -- use together with 
the \example{file-locking/run.sh} shell script.
\item In case of process crash the locks are not removed and therefore other
processes would wait forever. Thus it is prudent to write PID of the process 
that created the lock to the lock file. The process that is waiting for unlock
can verify that the process with given PID number exists. If not, it can remove
the lock file and retry. User level command that can do this is e.g.
\emsl{shlock}(1) (on FreeBSD in \texttt{/usr/ports/sysutils/shlock}), however
could cause situation in the following paragraph:
\item \emsl{watch out:} if multiple processes find out simultaneously that
the process does not exist, it can lead to error. First process deletes the
lock file and creates new one with its PID. Next process does the same,
because the operation of reading file contents and removing it is not atomic.
Now both processes think they acquired the lock.
\item \emsl{problem:} the \texttt{lock()} function contains active waiting.
This can be solved e.g. so that the process that acquired the lock can open
named pipe for writing. Reader processes will enter sleep by reading from the
pipe.
The \texttt{unlock()} will close the pipe and so the waiting processes will
be unblocked.
\item Lock files are usually used for situations where multiple instances of
the same program are unwanted.
\end{itemize}

%%%%%

\pdfbookmark[1]{fcntl}{fcntl}

\begin{slide}
\sltitle{file locking: \texttt{fcntl()}}
\texttt{int \funnm{fcntl}(int \emph{fildes}, int \emph{cmd}, ...);}
\begin{itemize}
\item to set locks for file \texttt{fildes}:
\texttt{cmd}: 
    \begin{itemize}
    \item \texttt{F\_GETLK} \dots{} takes lock description from 3rd argument
    and replaces it with description of existing lock that collides with it.
    \item \texttt{F\_SETLK} \dots{} sets or destroys lock described by the 3rd
    argument. If the lock cannot be set immediately returns $-1$.
    \item \texttt{F\_SETLKW} \dots{} like \texttt{F\_SETLK}, however puts
    the process to sleep if it is not possible to set the lock 
    (\texttt{W} means ``wait'')
    \end{itemize}
\item 3rd argument contains lock description and is pointer to 
\texttt{struct flock}
\end{itemize}
\end{slide}

\begin{itemize}
\item locking of files over NFS is done via the \texttt{lockd} daemon.
\item there are 2 types of locks:
    \begin{description}
    \item [advisory locks] -- for correct operation it is necessary that all
    processes working with locked files to check locks before reading/writing.
    used more frequently.
    \item [mandatory locks] -- if a file is locked, read/write operations will
    automatically block the process, i.e. the lock will be applied also on
    processes that do not explicitly work with the lock.
        \begin{itemize}
	\label{MANDATORY}
	\item not universally recommended, do not always work
        (e.g. \texttt{lockd} implements just advisory locking)
	\item for given file they are enabled by setting the SGID bit and
        removing right to execute for the group
	(tj. setting that otherwise does not make sense).
	One process sets the lock (e.g. using \texttt{fcntl}). Other processes
	then do not have to check the lock explicitly because each
	\texttt{open/read/write} operation is checked by the kernel against
	the file locks and enforces waiting till the lock is explicitly
	unlocked by the owner process.\\
	\item implemented e.g. on Solaris, Linux. FreeBSD does not support it.
	The fcntl(2) man page on Linuxu (2013) does not recommend it because
	the implementation contains errors that could lead to race conditions
	and therefore the consistency cannot be generally achieved.
        \end{itemize}
    \end{description}
\item It is important to realize that when process exits, all its locks are
released.
\end{itemize}

%%%%%

\pdfbookmark[1]{flock}{flock}

\begin{slide}
\sltitle{File locking: \texttt{struct flock}}
\begin{itemize}
\item \texttt{l\_type} \dots{} typ zámku 
    \begin{itemize}
    \item \texttt{F\_RDLCK} \dots{} shared lock (for reading)
    \item \texttt{F\_WRLCK} \dots{} exclusive lock (for writing)
    \item \texttt{F\_UNLCK} \dots{} unlock
    \end{itemize}
\item \texttt{l\_whence} \dots{} same as for \texttt{lseek()}, i.e.
\texttt{SEEK\_SET},
\texttt{SEEK\_CUR}, \texttt{SEEK\_END}
\item \texttt{l\_start} \dots{} start of locked region with regards to
\texttt{l\_whence}
\item \texttt{l\_len} \dots{} length of the region in bytes, 0 means till the
end of the file
\item \texttt{l\_pid} \dots{} PID of the process holding the lock, used
only for \texttt{F\_GETLK} when returning.
\end{itemize}
\end{slide}

\begin{itemize}
\item If given part is not locked when using \texttt{F\_GETLK},
the \texttt{flock} structure is returned unchanged except for the first member
that is set to \texttt{F\_UNLCK}.
\item \label{FCNTL_LOCKING} example: \example{file-locking/fcntl-locking.c}
\item \label{FCNTL_FIXED_RACE_C} example on how to use fcntl (it is 
,,fixed'' version of previous \example{race/race.c} example from page
\pageref{RACE_C}): \example{race/fcntl-fixed-race.c}.
\item locking via \texttt{fcntl} and \texttt{lockf} has one important property
that is being described in the \texttt{fcntl} man page in FreeBSD:

\emph{This interface follows the completely stupid semantics of System V
and IEEE Std 1003.1-1988 (``POSIX.1'') that require that all locks
associated with a file for a given process are removed when any file
descriptor for that file is closed by that process. This semantic
means that applications must be aware of any files that a subroutine
library may access. For example if an application for updating the
password file locks the password file database while making the
update, and then calls \texttt{getpwnam}(3) to retrieve a record,
the lock will be lost because \texttt{getpwnam}(3) opens, reads, and
closes the password database.}
\item The \texttt{lockf} function (SUSv3) is simpler variant of
\texttt{fcntl}, specifies only how to lock and how many bytes from the current
position in the file. Very often implemented as \texttt{fcntl} wrapper.
\item example \example{file-locking/lockf.c} demonstrates how mandatory
locking works and the use of the \texttt{lockf} function.
\end{itemize}


%%%%%

\pdfbookmark[1]{deadlock}{deadlock}

\begin{slide}
\sltitle{Deadlock}
\begin{itemize}
\item 2 shared resrouces \texttt{res1} and \texttt{res2} protected by locks
\texttt{lck1} and \texttt{lck2}. Processes \texttt{p1} and
\texttt{p2} want to have exclusive access to both resources.
\end{itemize}
\begin{center}
\input{img/tex/deadlock.tex}
\end{center}
\begin{itemize}
\item \emsl{watch out the locking order !}
\end{itemize}
\end{slide}

\begin{itemize}
\item Generally deadlock happens if process is waiting for an event that cannot
happen. Here e.g. 2 processes are waiting for each other, for the other to
release the lock however that will never happen. Next possibility is deadlock
of single process that is reading from a pipe after forgetting to close
the write end of the pipe. If there is no one else that has the pipe open,
the read will block because the all file desriptor copies of the write end are
not closed and therefore the end of file cannot happen until the reading process
closed the write end however it cannot do it because it is blocked.
in \texttt{read} syscall:

\label{FIFODEADLOCK}
\begin{verbatim}
int main(void)
{
        int c, fd;
        mkfifo("test", 0666);
        fd = open("test", O_RDWR);
        read(fd, &c, sizeof(c));
        /* never reached */
        return (0);
}

$ ./a.out 
^C
\end{verbatim}
\item \texttt{fcntl()} checks for deadlock and returns \texttt{EDEADLK}.
\item It is best to avoid deadlock by correct programming and do not rely on the
system.
\end{itemize}


%%%%%

\pdfbookmark[1]{System V IPC}{sysvipc}

\begin{slide}
\sltitle{System V IPC}
\begin{itemize}
\item \emsl{IPC} je zkratka pro \emph{Inter-Process Communication}
\item komunikace mezi procesy \emsl{v rámci jednoho systému}, tj.
nezahrnuje sí»ovou komunikaci 
\item \emsl{semafory} \dots{} pou¾ití pro synchronizaci procesù 
\item \emsl{sdíl{}ená pamì»} \dots{} pøedávání dat mezi procesy,
pøiná¹í podobné problémy jako sdíl{}ení souborù, k øe¹ení lze pou¾ít
semafory 
\item \emsl{fronty zpráv} \dots{} spojují komunikaci (zpráva nese
data) se synchronizací (èekání procesu na pøíchod zprávy) 
\item prostøedky IPC mají podobnì jako soubory definovaná \emsl{pøístupová
práva} (pro ètení a zápis) pro vlastníka, skupinu a ostatní.
\end{itemize}
\end{slide}

\begin{itemize}
\item uvìdomte si, ¾e tyto prostøedky se vztahují ke konkrétnímu systému, System
V, kde se objevily jako první. Dal¹í systémy je pak pøevzaly. \emsl{Ze
tøí zde uvedených synchronizaèních prostøedkù Systemu V se budeme zabývat pouze
semafory. Pro sdíl{}enou pamì» je mo¾né pou¾ít ji¾ probrané volání
\texttt{mmap}, místo zasílání zpráv je mo¾né pou¾ít so\-cke\-ty (budou v nìkteré
z pøí¹tích pøedná¹ek).}
\item prostøedky IPC existují i poté, kdy skonèí proces, který je vytvoøil. O
jejich zru¹ení je nutno explicitnì po¾ádat (ze shellu lze zjistit seznam IPC
prostøedkù pøíkazem \texttt{ipcs} a smazat je pøíkazem \texttt{ipcrm}). Stav a
obsah existujících prostøedkù IPC zùstává v platnosti, i kdy¾ s nimi právì
nepracuje ¾ádný proces (napø. data ve sdíle{}né pamìti zùstávají, i kdy¾ ji
nemá ¾ádný proces pøipojenou).
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Semafory}
\begin{itemize}
\item zavedl je E. Dijkstra
\item semafor s je datová struktura obsahující 
    \begin{itemize}
    \item celé nezáporné èíslo \texttt{i} (volná kapacita) 
    \item frontu procesù \texttt{q}, které èekají na uvolnìní 
    \end{itemize}
\item operace nad semaforem: 
    \begin{description}
    \item [init(s, n)]~\\
    vyprázdnit \texttt{s.q; s.i = n}
    \item [P(s)]~\\
    \texttt{if(s.i > 0) s.i-- else\\
    uspat volající proces a zaøadit do s.q }
    \item [V(s)]~\\
    \texttt{if(s.q prázdná) s.i++ else\\
    odstranit jeden proces z s.q a probudit ho}
    \end{description}
\end{itemize}
\end{slide}

\begin{itemize}
\item \emsl{P} je z holandského \uv{proberen te verlagen} -- zkus
dekrementovat, \emsl{V} pak ze slova \uv{verhogen} -- inkrementovat.
\item operace \texttt{P(s)} a \texttt{V(s)} lze zobecnit: hodnotu semaforu je
mo¾né mìnit o libovolnou hodnotu \texttt{n} \dots{} \texttt{P(s,~n)},
\texttt{V(s,~n)}.
\item Allen B. Downey: \emph{The Little Book of Semaphores}, Second Edition,
on-line na \url{http://greenteapress.com/semaphores/}
\item \emph{binární semafor} má pouze hodnotu 0 nebo 1
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Vzájemné vylouèení pomocí semaforù}
\begin{itemize}
\item jeden proces inicializuje semafor
\begin{alltt}
sem s;
init(s, 1);
\end{alltt}
\item kritická sekce se doplní o operace nad semaforem
\begin{alltt}
...
\emprg{P(s)};
kritická sekce;
\emprg{V(s)};
...
\end{alltt}
\end{itemize}
\end{slide}


\begin{itemize}
\item inicializace semaforu na hodnotu \texttt{n} dovolí vstoupit do kritické
sekce \texttt{n} procesùm. Zde semafor funguje jako zámek, v¾dy ho odemyká
(zvy¹uje hodnotu) stejný proces, který ho zamknul (sní¾il hodnotu).
\item obecnì ale mù¾e semafor zvednout jiný proces, ne¾ který ho sní¾il; jinak
by to ani nemìlo velký smysl. Je zde rozdíl oproti zámkùm, viz strana
\pageref{MUTEXES}.
\end{itemize}

%%%%%

\pdfbookmark[1]{segmget, semctl, semop}{semfncs}

\begin{slide}
\sltitle{API pro semafory}
\texttt{int \funnm{semget}(key\_t \emph{key}, int \emph{nsems}, int
\emph{semflg});}
\begin{itemize}
\item vrátí identifikátor pole obsahujícího \texttt{nsems} semaforù asociovaný
s~klíèem \texttt{key} (klíè \texttt{IPC\_PRIVATE} \dots{} privátní semafory, pøi
ka¾dém pou¾ití vrátí jiný identifikátor). \texttt{semflg} je OR-kombinace
pøístupových práv a konstant \texttt{IPC\_CREAT} (vytvoøit, pokud neexistuje),
\texttt{IPC\_EXCL} (chyba, pokud existuje). 
\end{itemize}
\texttt{int \funnm{semctl}(int \emph{semid}, int \emph{semnum},
int \emph{cmd}, ...);}
\begin{itemize}
\item øídicí funkce, volitelný ètvrtý parametr \texttt{arg} je typu
\texttt{union~semun}. 
\end{itemize}
\texttt{int \funnm{semop}(int \emph{semid}, struct sembuf *\emph{sops}, size\_t
\emph{nsops});}
\begin{itemize}
\item zobecnìné operace P a V.
\end{itemize}
\end{slide}

\begin{itemize}
\item jak získat klíè pro \texttt{semget} je vysvìtleno na strane
\pageref{FTOK}.
\item nejvìt¹í zajímavost na System V implementaci semaforù je skuteènost, ¾e
daný syscall neoperuje nad jedním semaforem, ale nad \emsl{polem semaforù}, a to
atomicky. Vìt¹inou v¹ak budete potøebovat pouze jeden semafor, tj. pole o jednom
prvku. Pro takové pou¾ití jsou System V semafory zbyteènì slo¾ité.
\item pøístupová práva jsou jen pro ètení a zápis; bit execute zde nemá smysl.
\item podobné schéma API funkcí (funkce na vytvoøení, øízení a operace) dodr¾ují
i ostatní System V IPC mechanismy.
\item jakmile je jednou pole semaforù jedním procesem vytvoøeno, mohou i ostatní
procesy pou¾ít \texttt{semctl()} a \texttt{semop()}, ani¾ by pøedtím volaly
\texttt{semget()}. To platí i pro semafory vytvoøené s klíèem
\texttt{IPC\_PRIVATE}, pro které nelze volat \texttt{semget()}, proto¾e by se
tím vytvoøilo nové pole semaforù. Je to tak proto, aby i privátní semafory mohly
být dìdìné v rámci \texttt{fork}.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{API pro semafory: \texttt{semctl()}}
\setlength{\baselineskip}{0.9\baselineskip}
\begin{itemize}
\item \texttt{semnum} \dots{} èíslo semaforu v poli 
\item mo¾né hodnoty \texttt{cmd}: 
    \begin{itemize}
    \item \texttt{GETVAL} \dots{} vrátí hodnotu semaforu 
    \item \texttt{\emsl{SETVAL}} \dots{} \emsl{nastaví semafor na hodnotu}
    \texttt{arg.val}
    \item \texttt{GETPID} \dots{} PID procesu, který provedl
    poslední operaci 
    \item \texttt{GETNCNT} \dots{} poèet procesù èekajících na vìt¹í
    hodnotu 
    \item \texttt{GETZCNT} \dots{} poèet procesù èekajících na nulu 
    \item \texttt{GETALL} \dots{} ulo¾í hodnoty v¹ech semaforù do
    pole
    \texttt{arg.array}
    \item \texttt{SETALL} \dots{} nastaví v¹echny semafory podle
    \texttt{arg.array}
    \item \texttt{IPC\_STAT} \dots{} do \texttt{arg.buf} dá poèet
    semaforù, pøístupová práva a èasy posledních \texttt{semctl()} a
    \texttt{semop()}
    \item \texttt{IPC\_SET} \dots{} nastaví pøístupová práva 
    \item \texttt{IPC\_RMID} \dots{} zru¹í pole semaforù
    \end{itemize}
\end{itemize}
\end{slide}

\begin{itemize}
\item volání \texttt{semctl(semid, semnum, SETVAL, arg)} odpovídá obecné
semaforové inicializaèní operaci \texttt{init(s,~n)}.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{API pro semafory: \texttt{semop()}}
\begin{itemize}
\item operace se provádí atomicky (tj. buï se povede pro v¹echny
semafory, nebo pro ¾ádný) na \texttt{nsops} semaforech podle pole
\texttt{sops} struktur \texttt{struct~sembuf}, která obsahuje: 
    \begin{itemize}
    \item \texttt{sem\_num} \dots{} èíslo semaforu 
    \item \texttt{sem\_op} \dots{} operace 
        \begin{itemize}
        \item \texttt{P(sem\_num, abs(sem\_op))} pro \texttt{sem\_op < 0}
        \item \texttt{V(sem\_num, sem\_op)} pro \texttt{sem\_op > 0}
        \item èekání na nulovou hodnotu semaforu pro \texttt{sem\_op == 0} 
        \end{itemize}
    \item \texttt{sem\_flg} \dots{} OR-kombinace 
        \begin{itemize}
        \item \texttt{IPC\_NOWAIT} \dots{} kdy¾ nelze operaci hned provést,
        neèeká a vrátí chybu 
        \item \texttt{SEM\_UNDO} \dots{} pøi ukonèení procesu vrátit
        operace se semaforem
        \end{itemize}
    \end{itemize}
\end{itemize}
\end{slide}

\begin{itemize}
\item atomiènost pøes mno¾inu semaforù zajistí, ¾e nedojde k deadlocku
v následující situaci: dva procesy $A$ a $B$ budou pou¾ívat dva semafory k
øízení pøístupu (zamykání) ke dvìma systémovým zdrojùm. Proces $A$ je bude
zamykat v poøadí $(0, 1)$ a proces $B$ v poøadí $(1, 0)$. Ve chvíli,
kdy proces $A$ zamkne semafor $0$ a $B$ zamkne $1$, dojde k
deadlocku, proto¾e ani jeden proces nemù¾e pokraèovat (potøeboval by
zamknout druhý semafor). Pøi pou¾ití atomické operace zamèení obou
semaforù najednou bude úspì¹ný v¾dy právì jeden proces, který získá
oba semafory, druhý bude èekat.
\item \texttt{SEM\_UNDO} zajistí, ¾e pøi ukonèení procesu dojde k odemèení
semaforù (po\-u\-¾i\-tých jako zámky), které tento proces mìl zamèené.
\end{itemize}

%%%%%

\pdfbookmark[1]{ftok}{ftok}

\begin{slide}
\sltitle{Vytváøení prostøedkù IPC}
\begin{itemize}
\item jeden proces prostøedek vytvoøí, ostatní se k nìmu pøipojí. 
\item po skonèení pou¾ívání je tøeba prostøedek IPC zru¹it. 
\item funkce \texttt{semget()}, \texttt{shmget()} a
\texttt{msgget()} mají jako první parametr klíè identifikující
prostøedek IPC. Skupina procesù, která chce komunikovat, se musí
domluvit na spoleèném klíèi. Rùzné skupiny komunikujících procesù by
mìly mít rùzné klíèe. 
\end{itemize}
\texttt{key\_t \funnm{ftok}(const char *\emph{path}, int \emph{id});}
\begin{itemize}
\item vrátí klíè odvozený ze zadaného jména souboru \texttt{path} a
èísla \texttt{id}. Pro stejné \texttt{id} a libovolnou cestu
odkazující na stejný soubor vrátí stejný klíè. Pro rùzná \texttt{id}
nebo rùzné soubory na stejném svazku vrátí rùzné klíèe. 
\end{itemize}
\end{slide}

\label{FTOK} poznámky k \texttt{ftok()}:
\begin{itemize}
\item z \texttt{id} se pou¾ije jen nejni¾¹ích 8 bitù.
\item není specifikováno, zda bude stejný klíè vrácen i po smazání a
znovuvytvoøení souboru. Vìt¹inou ne, proto¾e v klíèi se èasto odrá¾í èíslo
indexového uzlu.
\item rùzné klíèe pro rùzné soubory nejsou v¾dy zaruèené. Napø. na Linuxu se
klíè získá kombinací 16 bitù èísla i-uzlu, 8 bitù \texttt{id} a 8 bitù
vedlej¹ího èísla zaøízení. Stejný klíè pro rùzné soubory je vrácen, pokud se
èísla i-uzlù shodují na spodních 16 bitech.
\item pokud tedy nepøíbuzné procesy chtìjí pou¾ívat stejný semafor, \emsl{musí
být jmého souboru pro klíè domluveno pøedem.}
\item \label{SEM_FIXED_RACE_C} pøíklad na semafory (je to pomocí semaforù
,,opravená'' verze døívej¹ího pøí\-kla\-du \example{race/race.c} ze strany
\pageref{RACE_C}): \example{race/sem-fixed-race.c}.
\end{itemize}

%%%%%

\pdfbookmark[1]{shm\_open, sem\_open, mq\_open}{posixipc}

\begin{slide}
\sltitle{Dal¹í prostøedky IPC}
\begin{itemize}
\item POSIX a SUSv3 definují je¹tì dal¹í prostøedky komunikace mezi procesy: 
    \begin{itemize}
    \item \emsl{signály} \dots{} pro u¾ivatelské úèely lze vyu¾ít signály
    \texttt{SIGUSR1} a \texttt{SIGUSR2}
    \item \emsl{POSIXová sdíl{}ená pamì»} pøístupná pomocí \texttt{shm\_open()}
    a \texttt{mmap()}
    \item \emsl{POSIXové semafory} \dots{} \texttt{sem\_open()},
    \texttt{sem\_post()}, \texttt{sem\_wait()}, \dots
    \item \emsl{POSIXové fronty zpráv} \dots{} \texttt{mq\_open()},
    \texttt{mq\_send()}, \texttt{mq\_receive()}, \dots{} 
    \end{itemize}
\item Z BSD pochází \emsl{sokety (sockets)} umo¾òující komunikaci v~doménách
\texttt{AF\_UNIX} (komunikace v rámci jednoho poèítaèe) a \texttt{AF\_INET}
(komunikace na jednom poèítaèi nebo po síti).
\end{itemize}
\end{slide}

\begin{itemize}
\item POSIXové IPC pou¾ívá pro pojmenování jednotlivých IPC objektù
øetìzce místo numerických identifikátorù, proto do znaèné míry
odpadají problémy s identifikací známé ze System V IPC (kde se øe¹í
napø. funkcí \texttt{ftok()}).
\item POSIXová rozhraní zde uvedená jsou souèástí roz¹íøení 1003.1b (aka
POSIX.4), viz strana \pageref{POSIX4}.
\item sokety se z BSD roz¹íøily i do ostatních UNIXových systémù a
dostaly se i do normy SUSv2.
\item existují dal¹í API specifické pro konkrétní systém, napø. Solaris doors.
\end{itemize}

\label{SYNCHRONIZATIONEND}

\endinput
