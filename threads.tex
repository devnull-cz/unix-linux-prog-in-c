changequote([[[, ]]])

\pagebreak
\pdfbookmark[0]{threads and their synchronization}{vlakna}

\begin{slide}
\sltitle{Contents}
\slidecontents{8}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}
\sltitle{Threads}
\begin{itemize}
\item \emph{thread} = \emph{thread of execution}, a basic software ``thing''
that can do work on a computer
\item classic Unix model: single threaded processes
\item with introduction of threads, a process becomes just a container for
threads
\item advantages of multithreaded applications
  \begin{itemize}
  \item speed-up -- a typical objective is having threads on multiple CPUs
  running in parallel
  \item more modular programming
  \end{itemize}
\item disadvantages
  \begin{itemize}
  \item more complex code
  \item debugging may become more difficult
  \end{itemize}
\end{itemize}
\end{slide}

\begin{itemize}
\item \emsl{While one has to put resources into sharing data when working with
processes, one has to put resources into managing
inherent data sharing if working with threads.}  Note that all threads of the
same process have equal access to the process virtual address space.
\item Not all applications are fit for multithreading as some tasks are not
inherently parallel in nature.
\item Even that debuggers typically support threads, debugging changes timing so
the problem may not reproduce when using the debugger.  That is usually not an
issue in a single threaded application.
\item There is an excellent book on programming with POSIX threads by Butenhof,
see page \pageref{REF_PROGRAMMING}. You can also use an online book
\emph{Multithreaded Programming Guide} available on
\url{http://docs.oracle.com}.
\item \label{PRIVILEGE_SEPARATION} An example situation when you do not want to
use threads is if you want to change a real and effective UID of processes.  Take
OpenSSH -- every connection is served by two processes.  One, with maximum
privileges, usually runs as root, and provides services (allocating a pseudo
terminal is one of them) to a second, unprivileged process.  The idea is that
most of the OpenSSH code does not need any special privilege so if a bug is
found in code that is run under an unprivileged user, the damage is much smaller
than if such code was run with maximum privileges.  This technique is called a
\emph{privilege separation} and you could not do the same thing with threads.
\end{itemize}

\begin{slide}
\sltitle{Implementation of threads}
\setlength{\baselineskip}{0.8\baselineskip}
\begin{description}
\item[library-thread model]~\\\vspace{-2.5ex}
    \begin{itemize}
    \item threads are implemented in a library.  Kernel has no knowledge of
    such threads.
    \item run-time library schedules threads on processes and kernel schedules
    processes on CPUs
    \item[$\oplus$] less overhead
    \item[$\ominus$] more threads of the same process cannot run in parallel
    \end{itemize}
\item [kernel-thread model]~\\\vspace{-2.5ex}
    \begin{itemize}
    \item threads are a first class kernel citizen
    \item[$\oplus$] more threads of the same process can run in parallel on
    multiple CPUs
    \end{itemize}
\item[hybrid models]~\\\vspace{-2.5ex}
    \begin{itemize}
    \item N library threads scheduled on M kernel threads, N $>=$ M
    \item[$\ominus$] too complex to implement, not really used today
    \end{itemize}
\end{description}
\end{slide}

\begin{itemize}
\item Original Unix systems used library models.  Today in general the kernel
model is used.
\item Threads implemented in a library may be either preemptive or
non-pre\-emp\-tive.  To achieve preemptiveness, you can use timers and signals.
However, if the objective is more in better modular programming than real
parallelism, usually non-preemptive threads do fine.  Switching threads will be
done when a process would normally block in system calls.
\item \label{SETJMP} If a system call blocks in a library implemented thread,
the whole process will block as the kernel has no knowledge there are more
threads in the process.  So the threading library is written the way that
non-blocking calls are used, the thread context is saved after that and the
library switches to another thread via \funnm{setjmp}() and \funnm{longjmp}()
system calls.  Example: \example{pthreads/setjmp.c}.
\end{itemize}

\begin{slide}
\sltitle{POSIX threads (pthreads)}

\begin{itemize}
\item first came with IEEE Std 1003.1c-1995
\item POSIX thread API uses a prefix \texttt{pthread\_}
\item these functions return 0 (= OK) or an error number (values as for
\texttt{errno})
\begin{itemize}
\item \dots{} functions do \emsl{not} set \texttt{errno}
\item so you cannot use functions \funnm{perror}() or \funnm{err}()
\end{itemize}
\item the standard also defines other functions, for example those that could
not be possible to adjust for the use with threads without changing its API (eg.
\texttt{readdir\_r}, \texttt{strtok\_r}, etc.)
\begin{itemize}
\item \texttt{\_r} means \emph{reentrant}, ie. the function can be called by
multiple threads without any side effects
\end{itemize}
\end{itemize}

\end{slide}

\label{POSIXTHREADS}

\begin{itemize}
\item General information on POSIX is on page \pageref{POSIX}.
\item There are more threading API, the POSIX thread API is just one of them.
For example, there is a system call \texttt{sproc()} on IRIX, then Cthreads,
Solaris threads, GNU Ptr threads (= portable), \dots
\item The POSIX thread API is available in different libraries on different
systems.  For example, on Linux you usually need \texttt{-lpthread} but on
Solaris the API is part of standard \texttt{libc}.  With \texttt{gcc}, instead
of \texttt{-lpthread}, you can use \texttt{-pthread} and the compiler will do
what is needed for the specific system (which does not have to be Linux).
\item Each POSIX thread API implementation is usually built on top of the native
threading library.  For example, on Solaris, it's the \texttt{thr\_} API
functions.
\item We will talk more on reentrant functions in connection with threads on
page \pageref{THREADSAFE}.
\item As already mentioned, given that the POSIX thread API uses \texttt{errno}
codes directly as return values, the following piece of code is not correct:

\begin{verbatim}
if (pthread_create(&thr, NULL, thrfn, NULL) != 0)
        err(1, "pthread_create");
\end{verbatim}

as it will print possibly something like the following on error (unless
\texttt{errno} was set by previous code which would make it even more
confusing):

\begin{itemize}
\item ``\texttt{a.out: pthread\_create: Success}'' on Linux distros
\item ``\texttt{a.out: pthread\_create: Error 0}'' on Solaris
\item ``\texttt{a.out: pthread\_create: Unknown error: 0}'' on FreeBSD
\item or something else based on the system and the concrete message it uses for
\texttt{errno} equal to 0, unless \texttt{errno} is already set otherwise.
\end{itemize}

The Linux approach does not seem to be the best as leaving \texttt{errno} zero
does not have to mean the function did not fail, as we just showed.  FreeBSD
makes it obvious that something is not entirely right.  The correct code could
look like this:

\begin{verbatim}
int e;

if ((e = pthread_create(&thr, NULL, thrfn, NULL)) != 0)
        errx(1, "pthread_create: %s", strerror(e));
\end{verbatim}

\item \label{ERRNO_IN_THREADS} Other functions that use \texttt{errno} work the
same with POSIX threads as each thread has its own \texttt{errno}.  In that
case, it's redefined as a function.  Check \texttt{/usr/include/bits/errno.h} on
Linux if interested.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Example: thread creation}
{\catcode95=12\catcode38=12
\begin{center}
\input{img/tex/threads.pstex_t}
\end{center}}
\end{slide}

\begin{itemize}
\item This is a trivial example.  The process (main thread) creates two more
threads and waits for them to finish.  This process thus have 3 threads in
total.
\end{itemize}

%%%%%

\pdfbookmark[1]{pthread\_create}{thrcreate}

\begin{slide}
\label{PTHREAD_T}
\sltitle{Vytvoøení vlákna}
\funml{int \funnm{pthread\_create}(\=pthread\_t *\emph{thread},
\\\>const pthread\_attr\_t *\emph{attr},
\\\>void *(*\emph{start\_fun})(void*), void *\emph{arg});}
\begin{itemize}
\item vytvoøí nové vlákno, do \texttt{thread} ulo¾í jeho ID.
\item podle \texttt{attr} nastaví jeho atributy, napø. velikost zá\-sob\-ní\-ku
èi plánovací politiku. \texttt{NULL} znamená pou¾ít implicitní atributy.
\item ve vytvoøeném vláknu spustí funkci \texttt{start\_fun}() s
argumentem \texttt{arg}. Po návratu z této funkce se zru¹í vlákno. 
\item s objekty \texttt{pthread\_attr\_t} lze manipulovat funkcemi
\texttt{pthread\_attr\_init()}, \texttt{pthread\_attr\_destroy()},
\texttt{pthread\_attr\_setstackaddr()}, atd\dots{}
\end{itemize}
\end{slide}

\begin{itemize}
\item Pozor na konstrukce typu:
\begin{alltt}
for (i = 0; i < N; i++)
    pthread\_create(&tid, attr, start\_routine, &i);
\end{alltt}

Na první pohled takto pøedáme ka¾dému vláknu jeho in{}dex. Jen¾e plánovaè mù¾e
zpùsobit to, ¾e ne¾ si novì spu¹tìné vlákno staèí pøeèíst hodnotu \texttt{i},
pøíkaz \texttt{for} provede dal¹í iteraci a hodnota se zmìní. Obecnì vlákno mù¾e
dostat místo správné hodnoty \texttt{i} libovolnou vìt¹í.
\item \label{WRONG_USE_OF_ARG} Pøíklady:
\example{pthreads/wrong-use-of-arg.c}, \example{pthreads/correct-use-of-arg.c}.

\item Co je mo¾né pou¾ít, pokud potøebujeme pøedat pouze jednu hodnotu
(\textbf{podle C standardu je to ale implementaènì závislé a tedy
ne\-pøe\-no\-si\-tel\-né}):

\begin{alltt}
assert(sizeof (void *) >= sizeof (int));
for (i = 0; i < N; i++)
    pthread\_create(&tid, attr, start\_routine, (void *)(intptr\_t)i);
\end{alltt}

\dots a ve funkci \texttt{void *start\_routine(void *arg)} pak
pøetypovat ukazatel zpátky na integer a máme potøebný identifikátor
vlákna:

\begin{alltt}
printf("thread \%d started\bs{}n", (int)arg);
\end{alltt}

\label{INT_AS_ARG} Pøíklad: \example{pthreads/int-as-arg.c}
\item Pokud potøebujeme pøedat více bajtù ne¾ je velikost ukazatele, tak u¾
opravdu musíme pøedat ukazatel na pamì» s pøíslu¹nými pøedávanými daty nebo
pou¾ít globální promìnné; pøístup k nim je pak ale samozøejmì nutné
synchronizovat.

\item \label{PTHREAD_CREATE_CYCLE} \texttt{pthread\_t} je "prùhledný" typ,
do kterého program nevidí
a ani by nemìl, jeho implementace se mù¾e li¹it systém od systému; nicménì
vìt¹inou jde o celoèíselný typ, který se pou¾ívá k mapování na nativní thready
na daném systému. Pøi vytváøení nìkolika threadù v cyklu je tedy nutné pøedat
funkci \texttt{pthread\_create} poka¾dé adresu jiné promìnné
\texttt{pthread\_t}, jinak u¾ nepùjde s tìmito vlákny nadále manipulovat
z hlavního vlákna, napø. èekat na jejich dokonèení (aèkoliv bì¾et budou
normálnì), jejich identifikace se ztratí. Toto je øe¹itelné napø. pøes
pole \texttt{pthread\_t} nebo dynamickou alokací.
\end{itemize}


%%%%%

\pdfbookmark[1]{pthread\_self, pthread\_key\_create}{pthreadkey}
\label{THREAD_ATTRS}

\begin{slide}
\sltitle{Soukromé atributy vláken}
\begin{itemize}
\item èítaè instrukcí 
\item zásobník (automatické promìnné) 
\item thread ID, dostupné funkcí\\
\texttt{pthread\_t \funnm{pthread\_self}(void);}
\item plánovací priorita a politika 
\item hodnota \texttt{errno}
\item klíèované hodnoty -- dvojice
\texttt{(pthread\_key\_t \emph{key}, void *\emph{ptr})} 
    \begin{itemize}
    \item klíè vytvoøený voláním \texttt{pthread\_key\_create()} je
    viditelný ve v¹ech vláknech procesu. 
    \item v ka¾dém vláknu mù¾e být s klíèem asociována jiná hodnota
    voláním \texttt{pthread\_setspecific()}.
    \end{itemize}
\end{itemize}
\end{slide}

\begin{itemize}
\item Ka¾dé vlákno má zásobník pevné velikosti, \emsl{který se automaticky
ne\-zvìt\-¹u\-je.} Bývá to kolem 64-512 KB, tak¾e pokud si ve funkci alokujete
pole o velikosti 256KB a pou¾ijete ho, je dost mo¾né, ¾e skonèíte s core
dumpem. Pokud chcete zásobník vìt¹í ne¾ je systémový default, musíte pou¾ít
argument \emph{attr} pøi vytvoøení vlákna.
Pøíklad: \example{pthreads/pthread-stack-overflow.c}
\item O soukromých klíèovaných atributech vlákna více na stranì
\pageref{THREAD_SPECIFIC_DATA}.
\item Ka¾dé vlákno má je¹tì vlastní signálovou masku, k tomu se také dostaneme,
viz strana \pageref{PTHREADSIGMASK}.
\end{itemize}

%%%%%

\pdfbookmark[1]{pthread\_exit, pthread\_join, pthread\_detach}{pthreadexit}

\begin{slide}
\sltitle{Ukonèení vlákna}
\texttt{void \funnm{pthread\_exit}(void *\emph{val\_ptr});}
\begin{itemize}
\item ukonèí volající vlákno, je to obdoba \texttt{exit} pro proces
\end{itemize}
\texttt{int \funnm{pthread\_join}(pthread\_t \emph{thr},
void **\emph{val\_ptr});}
\begin{itemize}
\item poèká na ukonèení vlákna \texttt{thr} a ve
\texttt{val\_ptr} vrátí hodnotu ukazatele z \texttt{pthread\_exit} nebo
návratovou hodnotu vláknové funkce. Pokud vlákno skonèilo døíve, funkce hned vrací
pøíslu¹nì nastavené \texttt{val\_ptr}.
\item obdoba èekání na synovský proces pomocí \texttt{wait}
\end{itemize}
\texttt{int \funnm{pthread\_detach}(pthread\_t \emph{thr});}
\begin{itemize}
\item nastaví okam¾ité uvolnìní pamìti po ukonèení vlákna, na vlákno
nelze pou¾ít \texttt{pthread\_join}.
\end{itemize}
\end{slide}

\begin{itemize}
\item Pokud se nepou¾ije \texttt{pthread\_exit}, vyvolá se tato funkce pøi
skonèení vlákna implicitnì, s hodnotou pou¾itou pro \texttt{return}
\item Norma specifikuje, ¾e stav zásobníku ukonèovaného vlákna není definovaný,
a proto by se v \texttt{pthread\_exit} nemìly pou¾ívat odkazy na lokální
promìnné ukonèovaného vlákna pro parametr \texttt{\emph{val\_ptr}}
\item Pokud nemáme v úmyslu po skonèení vlákna volat \texttt{pthread\_join}, je
tøeba zavolat \texttt{pthread\_detach}. Jinak po ukonèeném vláknu zùstanou v
pamìti data nutná pro zji¹tìní jeho výsledku pomocí \texttt{pthread\_join}. To
je podobná situace, jako kdy¾ rodièovský proces nepou¾ívá \texttt{wait} a v
systému se hromadí zombie. Ve funkci pro takové vlákno je mo¾né jednodu¹e pou¾ít
toto:
\begin{alltt}
pthread\_detach(pthread\_self());
\end{alltt}
\item Jiná mo¾nost jak nastavit, ¾e se na vlákna nemusí èekat, je zavolat funkci
\texttt{p\-thr\-ead\_attr\_setdetachstate} s hodnotou
\texttt{PTHREAD\_CREATE\_DETACHED} nad strukturou atributù a tu pak pou¾ít ve
voláních \texttt{pthread\_create}. Pøíklad: \example{pthreads/set-detachstate.c}
\item Nastavením \texttt{NULL} do argumentu \emph{\texttt{val\_ptr}} systému
sdìlujeme, ¾e nás ná\-vra\-to\-vá hodnota ukonèeného vlákna nezajímá.
\item Èekat na ukonèení vlákna mù¾e libovolné jiné vlákno, nejen to,
které ho spustilo.
\item Doporuèuji v¾dy kontrolovat návratovou hodnotu \texttt{pthread\_join}, tím
si budete jisti, ¾e èekáte správnì, pøi pou¾ití ¹patného ID vlákna funkce hned
vrá\-tí, co¾ vá¹ program nutnì nemusí negativnì ovlivnit co se týká funkènosti,
ale mù¾ete pak narazit na limit poètu vláken nebo vyplýtvat pamì».
\item Na rozdíl od procesù \emsl{nelze èekat na ukonèení kteréhokoli vlákna}. Je
to z toho dùvodu, ¾e vlákna nemají vztah rodiè--potomek, a proto to nebylo
pova¾ováno za potøebné. Pro zajímavost, Solaris vlákna toto umo¾ní (jako ID
vlákna ve funkci \texttt{thr\_join} se pou¾ije 0). Pokud byste tuto funkènost
potøebovali s POSIXovými vlákny, je jednoduché nastavit vlákna jako
\emph{detached}, pou¾ít podmínkové promìnné, a pøedávat potøebné informace pøes
globální promìnnou pod ochranou zámku, který je s podmínkovou promìnnou svázán.
Více viz strana \pageref{CONDITION_VARIABLES}.
\item \label{PTHREAD_JOIN} Pøíklady: \example{pthreads/pthread-join.c},
\example{pthreads/pthread-detach-join.c}
\end{itemize}


%%%%%

\pdfbookmark[1]{pthread\_once}{pthreadonce}

\begin{slide}
\sltitle{Inicializace}
\funml{int \funnm{pthread\_once}(\=pthread\_once\_t *\emph{once\_control},
\\\>void (*\emph{init\_routine})(void));}
\begin{itemize}
\item V parametru \texttt{once\_control} se pøedává ukazatel na
staticky inicializovanou promìnnou\\ \texttt{pthread\_once\_t
\emph{once\_control} = PTHREAD\_ONCE\_INIT;}
\item První vlákno, které zavolá \texttt{pthread\_once()}, provede
inicializaèní funkci \texttt{init\_routine()}. Ostatní vlákna u¾
tuto funkci neprovádìjí, navíc, pokud inicializaèní funkce je¹tì
neskonèila, zablokují se a èekají na její dokonèení. 
\item Lze pou¾ít napø. na dynamickou inicializaci globálních dat
v~knihovnách, jejich¾ kód mù¾e zavolat více vláken souèasnì, ale je
tøeba zajistit, ¾e inicializace probìhne jen jednou. 
\end{itemize}
\end{slide}

\begin{itemize}
\item V programu samotném tuto funkci asi potøebovat nebudete. Místo pou¾ití
\texttt{pthread\_once} staèí danou inicializaèní funkci zavolat pøed tím, ne¾
vytvoøíte vlákna...
\item Není definováno, co se má stát, pokud je \texttt{once\_control}
automatická pro\-mìn\-ná nebo nemá po¾adovanou hodnotu.
\end{itemize}

%%%%%

\pdfbookmark[1]{pthread\_cancel, pthread\_setcancelstate, pthread\_setcanceltype}{pthreadcancel}

\begin{slide}
\sltitle{Zru¹ení vlákna}
\setlength{\baselineskip}{0.9\baselineskip}
\texttt{int \funnm{pthread\_cancel}(pthread\_t \emph{thread});}
\begin{itemize}
\item po¾ádá o zru¹ení vlákna \texttt{thread}. Závisí na nastavení 
\end{itemize}
\texttt{int \funnm{pthread\_setcancelstate}(int \emph{state},
int *\emph{old});}
\begin{itemize}
\item nastaví nový stav a vrátí starý:
    \begin{itemize}
    \item \texttt{PTHREAD\_CANCEL\_ENABLE} \dots{} povoleno zru¹it 
    \item \texttt{PTHREAD\_CANCEL\_DISABLE} \dots{} nelze zru¹it, ¾ádost bude
    èekat na povolení 
    \end{itemize}
\end{itemize}
\texttt{int \funnm{pthread\_setcanceltype}(int \emph{type}, int *\emph{old});}
\begin{itemize}
\item \texttt{PTHREAD\_CANCEL\_ASYNCHRONOUS} \dots{} okam¾ité zru¹ení 
\item \texttt{PTHREAD\_CANCEL\_DEFERRED} \dots{} ¾ádost èeká na vstup do
urèitých funkcí (napø. \texttt{open()}, \texttt{read()}, \texttt{wait()}),
nebo na volání
\end{itemize}
\texttt{void \funnm{pthread\_testcancel}(void);}
\end{slide}

\begin{itemize}
\item Vlákna je mo¾né zvenku \uv{násilnì} ru¹it (obdoba ukonèení procesu pomocí
signálu) buï okam¾itì, nebo jen v urèitých voláních (tzv. \emph{cancellation
points}). To znamená, ¾e v takovém pøípadì je mo¾né vlákno zru¹it v èase, kdy je
vlákno vykonává danou funkci. Pokud vlákno zrovna takovou funkci nevykonává,
informace o zru¹ení se ``doruèí'' bìhem vykonání první takové funkce od té doby.
\item Funkce \verb#pthread_cancel# se podobá zru¹ení procesu signálem poslaným
vo\-lá\-ním \texttt{kill}.
\item Pøi zru¹ení vlákna se zavolají úklidové handlery, viz strana
\pageref{PTHREAD_CLEANUP}. Pokud se rozhodnete ru¹ení vláken pou¾ívat,
\emsl{buïte velmi opatrní}. Napøíklad, pokud budete ru¹it vlákno, které má
zamknutý mutex, musíte mutex odemknout v úklidových handlerech.
\item Funkce \verb#pthread_setcancelstate# a \verb#pthread_setcanceltype# jsou
obdobou zakázání a povolení zru¹ení procesu signálem pomocí manipulace s maskou
blokovaných signálù (\texttt{sigprocmask}).
\item \label{PTHREAD_CANCEL} Pøíklad: \example{pthreads/pthread-cancel.c}
\item Pøi ru¹ení vlákna mù¾e nastat mnoho mo¾ností. Solaris má tøeba samostatnou
manuálnovou stránku \texttt{cancellation(5)}, která se tomu vìnuje. FreeBSD
definuje \emph{cancellation points} v manuálové stránce
\texttt{pthread\_setcanceltype(3)}.
\end{itemize}

%%%%%

\pdfbookmark[1]{pthread\_key\_create, pthread\_key\_delete,
pthread\_setspecific, pthread\_getspecific}{pthreadglobals}

\begin{slide}
\sltitle{Globální promìnné pro vlákno}
\funml{int \funnm{pthread\_key\_create}(\=pthread\_key\_t *\emph{key},
\\\>void (*\emph{destructor})(void *));}
\begin{itemize}
\item vytvoøí klíè, který lze asociovat s hodnotou typu
\texttt{(void *)}.  Funkce \texttt{destructor()} se volají opakovanì
pro v¹echny klíèe, jejich¾ hodnota není \texttt{NULL}, pøi ukonèení
vlákna. 
\end{itemize}
\texttt{int \funnm{pthread\_key\_delete}(pthread\_key\_t \emph{key});}
\begin{itemize}
\item zru¹í klíè, nemìní asociovaná data. 
\end{itemize}
\funml{int \funnm{pthread\_setspecific}(\=pthread\_key\_t \emph{key},
\\\>const void *\emph{value});}
\begin{itemize}
\item pøiøadí ukazatel \texttt{value} ke klíèi \texttt{key}.
\end{itemize}
\texttt{void *\funnm{pthread\_getspecific}(pthread\_key\_t \emph{key});}
\begin{itemize}
\item vrátí hodnotu ukazatele pøíslu¹ného ke klíèi \texttt{key}.
\end{itemize}
\end{slide}

\begin{itemize}
\item \label{THREAD_SPECIFIC_DATA} Bì¾né globální promìnné (a také dynamicky
alokovaná data) jsou spoleèné pro v¹echna vlákna. Klíèované hodnoty pøedstavují
zpùsob, jak vytvoøit glo\-bál\-ní promìnné v rámci vláken. Uvìdomte si rozdíl
proti lokální promìnné definované ve vláknové funkci - taková promìnná není
vidìt v dal¹ích volaných funkcích ve stejném vláknì. Vyu¾itelnost soukromých
atributù vláken se mù¾e zdát malá, ale obèas se to velmi dobøe hodí. Já to
jednou pou¾il v existujícím kódu, kde jsem potøeboval nahradit práci s globálním
spojovým seznamem na lokální seznamy specifické pro ka¾dé vlákno. Nejjednodu¹¹í,
tj. nejménì zmìn v existujícím kódu bylo pøevést práci s globální promìnnou na
práci se soukromým atributem vlákna.
\item Pøi vytvoøení klíèe je s ním asociována hodnota \texttt{NULL}. Ukazatel na
destruktor funkci není povinný, pokud není potøeba, pou¾ijte \texttt{NULL}.
\item Pøi ukonèení nebo zru¹ení vlákna se volají destruktory (v nespecifikovaném
poøadí) pro v¹echny klíèe s hodnotou rùznou od \texttt{NULL}.  Aktuální hodnota
je destruktoru pøedána v parametru. Jestli¾e po skonèení v¹ech destruktorù
zbývají klíèe s hodnotou rùznou od \texttt{NULL}, znovu se volají destruktory.
Implementace mù¾e (ale nemusí) zastavit volání destruktorù po
\texttt{PTHREAD\_DESTRUC\-TOR\_ITERATIONS} iteracích. Destruktor by tedy mìl
nastavit hodnotu na \texttt{NULL}, jinak hrozí nekoneèný cyklus.
\item Destruktor si musí sám zjistit klíè polo¾ky, ke které patøí, a zru¹it
hodnotu voláním \texttt{pthread\_setspecific(key,~NULL)}.
\item SUSv3 tento nesmyslný po¾adavek odstraòuje, proto¾e definuje, ¾e pøed
vstupem do destruktoru je hodnota automaticky nastavená na \texttt{NULL};
destruktor se následnì vyvolá s pøedchozí hodnotou klíèe.
\end{itemize}

%%%%%

\pdfbookmark[1]{pthread\_cleanup\_push, pthread\_cleanup\_pop}{pthreadcleanup}

\begin{slide}
\sltitle{Úklid pøi ukonèení/zru¹ení vlákna}
\begin{itemize}
\item vlákno má zásobník úklidových handlerù, které se volají pøi
ukonèení nebo zru¹ení vlákna funkcemi \texttt{pthread\_exit} a
\texttt{pthread\_cancel} (ale ne pøi \texttt{return}). Handlery se spou¹tí
v opaèném poøadí ne¾ byly vkládány do zásobníku.
\item po provedení handlerù se volají destruktory privátních klíèovaných dat
vlákna (poøadí není specifikované)
\end{itemize}
\funml{void \funnm{pthread\_cleanup\_push}(\=void (*\emph{routine})(void *),
\\\>void *\emph{arg});}
\begin{itemize}
\item vlo¾í handler do zásobníku. 
\end{itemize}
\texttt{void \funnm{pthread\_cleanup\_pop}(int \emph{execute});}
\begin{itemize}
\item vyjme naposledy vlo¾ený handler ze zásobníku. Provede ho,
pokud je \texttt{execute} nenulové.
\end{itemize}
\end{slide}

\label{PTHREAD_CLEANUP}

\begin{itemize}
\item Handlery se volají jako \texttt{routine(arg)}.
\item Tyto handlery se dají pou¾ívat napø. na úklid lokálních dat funkcí (obdoba
volání destruktorù pro automatické promìnné v C++).
\end{itemize}

%%%%%

\begin{slide}
\sltitle{\texttt{fork()} a vlákna (POSIX)}
\prgchars
\begin{itemize}
\item je nutné definovat sémantiku volání \texttt{fork} v aplikacích
pou¾ívajících vlákna. Norma definuje, ¾e:

\begin{itemize}
\item nový proces obsahuje pøesnou kopii volajícího vlákna,
vèetnì pøípadných stavù mutexù a jiných zdrojù
\item ostatní vlákna v synovském procesu neexistují
\item pokud taková vlákna mìla naalokovanou pamì», zùstane tato
pamì» naalokovaná (= ztracená)
\item obdobnì to platí pro zamèený mutex ji¾ neexistujícího vlákna
\end{itemize}
\item vytvoøení nového procesu z multivláknové aplikace má smysl pro
následné volání \texttt{exec} (tj. vèetnì volání \texttt{popen},
\texttt{system} apod.)
\end{itemize}
\end{slide}

\begin{itemize}
\item Pokud mìlo ji¾ neexistující vlákno zamèený mutex, tak je pøístup k
pøí\-slu¹\-ným sdíl{}eným datùm ztracen, proto¾e zamèený mutex mù¾e odemknout
pouze to vlákno, které ho zamknulo. Zde ale trochu pøedbíhám, mutexy jsou
pøedstavené a¾ na stranì \pageref{MUTEXES}.
\item Ostatní vlákna v novém procesu pøestanou existovat, nevolají se ¾ádné
rutiny jako pøi volání \texttt{pthread\_exit}, \texttt{pthread\_cancel} nebo
destruktory klíèovaných dat.
\item \label{FORKALL} Pozor na to, ¾e chování \texttt{fork} také závisí na
pou¾ité knihovnì a verzi systému, napøíklad na Solarisu pøed verzí 10 znamenalo
\texttt{fork} v knihovnì \texttt{libthread} (jiná knihovna ne¾
\texttt{libpthread}) to samé co \texttt{forkall}.
\item Pøíklady: \example{pthreads/fork.c},
\example{pthreads/fork-not-in-main.c},
\example{pthreads/forkall.c}
\item \label{ATFORK} Pomocí funkce \texttt{pthread\_atfork} je mo¾né nastavit
handlery které se automaticky vykonají pøed pou¾itím \texttt{fork} v rodièi
a po návratu z \texttt{fork} v rodièi a synovském procesu.  Toto volání se
velmi hodí pro v¹echny multithreadové programy které volají \texttt{fork}
a nepou¾ívají ho pouze jako jednoduchý wrapper pro \texttt{exec}.
Po \texttt{fork} se toti¾ v synovském procesu nacházejí v¹echny promìnné
ve stejném stavu jako byly v rodièi ve chvíli kdy se zavolal \texttt{fork}
a tedy pokud mìlo nìjaké jiné vlákno (ne¾ které zavolalo \texttt{fork})
napø. zamèený mutex (zamykání pomocí mutexù viz strana \pageref{MUTEXES})
tak bude tento mutex zamèený i v synovském procesu. Pokud se pak vlákno ze
synovského procesu tento mutex pokusí zamknout, dojde k deadlocku. Pokud
se v \emph{pre-fork} handleru provede zamèení v¹ech mutexù a v obou (rodiè
i syn) \emph{post-fork} handlerù odemèení v¹ech mutexù, tato situace
nenastane. Tento mechanismus funguje díky tomu, ¾e \emph{pre-fork} handler
se zavolá ve vláknu, které zavolalo fork, je¹tì pøedtím ne¾ se provede samotný
fork syscall; ostatní vlákna mezitím dál bì¾í a mohou tedy uvolnit mutexy
(jednodu¹e tak ¾e ka¾dé vlákno v rozumnì napsaném programu èasem opustí
kritickou sekci),
na které se èeká v handleru. Toto samozøejmì pøedpokládá, ¾e zamykání a
odemykání v handlerech dodr¾uje zamykací pravidla ("protokol") stanovený
pro celý program a nedojde tedy k deadlocku.
\example{pthreads/atfork.c}
Více napø. v [Butenhof].
\end{itemize}


%%%%%

\pdfbookmark[1]{pthread\_sigmask}{pthreadsigmask}

\begin{slide}
\sltitle{Signály a vlákna}
\prgchars
\begin{itemize}
\item signály mohou být generovány pro proces (voláním
\texttt{kill}), nebo pro vlákno (chybové události, volání
\texttt{pthread\_kill}). 
\item nastavení obsluhy signálù je stejné pro v¹echna vlákna
procesu, ale masku blokovaných signálù má ka¾dé vlákno vlastní,
nastavuje se funkcí 
\end{itemize}
\funml{int \funnm{pthread\_sigmask}(\=int \emph{how},
const sigset\_t *\emph{set},\\\> sigset\_t *\emph{oset});}
\begin{itemize}
\item signál urèený pro proces o¹etøí v¾dy právì jedno vlákno, které
nemá tento signál zablokovaný. 
\item lze vyhradit jedno vlákno pro synchronní pøíjem signálù pomocí volání
\texttt{sigwait}. Ve v¹ech vláknech se signály zablokují.
\end{itemize}
\end{slide}

\label{PTHREADSIGMASK}

\begin{itemize}
\item Jestli¾e je pro signál nastaveno ukonèení procesu, skonèí celý proces,
nejen jedno vlákno.
\item Vytvoøené vlákno dìdí nastavení signálové masky od vlákna, které ho
vytvoøilo
\item Analogicky k pou¾ití \texttt{sigwait} s procesy (stra\-na
\pageref{SIGWAIT}) -- zablokujte pøíslu¹né signály ve v¹ech vlák\-nech, vèetnì
vlákna, ve kterém chcete zpracovávávat signály pomocí \texttt{sigwait}.
\emsl{Tento zpùsob zpracování signálù bývá èasto jediný opravdu doporuèovaný pro
vlákna}, a navíc je i nejsnáze implementovatelný. Jak vyplývá z pøedchozí
poznámky, staèí zamaskovat signály pouze jednou, a to v hlavním vláknì, proto¾e
maska se pak podìdí pøi ka¾dém volání \texttt{pthread\_create}.
\item V prostøedí vláken nepou¾ívejte \texttt{sigprocmask} (strana
\pageref{SIGPROCMASK}), proto¾e chování tohoto volání není v takovém prostøedí
normou specifikováno. Mù¾e to fungovat, a také nemusí.
\item \label{THREADS_SIGWAIT} Pøíklad: \example{pthreads/sigwait.c}.
\item \emsl{Pozor} na to, ¾e byste nemìli tento zpùsob obsluhy signálù pou¾ívat
pro sig\-nály synchronní jako jsou \texttt{SIGSEGV}, \texttt{SIGILL}, apod. Tyto
signály jsou ge\-ne\-ro\-va\-né pøímo pro vlákno, tak¾e pokud je zablokujete,
vlákno urèené pro synchronní pøíjem signálù je nemusí ``vidìt'', jedinì pokud by
ten signál zpù\-so\-bi\-lo samo, samozøejmì. Dal¹í vìc ale je, ¾e specifikací
není definováno, zda blokování takových signálù tyto signály skuteènì zablokuje,
jak ji¾ bylo zmínìno na stranì \pageref{SPECIALSIGNALS}. Nìkteré sys\-té\-my
tyto signály normálnì doruèí, èím¾ proces ukonèí, viz pøesné znìní:

\begin{quote}
\emph{If any of the SIGFPE, SIGILL, SIGSEGV, or SIGBUS signals are generated
while they are blocked, the result is undefined, unless the signal was generated
by the kill() function, the sigqueue() function, or the raise() function.}
\end{quote}

Pøíklad: \example{pthreads/sigwait-with-sync-signals.c}. Tento pøíklad ukazuje,
¾e na Solarisu 10, Solarisu 11, FreeBSD 7.2 a Linux distribuci, která se hlásí
jako ``Gentoo Base System release 1.12.13'', je signál \texttt{SIGSEGV} doruèen
a proces zabit bez ohledu na to, zda je maskován. Na¹el jsem ale i systém, který
po zamaskování signál nedoruèí -- FreeBSD 6.0. Synchronní signály by ale mìlo
být v¾dy mo¾né zachytit (pøed zavoláním \texttt{exit}), viz strana
\pageref{SPECIALSIGNALS}, kde je i pøíklad.

\end{itemize}


%%%%%

\begin{slide}
\sltitle{Thread synchronization in general}

\begin{itemize}
\item most of the programs employing threads needs to share data between them
\item or needs to execute given actions in certain order
\item \dots{}all of this needs to \emsl{synchronize} running threads activity
\item for processes it is necessary to make some effort to actually share data,
for threads on the other hand it is necessary to maintain natural data sharing.
\item will describe:
\begin{itemize}
\item mutexes
\item conditional variables
\item read-write locks
\end{itemize}
\end{itemize}
\end{slide}

\label{THREADSYNCHRONIZATION}

\begin{itemize}
\item Process synchronization is described on pages
\pageref{SYNCHRONIZATION} to \pageref{SYNCHRONIZATIONEND}.
\item Using mutexes and conditional variables it is possible to construct any
other synchronization model.
\item The exact behavior of synchronization primitives is largely determined by
the scheduler, that decides which of the threads waiting for unlock will be
waked up after the unlock happens. This leads to classical problems such as
\emph{thundering horde} (lots of threads waiting for unlock)
or \emph{priority inversion} (thread holding a lock has lower priority than
the thread waiting for the lock).
\end{itemize}

%%%%%
%%%%%

\pdfbookmark[1]{pthread\_mutex\_init, pthread\_mutex\_destroy}{pthreadinit}

\begin{slide}
\sltitle{Thread synchronization: mutexes (1)}

\begin{itemize}
\item the simplest way how to ensure synchronized access to shared data between
threads
\item inicialization of statically defined mutex:
\end{itemize}

\texttt{pthread\_mutex\_t mutex = PTHREAD\_MUTEX\_INITIALIZER;}

\begin{itemize}
\item inicialization of dynamically allocated mutex \texttt{mx} with attributes
\texttt{attr} (these are set using \texttt{pthread\_mutexattr\_...};
if \texttt{attr} is \texttt{NULL}, defaultní attributes will be used)
\end{itemize}

\funml{int \funnm{pthread\_mutex\_init}(\=pthread\_mutex\_t *\emph{mx},
\\\>const pthread\_mutexattr\_t *\emph{attr});}

\begin{itemize}
\item after done using the mutex it is possible to destroy it:
\end{itemize}

\texttt{int \funnm{pthread\_mutex\_destroy}(pthread\_mutex\_t *\emph{mx});}
\end{slide}

\label{MUTEXES}

\begin{itemize}
\item Mutex = \emph{mutual exclusion}
\item Special form of Dijkstra semaphores -- the difference between mutexes and
binary semaphores is that \emsl{mutex has an owner and locked mutex must be
unlocked only by the thread that acquied it.} This is not the case with
semephores. In order to check whether given mutex was locked by different thread
when acquiring it, it is necessary to test return value of
\texttt{p\-thread\_mutex\_lock}, and also have the lock checking set, see below.
\item Mutexes are meant to be held for short time only. They are used for
critical section (see the definition on page \pageref{CRITICALSECTION}),
implementation, similarly to lock-files or semaphores (used like locks).
\item Lock checking is governed by mutex type. By default the mutex type is set to
\texttt{PTHREAD\_MUTEX\_DEF\-AULT}. This type does not define the result of
locking a locked mutex, unlocking a mutex locked by different thread or
unlocking an unlocked mutex. Concrete Unix implementations will map this define
to \texttt{PTHREAD\_MUTEX\_NORMAL} or \texttt{PTHREAD\_\-MUT\-EX\_ERRORCHECK}.
Thus, depending on correct implementation, that locking already locked mutex
will result in deadlock (\texttt{NORMAL}) or not (\texttt{ERRORCHECK}).
In the second case, return value will contain information about the error.
If not tested, the program will wrongly assume that the mutex is locked.
For the \texttt{NORMAL} type the result of the remaining two situations is not
define, for \texttt{ERRORCHECK} an error will be returned. ``Not defined``
means that the thread unlocking a mutex locked by different thread can succeed.
Or not -- everything depends on the implementation at hand. It also means that
the result of such operations is of no interest because these should be avoided.
More info can be found in the POSIX standard or the
\texttt{pth\-read\_mutex\-attr\_set\-ty\-pe} man page.
Checking return values of mutex functions can make the code slightly less
readable however it can be wrapped in a macro. Alternatively, the checks can be
used during development only.
Solaris and Linux use \texttt{NORMAL} type by default, FreeBSD uses
\texttt{ERRORCHECK}.
\label{NOTMYLOCK}
Example: \example{mutexes/not-my-lock.c}.
\item Another type is \texttt{PTHREAD\_MUTEX\_RECURSIVE} that holds count of
lock actions done by given thread. The remaining threads will be granted access
only if the count reaches 0. This mutex cannot be shared between processes.
\item What are recursive mutexes good for ? Let's assume there are two
libraries, \texttt{A} and \texttt{B}. There is a library
function \texttt{A:foo()}, that will acquire a mutex and calls \texttt{B:bar()}
that can in turn call \texttt{A:bar()}, which will try to acquire the same
mutex. Without recursive locks a deadlock will ensue. With recursive mutexes
that's fine if these two calls are done by the same thread (another thread will
get blocked). That is, assuming \texttt{A:foo()} and \texttt{A:bar()} are aware
that the same thread can be already in the critical section.
\item \label{MUTEXTAB} The behavior according to mutex types:
shrnuje tabulka:\\
\\
\raisetab{
\begin{tabular}[t]{r|c|c|c|}
% \cline{2-4}
&\texttt{NORMAL}&\texttt{ERRORCHECK}&\texttt{RECURSIVE}\\
% \cline{2-4}
detects deadlock&N&Y&N/A\\
multi locking&deadlock&error&success\\
unlock by different thread&undefined&error&error\\
unlock unlocked&undefined&error&error\\
can be shared between processes&Y&Y&N
% \cline{2-4}
\end{tabular}}
\item Static mutex initialization using before mentioned macro will set default
attributes. It is possbile to use initializer function also for statically
allocated mutex. If a mutex is dynamically allocated, it is always necessary to
use \texttt{pthread\_mutex\_init}, even if the default attributes are desired or
not.
\item Dynamic mutexes are needed e.g. when a data structure which contains a
mutex protecting it, is dynamically allocated.
In such case before calling \texttt{free} with the data structure, it is first
necessary to properly destroy the mutex (that can also have some memory
allocated). Destroying locked mutex is not defined by the standard.
\item Copying mutexes is also not defined by the standard -- the result of such
operation depends on implementation. It is possible to copy pointer to mutex
and work with that.
\item Mutex destroy means its de-initialization.
\end{itemize}

%%%%%

\pdfbookmark[1]{pthread\_mutex\_lock, pthread\_mutex\_unlock,%
pthread\_mutex\_trylock}{pthreadmutexfncs}

\begin{slide}
\sltitle{Mutexes (2)}

\begin{itemize}
\item to lock and unlock mutex:
\end{itemize}

\texttt{int \funnm{pthread\_mutex\_lock}(pthread\_mutex\_t *\emph{mx});}
\linebreak
and
\linebreak
\texttt{int \funnm{pthread\_mutex\_unlock}(pthread\_mutex\_t *\emph{mx});}

\begin{itemize}
\item If a mutex is already locked, the attempt to acquire it will result on the
thread being locked (depending on mutex type).
It is possible to use:
\end{itemize}

\texttt{int \funnm{pthread\_mutex\_trylock}(pthread\_mutex\_t *\emph{mx});}

\begin{itemize}
\item[\dots] that will attempt to acquire the mutex and if that fails it will
return error
\end{itemize}
\end{slide}

\label{MUTEXES2}

\begin{itemize}
\item Locking a mutex that is being held by another thread is not correct.
Sometimes a (self)deadlock can ensue, see the previous page. If you need to
unlock a mutex locked by different thread, use binary semaphores instead.
\item When creating a program where effectivity is paramount, it is necessary to
think about how many mutexes will be needed and how exactly will be used.
Even a library that was not written with threads in mind can be converted to be
thread-safe (see page \pageref{THREADSAFE}) by inserting arbitrary function from
the library a lock will be acquired and released before the function exits.
Such locked can be called ``giant'' mutex, i.e. there will be lock contention
for every consumer of such library in given program. On the other hand, if using
many mutexes to synchronize access to concrete small sections, lots of time can
be spent in the functions implementing the locking. It is therefore desired to
search for a compromise. (Or use an algorithm that does not require locks at
all)
\item \label{MUTEX_RACE} Examples: \example{mutexes/race.c},
\example{mutexes/race-fixed.c}
\item Mutexes can be shared between processes so that their threads will
synchronize on them. This is done by using shared memory that will be set as an
attribute of such mutexes. See the
\texttt{pthread\_mutexattr\_setpshared} man page.
\end{itemize}


%%%%%

\begin{slide}
\sltitle{Podmínkové promìnné (1)}
\begin{itemize}
\item mutexy slou¾í pro synchronizaci pøístupu ke sdíl{}eným datùm
\item podmínkové promìnné pak k pøedání informací o tìchto sdíl{}ených
datech -- napøíklad ¾e se hodnota dat zmìnila
\item \dots{}a umo¾ní tak vlákna podle potøeby uspávat a probouzet
\item z toho plyne, ¾e \emsl{ka¾dá podmínková promìnná je v¾dy
asociována s právì jedním mutexem}
\item jeden mutex ale mù¾e být asociován s více podmínkovými promìnnými
\item spoleènì pomocí mutexù a podmínkových promìnných je mo¾né
vytváøet dal¹í synchronizaèní primitiva -- semafory, bariéry, \dots
\end{itemize}
\end{slide}

\label{CONDITION_VARIABLES}

\begin{itemize}
\item jinými slovy -- podmínkové promìnné se pou¾ívají v situaci, kdy vlákno
potøebuje otestovat stav \emsl{sdíl{}ených} dat (napø. poèet zpráv ve frontì), a
dobrovolnì se uspat, kdy¾ hledaného stavu nebylo dosa¾eno. Spící vlákno je pak
probuzeno jiným vláknem, které zmìnilo stav dat tak, ¾e nastala situace, na
kterou první vlákno èeká (tøeba vlo¾ením prvku do fronty). Druhé vlákno vzbudí
první vlákno zavoláním k tomu urèené funkce. Pokud ¾ádné vlákno v dané chvíli
nespí, probouzecí funkce nemá ¾ádný efekt -- nic se nikde neulo¾í, prostì jako
by se to nikdy nestalo.
\item není to tak, ¾e pøi deklaraci podmínkové promìnné, co¾ je pro programátora
zcela transparentní typ, s ní asociujete podmínku napø. ``\emph{\texttt{n} je
vìt¹í ne¾ 7}''. Pod\-mín\-ko\-vou promìnnou toti¾ mù¾ete pøirovnat k praporu
nìjaké barvy, a pokud jej zvednete, znamená to, ¾e ta vlákna, která èekají a¾
touto vlajkou nìkdo zamává nad hlavou, jsou o této situaci informována (=
vzbuzena) a mohou se podle toho zaøídit. Nìkterá vlákna tak mohou èekat na to,
a¾ \texttt{n} bude vìt¹í ne¾ 7, jiná mohou èekat pouze na to, a¾ se \texttt{n}
jakkoli zmìní. Je pouze na programátorovi, zda pro ka¾dou konkrétní situaci
pou¾ije jednu podmínkovou promìnnou, nebo jednu pro v¹echny situace dohromady.
Pro druhou situaci platí, ¾e vlákna èekající na \texttt{n == 7} pak musí v¾dy
\texttt{n} otestovat, proto¾e ví, ¾e je vzbuzeno pøi kazdé zmìnì èítaèe
\texttt{n}. Pokud není èítaè roven sedmi, znovu se dobrovolnì uspí. Jak je v¹ak
uvedeno dále, \emsl{test je nutné po probuzení provést v¾dy}, i kdy¾ pro nìj
pou¾íváte samostatnou podmínkovou promìnnou -- mù¾e se stát, ¾e systém z rùzných
implementaèních dùvodù vzbudí vlákno uspané nad podmínkovou promìnnou, ani¾ by
to zpùsobilo jiné vlákno a tedy ani¾ by stav na který vlákno èeká opravdu
nastal.
\end{itemize}

%%%%%

%%%%%

\pdfbookmark[1]{pthread\_cond\_init, pthread\_cond\_destroy,%
pthread\_cond\_wait}{pthreadcondvarfncs}

\begin{slide}
\sltitle{Podmínkové promìnné (2)}
\prgchars
\funml{int \funnm{pthread\_cond\_init}(\=pthread\_cond\_t *\emph{cond},
\\\>const pthread\_condattr\_t *\emph{attr});}
\begin{itemize}
\item Inicializuje podmínkovou promìnnou \texttt{cond} s atributy \texttt{attr}
(nastavují je funkce \texttt{pthread\_condattr\_...()}), \texttt{NULL} =
default.
\end{itemize}
\texttt{int \funnm{pthread\_cond\_destroy}(pthread\_cond\_t *\emph{cond});}
\begin{itemize}
\item zru¹í podmínkovou promìnnou.
\end{itemize}
\funml{int \funnm{pthread\_cond\_wait}(\=pthread\_cond\_t *\emph{cond},
\\\>pthread\_mutex\_t *\emph{mutex});}
\begin{itemize}
\item èeká na podmínkové promìnné dokud jiné vlákno nezavolá
\funnm{pthread\_cond\_signal()} nebo \funnm{pthread\_cond\_broadcast()}.
\end{itemize}
\end{slide}

\begin{itemize}
\item je nutné, aby po té, co vlákno zamkne mutex a døíve, ne¾ vlákno zavolá
\texttt{pthread\_cond\_wait}, otestovat podmínku. Pokud tuhle operaci vlákno
neprovede, mohlo by se uspat na neurèitou dobu, proto¾e hlá¹ka o splnìní
podmínky od jiného vlákna by pro¹la ``bez pov¹imnutí''. Jinak øeèeno, nesmím se
uspat pøi èekání na situaci, která u¾ mezitím nastala. Nefunguje to jako
signály, které pro vás systém dr¾í, pokud je máte napøíklad zablokované. Co je
dùle¾ité je to, ¾e ten test provádíte pod ochranou mutexu, tedy si opravdu
mù¾ete být jistí daným stavem vìcí pøi zavolání \texttt{pthread\_cond\_wait}.
\item to, ¾e podmínkové promìnné opravdu fungují je zpùsobeno tím, ¾e pøi vstupu
do kritické sekce vlákno zamkne mutex a \emsl{funkce \texttt{pthread\_cond\_wait}
pøed uspáním vlákna mutex odemkne}. Pøed ná\-vra\-tem z této funkce se pak mutex
opìt zamkne. Mù¾e se tedy stát, ¾e vlákno je probuzeno z èekání nad podmínkovou
promìnnou, ale nìjaký èas se pak je¹tì uspí pøi pokusu o zamknutí mutexu.
Nehledejte v tom nic slo¾itého, jde pouze o klasické vzájemné vylouèení procesù
nad kritickou sekcí.
\end{itemize}

%%%%%

\pdfbookmark[1]{pthread\_cond\_signal, pthread\_cond\_broadcast,
pthread\_cond\_timedwait}{pthreadcondunblfncs}

\begin{slide}
\sltitle{Podmínkové promìnné (3)}
\prgchars
\texttt{int \funnm{pthread\_cond\_signal}(pthread\_cond\_t *\emph{cond});}
\begin{itemize}
\item probudí jeden proces èekající na podmínkové promìnné
\texttt{cond}.
\end{itemize}
\texttt{int \funnm{pthread\_cond\_broadcast}(pthread\_cond\_t *\emph{cond});}
\begin{itemize}
\item probudí v¹echny procesy èekající na podmínkové promìnné
\texttt{cond}.
\end{itemize}
\funml{int \funnm{pthread\_cond\_timedwait}(\=pthread\_cond\_t *\emph{cond}, 
\\\>pthread\_mutex\_t *\emph{mutex},\\\> const struct timespec *\emph{atime});}
\begin{itemize}
\item èeká na \texttt{pthread\_cond\_signal()} nebo
\texttt{pthread\_cond\_broadcast()}, ale maximálnì do doby ne¾ systémový
èas dosáhne hodnoty dané \texttt{atime}.
\end{itemize}
\end{slide}

\begin{itemize}
\item jak ji¾ bylo øeèeno, jedna podmínková promìnná mù¾e být pou¾ita pro
hlá\-¹e\-ní nìkolika rozdílných situací najednou -- napøíklad pøi vlo¾ení prvku do
fron\-ty i pøi jeho vyjmutí. Z toho dùvodu je nutné po probuzení otestovat
podmínku, na kterou se èeká. Dal¹í vìc, která z toho vychází je ta, ¾e v takovém
pøípadì musíte pou¾ít broadcast. Staèí si pøedstavit následující situaci --
èekáte na podmínku ``zmìnil se stav fronty'', na které èekají ètenáøi i
zapisovatelé (pøedpokládejme, ¾e jednu frontu pou¾ívá více ètenáøù i více
zapisovatelù). Pokud po vlo¾ení zprávy pouze vypustíte jednu signalizaci, tak se
mù¾e stát, ¾e tato signalizace probudí jiného zapisovatele, který ale samozøejmì
èeká na situaci, kdy ètenáø z fronty zprávu odebere. Tím se stane, ¾e ve frontì
zùstane zpráva, která mù¾e být vytlaèena a¾ dal¹í signalizací.
\item vlákno mù¾e být probuzeno jiným vláknem i v pøípadì, ¾e je podmínková
promìnná svázána pouze s jednou konkrétní událostí, která v¹ak po probuzení
vlákna ji¾ neplatí. Pøedstavte si, ¾e tìsnì po té, kdy jiné vlákno zahlásí
splnìní podmínky, mù¾e dal¹í vlákno zamknout mutex a nìjakou akcí, napø.
vyjmutím prvku z fronty, zru¹it platnost podmínky ``ve frontì je zpráva''. To
vlákno, které je probuzeno, tak najde frontu prázdnou. Dal¹í dùvod pro to, ¾e
podmínkové promìnné je nutné \emsl{v¾dy} testovat v cyklu.
\item v øídkých pøípadech je mo¾né, ¾e se vlákno probudí a podmínka není platná
i díky konkrétní implementaci. Z toho opìt vyplývá nutnost pou¾ití cyklu.
\item v parametru \texttt{abstime} funkce \texttt{pthread\_cond\_timedwait} se
pøedává absolutní èas, tj. timeout vypr¹í, kdy¾ systémový èas dosáhne hodnoty
vìt¹í nebo rovné \texttt{abstime}. Pro absolutní èas bylo rozhodnuto proto, aby
programátor nemusel pøi pøípadných probuzeních, kdy následnì zjistí, ¾e daná
podmínka neplatí, pøepoèítávat èasový rozdíl.
\end{itemize}

%%%%%

\begin{slide}
\label{CONDVAR_USE}
\sltitle{Pou¾ití podmínkových promìnných}
\begin{alltt}
pthread\_cond\_t cond; pthread\_mutex\_t mutex;
...
\emprg{pthread\_mutex\_lock}(&mutex);
while (!podminka(data))
    \emblue{pthread\_cond\_wait}(&cond, &mutex);
process\_data(data, ...);
\emprg{pthread\_mutex\_unlock}(&mutex);
...
\emprg{pthread\_mutex\_lock}(&mutex);
produce\_data(data, ...);
\emblue{pthread\_cond\_signal}(&cond);
\emprg{pthread\_mutex\_unlock}(&mutex);
\end{alltt}
\end{slide}

\begin{itemize}
\prgchars
\item První kus kódu èeká na zmìnu podmínky. Pokud k ní dojde, data zmìnila
a tedy mohou být zpracována. Druhý kus kódu (spu¹tìný v jiném vláknì) data
pøipravuje ke zpracování. Jakmile jsou pøipravena, zasignalizuje konzumentovi.
\item pro zopakování -- ke ka¾dé podmínkové promìnné je potøeba mít je¹tì mutex.
\item funkce \texttt{pthread\_cond\_wait} atomicky odemkne mutex a uspí
vlákno. Kdy¾ je vlákno probuzeno, nejprve se znovu zamkne mutex (tj. toto
zamknutí se provede v rámci pøíslu¹né implementace podmínkových promìnných!) a
teprve pak se volání \texttt{pthread\_cond\_wait} vrátí.
\item kdy¾ signalizujeme, ¾e se nìco zmìnilo, neznamená to je¹tì, ¾e po zmìnì
bude platit podmínka. Navíc, jak bylo nìkolikrát zdùraznìno,
\texttt{pthread\_cond\_wait} mù¾e vrátit, i kdy¾ ¾ádné jiné vlákno nezavolalo
\texttt{pthread\_cond\_signal} ani \texttt{pthread\_cond\_broadcast}. Dal¹í
dùvod proè je potøeba znovu otestovat pod\-mín\-ku a pøípadnì obnovit èekání.
\item Odemknutí zámku následuje v pøíkladu na slajdu a¾ po signalizaci podmínky,
ale není to nutné.  Mù¾ete signalizovat a¾ po odemknutí a v takovém pøípadì to
mù¾e být v závislosti na konkrétním systému i efektivnìj¹í, proto¾e probuzené
vlákno se hned neuspí na zámku, který jinak je¹tì dr¾íte, pokud signalizujete v
rámci kritické sekce.
\item \label{QUEUESIMULATION} pøíklad: \example{cond-variables/queue-simulation.c}
\end{itemize}


%%%%%

\pdfbookmark[1]{pthread\_rwlock\_init, pthread\_rwlock\_rdlock,%
pthread\_rwlock\_tryrdlock}{pthreadrwlockfncs}

\begin{slide}
\sltitle{Read-write zámky (1)}
\prgchars
\funml{int \funnm{pthread\_rwlock\_init}(\=pthread\_rwlock\_t *\emph{l},
\\\>const pthread\_rwlockattr\_t *\emph{attr}); }
\begin{itemize}
\item vytvoøí zámek s atributy podle \texttt{attr} (nastavují se funkcemi
\texttt{pthread\_rwlockattr\_...()}, \emph{NULL} = default)
\end{itemize}
\texttt{int \funnm{pthread\_rwlock\_destroy}(pthread\_rwlock\_t *\emph{l});}
\begin{itemize}
\item zru¹í zámek
\end{itemize}
\texttt{int \funnm{pthread\_rwlock\_rdlock}(pthread\_rwlock\_t *\emph{l});}\\
\texttt{int \funnm{pthread\_rwlock\_tryrdlock}(pthread\_rwlock\_t *\emph{rwlock});}
\begin{itemize}
\item zamkne zámek pro ètení (více vláken mù¾e dr¾et zámek pro
ètení), pokud má nìkdo zámek pro zápis, uspí volající vlákno
(\texttt{rdlock()}) resp. vrátí chybu (\texttt{tryrdlock()}).
\end{itemize}
\end{slide}

\label{RWLOCKS}

\begin{itemize}
\item není souèástí POSIXových vláken z POSIX.1c, ale POSIX.1j roz¹íøení,
naz\-va\-né ``advanced realtime extensions''.
\item najednou mù¾e mít zámek buï nìkolik vláken zamèeno pro ètení nebo
maximálnì jedno vlákno zamèeno pro zápis (a nikdo pro ètení).
\item read-write zámky jsou semanticky podobné zamykání souborù pomocí
funkce \texttt{fcntl}.
\item Je bì¾né, ¾e implementace preferuje vlákna, která chtìjí zapisovat
pøed vlákny, která chtìjí èíst. Napø. pokud je zámek vlastnìný zapisovatelem
a nìjaké dal¹í vlákno zavolá \funnm{pthread\_rwlock\_rdlock} a existuje aspoò
jedno vlákno èekající v \funnm{pthread\_rwlock\_wrlock}, dá ètenáø pøednost
zapisovateli.
\item Existuje maximální poèet zamèení pro ètení daný implementací (velikostí
typu reprezentujícího poèet zamèení), po dosa¾ení maxima vrací
\funnm{pthread\_rwlock\_rdlock} hodnotu \texttt{EAGAIN}.
\end{itemize}


%%%%%

\pdfbookmark[1]{pthread\_rwlock\_wrlock, pthread\_rwlock\_trywrlock,%
pthread\_rwlock\_unlock}{pthreadrwlockfncsw}

\begin{slide}
\sltitle{Read-write zámky (2)}
\prgchars
\texttt{int \funnm{pthread\_rwlock\_wrlock}(pthread\_rwlock\_t *\emph{rwlock});}
\begin{itemize}
\item zamkne zámek pro zápis; pokud má nìkdo zámek pro ètení nebo
zápis, èeká. 
\end{itemize}
\texttt{int \funnm{pthread\_rwlock\_trywrlock}(pthread\_rwlock\_t *\emph{rwlock});}
\begin{itemize}
\item jako \texttt{pthread\_rwlock\_wrlock()}, ale kdy¾ nemù¾e
zamknout, vrátí chybu. 
\end{itemize}
\texttt{int \funnm{pthread\_rwlock\_unlock}(pthread\_rwlock\_t *\emph{rwlock});}
\begin{itemize}
\item odemkne zámek
\end{itemize}
\end{slide}

\begin{itemize}
\item \emph{zvlá¹tnost}: pokud vlákno èekající na zámek dostane signál, po
návratu z handleru se v¾dy pokraèuje v èekání, tj. nenastane chyba
\texttt{EINTR}. Takto se chovají i mutexy a podmínkové promìnné.
\end{itemize}

%%%%%

\pdfbookmark[1]{atomic\_add}{atomicadd}

\begin{slide}
\sltitle{Atomické aritmetické operace}
\begin{itemize}
\item pro architektury, kde operace sèítání není atomická
\item výraznì rychlej¹í ne¾ jiné mechanismy pro získání exkluzivního pøístupu
díky pou¾ití instrukcí na dané platformì zaji¹»ujících atomicitu.
\item nìkteré systémy dodávají funkce pro atomické operace,
(napø. \texttt{atomic\_add(3c)} v Solarisu), obecnì je lep¹í pou¾ít
podporu v C11 standardu pøes \emph{stdatomic.h}.
\item sada volání pro rùzné typy a operace, napø. sèítání:
\end{itemize}
\begin{verbatim}
    #include <stdatomic.h>

    atomic_int acnt;
    atomic_fetch_add(&acnt, 1);
\end{verbatim}
\end{slide}

\begin{itemize}
\item \label{ATOMIC_ADD} Pøíklad \example{race/atomic-add.c} demonstruje
problém se soubìhem pøi sèítání a jeho mo¾ná øe¹ení. Program spustí dvì
vlákna, ka¾dé vlákno pracuje se stejnou globální promìnnou \emsl{x}, do
které v cyklu postupnì pøiète èísla od jedné do velikosti parametru
\emsl{arg}, který program dostane na pøíkazové øádce. Vlákna bì¾í paralelnì,
ka¾dé z nich provádí toto:

\begin{verbatim}
for (i = 1; i < arg; ++i)
        x = x + i;
\end{verbatim}

Poté se sèítání pro kontrolu provede v hlavním vláknu, a dvojnásobek (mìli
jsme dva thready) se porovná s hodnotou globální promìnné \emsl{x}. Pokud
nejsou výsledky stejné, do¹lo k soubìhu (pøeteèení promìnné mù¾eme v této
situaci zcela ignorovat).
\par
Výsledky a èasy bìhu se markantnì li¹í pro situace, kdy program pou¾il
obyèejné sèítání, funkci pro atomickou aritmetiku a zamykání pomocí
mutexù. Je vidìt nìkolikanásobný rozdíl v dobì bìhu mezi pou¾itím
funkce pro atomickou aritmetiku a mutexù, zejména na procesorech hardwarovou
podporou paralelismu.
\item Podobnì existují dal¹í atomické rutiny pro odeèítání, bitové operace
AND a OR, pro pøiøazení hodnoty atd.
\end{itemize}


%%%%%

\pdfbookmark[1]{pthread\_barrier\_init, pthread\_barrier\_wait,%
pthread\_barrier\_destroy}{bariera}

\begin{slide}
\sltitle{Bariéra}
\begin{itemize}
\item bariéra (\emph{barrier}) je zpùsob, jak udr¾et èleny skupiny pohromadì
\item v¹echna vlákna èekají na bariéøe, dokud ji nedosáhne poslední vlákno; pak
mohou pokraèovat
\item typické pou¾ití je paralelní zpracování dat
\end{itemize}
\texttt{int \funnm{pthread\_barrier\_init}(pthread\_barrier\_t *\emph{barrier},
\emph{attr}, unsigned \emph{count});}
\begin{itemize}
\item inicializuje bariéru pro \emph{count} vstupù do ní
\end{itemize}
\texttt{int \funnm{pthread\_barrier\_wait}(pthread\_barrier\_t *\emph{barrier});}
\begin{itemize}
\item zablokuje se dokud není zavolána \emph{count}-krát
\end{itemize}
\texttt{int \funnm{pthread\_barrier\_destroy}(pthread\_barrier\_t *\emph{barrier});}
\begin{itemize}
\item zru¹í bariéru
\end{itemize}
\end{slide}

\label{BARRIER}

\begin{itemize}
\item API pro bariéry je definované od SUSv3, podívejte se napøíklad na
\texttt{pthread\_\-barrier\_init}, je mo¾né je ale jednodu¹e vytvoøit pomocí
mutexù a pod\-mín\-ko\-vých promìnných.
\item Pozor na to, ¾e bariéry jsou nepovinnou èástí POSIXu (patøí do
Advanced realtime threads) a tedy i systém certifikovaný na SUS je nemusí
implementovat, co¾ je pøípad Mac OS X (10.10).
\item bariéru mù¾ete vyu¾ít napø. v situaci, kdy mezi jednotlivými fázemi
zpracování je potøeba provést jistou inicializaci, vlákna pøed ní tedy na sebe
v¾dy musí poèkat, proto¾e inicializace dal¹í fáze mù¾e zaèít a¾ tehdy, kdy
skonèí fáze pøedchozí. Pøíklad \example{pthreads/pthread-barrier.c} ukazuje
pou¾ití ba\-ri\-éry pro nìkolik fází zpracování dat.
\item podmínka pro bariéru je napøíklad hodnota èítaèe rovnající se nule. Ka¾dé
vlákno, které dosáhne bariéry, sní¾í èítaè, který je na zaèátku inicializován na
poèet vláken. Pokud vlákno po dekrementování èítaèe zjistí, ¾e je¹tì není roven
nule, uspí se na podmínkové promìnné.  Pokud dané vlákno je tím vláknem, které
sní¾í èítaè na nulu, místo zavolání \texttt{pthread\_cond\_wait} po¹le
broadcast, který následnì probudí v¹echna vlákna spící na bariéøe
(\texttt{pthread\_cond\_signal} zde nestaèí, chcete probudit v¹echna vlákna, ne
jen jedno!). Pøed spu¹tìním dal¹í fáze zpracování se èítaè reinicializuje na
pùvodní hodnotu. I zde je nutné øe¹it rùzné problémy, napøíklad není mo¾né jen
tak reinicializovat èítaè poté, co bariéry dosáhne poslední vlákno, proto¾e jak
ji¾ víme, vlákna po probuzení z \texttt{pthread\_cond\_wait} musí v¾dy
otestovat, zda èítaè je opravdu nulový a pokud není, opìt se uspí. Tak¾e by se
vám mohlo stát, ¾e by se probudila jen nìkterá vlákna, nebo taky ¾ádná. Je nutné
zresetovat èítaè a¾ po probuzení posledního vlákna. Jak byste to øe¹ili?
\end{itemize}


%%%%%

\pdfbookmark[1]{sem\_init, sem\_post, sem\_wait}{semafory}

\begin{slide}
\sltitle{POSIX Semaphores}
\begin{itemize}
\item semafory pochází z POSIX-1003.1b (real-time extensions)
\item jména funkcí nezaèínají \emsl{pthread\_}, ale \emsl{sem\_}
(\texttt{sem\_init}, \texttt{sem\_post}, \texttt{sem\_wait}, \dots)
\item je mo¾né je pou¾ít s vlákny
\end{itemize}
\end{slide}

\begin{itemize}
\item funkce pro semafory se dr¾í klasické UNIXové sémantiky -- pøi
chybì vracejí -1 a nastaví \texttt{errno}
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Typické pou¾ití vláken}

\begin{itemize}
\item \emsl{pipeline}
\begin{itemize}
\item ka¾dé z vláken provádí svoji operaci nad daty, která se
postupnì pøedávají mezi vlákny
\item ka¾dé vlákno typicky provádí jinou operaci
\item[\dots] zpracování obrázku, kde ka¾dé vlákno provede jiný filtr
\end{itemize}

\item \emsl{work crew}
\begin{itemize}
\item vlákna provádìjí stejnou operaci, ale nad jinými daty
\item[\dots] zpracování obrázku dekompozicí -- ka¾dé vlákno
zpracovává jinou èást obrázku, výsledkem je spojení zpracovaných dat
ze v¹ech vláken; zde se hodí øe¹ení s bariérou
\end{itemize}

\item \emsl{client -- server}
\end{itemize}
\end{slide}

\begin{itemize}
\item dané rozdìl{}ení je jen orientaèní, pou¾ití vláken je samozøejmì
neomezené, toto jsou asi ty tøi nejèastìj¹í pou¾ití
\item V pøípadì modelu klient -- server zpracovává ka¾dé vlákno jeden
po¾adavek od jednoho klienta.
\end{itemize}

%%%%%

\pdfbookmark[1]{thread-safe a reentrant functions}{thrsafe}

\begin{slide}
\sltitle{Thread-safe versus reentrantní}

\begin{itemize}
\item \emph{thead-safe} znamená, ¾e kód mù¾e být volán z více vláken
najednou bez destruktivních následkù
\begin{itemize}
\item do funkce, která nebyla navr¾ena jako thread-safe, je mo¾né
pøidat jeden zámek -- na zaèátku funkce se zamkne, na konci odemkne
\item tento zpùsob ale samozøejmì není pøíli¹ efektivní
\end{itemize}
\item slovem \emph{reentrantní} se typicky myslí, ¾e daná funkce byla navr¾ena s
pøihlédnutím na existenci vláken
\begin{itemize}
\item \dots{}tedy ¾e funkce pracuje efektivnì i ve vícevláknovém
prostøedí
\item taková funkce by se mìla vyvarovat pou¾ití statických dat a pokud mo¾no i
prostøedkù pro synchronizaci vláken, proto¾e bìh aplikace zpomalují
\end{itemize}
\end{itemize}
\end{slide}

\label{THREADSAFE}

\begin{itemize}
\item z vý¹e uvedeného vyplývá, ¾e thread-safe je slab¹í vlastnost ne¾
reentrantní. Napsat thread-safe funkci lze s pou¾itím synchronizaèních
primitiv; pøepsání existující funkci tak, aby byla reentrantní
vy¾aduje mnohem více invence.
\item reentrantní funkce jsou také jediné funkce bezpeènì pou¾itelné v
signal handlerech.
\item v dne¹ní dobì thread-safe vìt¹inou znamená reentrantní, tj. funkce jsou
pøe\-psá\-ny tak, aby pracovaly efektivnì i s vlákny, je ale dobré vìdìt, ¾e
nìkdy to mù¾e vyjadøovat rozdíl.
\item o zamykání knihoven viz také strana \pageref{MUTEXES2}.
\item existuje mno¾ství funkcí, které mohou být thread-safe, ale nikoliv
reentrant, napø. \texttt{gethostbyname}. Bì¾nì tato funkce pou¾ívá
statickou promìnnou, která se znovu pou¾ije pøi ka¾dém volání, tak¾e je
pro pou¾ití v multithreadovém prostøedí nevhodné - není thread-safe.
Nicménì, na FreeBSD 6.0 je tato funkce implementovaná tak, ¾e pou¾ívá
implicitnì thread-local storage pro ulo¾ení výstupních dat a
tím pádem je thread safe. To ji je¹tì ale neèiní úplnì bezpeènou k
pou¾ití (nemluvì o tom, ¾e program , který se spoléhá na takové chování
není portabilní), viz pøíklad \example{reentrant/gethostbyname.c}. O nìco
lep¹í je pou¾ít reentrantní verzi této funkce \texttt{gethostbyname\_r}
(pokud je na daném systému k dispozici), u které lze specifikovat adresu,
kam má ukládat svùj výstup, èím¾ se stává reentrantní. Daleko nejlep¹í
øe¹ení je pou¾ít standardní funkci \texttt{getaddrinfo} (viz strana
\pageref{GETADDRINFO}), která je sama o sobì reentrantní.


\item pøíklad: \example{reentrant/inet\_ntoa.c} - tady je vidìt, ¾e ani
takto napsaná funkce vám nepomù¾e pokud je volaná dvakrát v rámci
jednoho volání \texttt{printf}. Poka¾dé vrací pointer se stejnou adresou
(v jednom threadu), kterou si \texttt{printf} pouze poznamená a pøi
finálním tisku tedy vypí¹e reprezentaci poslední adresy, se kterou byla
\texttt{inet\_ntoa} volána. Na Solarisu je to vidìt pomocí:
\begin{verbatim}
truss -t\!all -u libnsl::inet_ntoa ./a.out
\end{verbatim}
\item Na Solarisu obsahují manuálové stránky knihovních funkcí polo¾ku
\texttt{MT-level} v sekci \texttt{ATTRIBUTES}, která udává zda je mo¾né
funkci pou¾ít v multithreadovém prostøedí a pøípadnì s jakými omezeními.
Tyto úrovnì jsou popsány v manuálové stránce attributes(5).
\end{itemize}

%%%%%

\pdfbookmark[1]{pthread\_set\_name\_np, pthread\_main\_np}{threadnpapis}

\begin{slide}
\sltitle{Nepøenositelná volání}

\begin{itemize}
\item nepøenositelná volání konèí øetìzcem \texttt{\_np} (\emph{non-portable}) a
jednotlivé systémy si takto definují vlastní volání

\item FreeBSD
\begin{itemize}
\item \funnm{pthread\_set\_name\_np}\texttt{(pthread\_t tid, const char *name)}
\item[$\rightarrow$] umo¾òuje pojmenovat vlákno
\end{itemize}

\item Solaris
\begin{itemize}
\item \funnm{pthread\_cond\_reltimedwait\_np}\texttt{(\dots)}
\item[$\rightarrow$] jako timedwait, ale èasový timeout je relativní
\end{itemize}

\item OpenBSD
\begin{itemize}
\item \texttt{int} \funnm{pthread\_main\_np}\texttt{(void)}
\item[$\rightarrow$] umo¾òuje zjistit, zda volající vlákno je hlavní
(= \texttt{main()})
\end{itemize}

\end{itemize}
\end{slide}

\begin{itemize}
\item Tyto informace jsou pro zajímavost, abyste vìdìli, ¾e se s podobnými vìcmi
mù¾ete setkat. Nepøenositelná volání by se mìla pou¾ívat spí¹e pro ladící úèely.
Nikdy nevíte, kdo bude potøebovat vá¹ kód spustit na jiném systému, co¾ se stane
typicky a neèekanì po té, co zrovna opustíte va¹i spoleènost a nemáte ji¾ èas to
opravit.
\item Zjistit, jaká nepøenositelná volání vá¹ systém poskytuje je jednoduché,
tøeba pomocí \texttt{apropos \_np}, nebo o nìco hrubìji (aplikujte na svùj
systém podle lokace manuálových stránek):
\begin{verbatim}
$ cd /usr/share/man
$ find . -name '*_np\.*'
./man3c/mq_reltimedreceive_np.3c
./man3c/mq_reltimedsend_np.3c
./man3c/posix_spawnattr_getsigignore_np.3c
./man3c/posix_spawnattr_setsigignore_np.3c
./man3c/pthread_cond_reltimedwait_np.3c
./man3c/pthread_key_create_once_np.3c
./man3c/pthread_mutex_reltimedlock_np.3c
./man3c/pthread_rwlock_reltimedrdlock_np.3c
./man3c/pthread_rwlock_reltimedwrlock_np.3c
./man3c/sem_reltimedwait_np.3c
\end{verbatim}
\end{itemize}

\pagebreak

\endinput
