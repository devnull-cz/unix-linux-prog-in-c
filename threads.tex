changequote([[[, ]]])

\pagebreak
\pdfbookmark[0]{threads and their synchronization}{vlakna}

\begin{slide}
\sltitle{Contents}
\slidecontents{8}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{slide}
\sltitle{Threads}
\begin{itemize}
\item \emph{thread} = \emph{thread of execution}, a basic software ``thing''
that can do work on a computer
\item classic Unix model: single threaded processes
\item with introduction of threads, a process becomes just a container for
threads
\item advantages of multithreaded applications
  \begin{itemize}
  \item speed-up -- a typical objective is having threads on multiple CPUs
  running in parallel
  \item more modular programming
  \end{itemize}
\item disadvantages
  \begin{itemize}
  \item more complex code
  \item debugging may become more difficult
  \end{itemize}
\end{itemize}
\end{slide}

\begin{itemize}
\item \emsl{While one has to put resources into sharing data when working with
processes, one has to put resources into managing
inherent data sharing if working with threads.}  Note that all threads of the
same process have equal access to the process virtual address space.
\item Not all applications are fit for multithreading as some tasks are not
inherently parallel in nature.
\item Even that debuggers typically support threads, debugging changes timing so
the problem may not reproduce when using the debugger.  That is usually not an
issue in a single threaded application.
\item There is an excellent book on programming with POSIX threads by Butenhof,
see page \pageref{REF_PROGRAMMING}. You can also use an online book
\emph{Multithreaded Programming Guide} available on
\url{http://docs.oracle.com}.
\item \label{PRIVILEGE_SEPARATION} An example situation when you do not want to
use threads is if you want to change a real and effective UID of processes.  Take
OpenSSH -- every connection is served by two processes.  One, with maximum
privileges, usually runs as root, and provides services (allocating a pseudo
terminal is one of them) to a second, unprivileged process.  The idea is that
most of the OpenSSH code does not need any special privilege so if a bug is
found in code that is run under an unprivileged user, the damage is much smaller
than if such code was run with maximum privileges.  This technique is called a
\emph{privilege separation} and you could not do the same thing with threads.
\end{itemize}

\begin{slide}
\sltitle{Implementation of threads}
\setlength{\baselineskip}{0.8\baselineskip}
\begin{description}
\item[library-thread model]~\\\vspace{-2.5ex}
    \begin{itemize}
    \item threads are implemented in a library.  Kernel has no knowledge of
    such threads.
    \item run-time library schedules threads on processes and kernel schedules
    processes on CPUs
    \item[$\oplus$] less overhead
    \item[$\ominus$] more threads of the same process cannot run in parallel
    \end{itemize}
\item [kernel-thread model]~\\\vspace{-2.5ex}
    \begin{itemize}
    \item threads are a first class kernel citizen
    \item[$\oplus$] more threads of the same process can run in parallel on
    multiple CPUs
    \end{itemize}
\item[hybrid models]~\\\vspace{-2.5ex}
    \begin{itemize}
    \item N library threads scheduled on M kernel threads, N $>=$ M
    \item[$\ominus$] too complex to implement, not really used today
    \end{itemize}
\end{description}
\end{slide}

\begin{itemize}
\item Original Unix systems used library models.  Today in general the kernel
model is used.
\item Threads implemented in a library may be either preemptive or
non-pre\-emp\-tive.  To achieve preemptiveness, you can use timers and signals.
However, if the objective is more in better modular programming than real
parallelism, usually non-preemptive threads do fine.  Switching threads will be
done when a process would normally block in system calls.
\item \label{SETJMP} If a system call blocks in a library implemented thread,
the whole process will block as the kernel has no knowledge there are more
threads in the process.  So the threading library is written the way that
non-blocking calls are used, the thread context is saved after that and the
library switches to another thread via \funnm{setjmp}() and \funnm{longjmp}()
system calls.  Example: \example{pthreads/setjmp.c}.  Another way is to use a
non-standard system call \funnm{swapcontext}() if the system provides it.
\end{itemize}

\begin{slide}
\sltitle{POSIX threads (pthreads)}

\begin{itemize}
\item first came with IEEE Std 1003.1c-1995
\item POSIX thread API uses a prefix \texttt{pthread\_}
\item these functions return 0 (= OK) or an error number (values as for
\texttt{errno})
\begin{itemize}
\item \dots{} functions do \emsl{not} set \texttt{errno}
\item so you cannot use functions \funnm{perror}() or \funnm{err}()
\end{itemize}
\item the standard also defines other functions, for example those that could
not be possible to adjust for the use with threads without changing its API (eg.
\texttt{readdir\_r}, \texttt{strtok\_r}, etc.)
\begin{itemize}
\item \texttt{\_r} means \emph{reentrant}, ie. the function can be called by
multiple threads without any side effects
\end{itemize}
\end{itemize}

\end{slide}

\label{POSIXTHREADS}

\begin{itemize}
\item General information on POSIX is on page \pageref{POSIX}.
\item There are more threading API, the POSIX thread API is just one of them.
For example, there is a system call \texttt{sproc()} on IRIX, then Cthreads,
Solaris threads, GNU Ptr threads (= portable), \dots
\item The POSIX thread API is available in different libraries on different
systems.  For example, on Linux you usually need \texttt{-lpthread} but on
Solaris the API is part of standard \texttt{libc}.  With \texttt{gcc}, instead
of \texttt{-lpthread}, you can use \texttt{-pthread} and the compiler will do
what is needed for the specific system (which does not have to be Linux).
\item Each POSIX thread API implementation is usually built on top of the native
threading library.  For example, on Solaris, it's the \texttt{thr\_} API
functions.
\item We will talk more on reentrant functions in connection with threads on
page \pageref{THREADSAFE}.
\item As already mentioned, given that the POSIX thread API uses \texttt{errno}
codes directly as return values, the following piece of code is not correct:

\begin{verbatim}
if (pthread_create(&thr, NULL, thrfn, NULL) != 0)
        err(1, "pthread_create");
\end{verbatim}

as it will print possibly something like the following on error (unless
\texttt{errno} was set by previous code which would make it even more
confusing):

\begin{itemize}
\item ``\texttt{a.out: pthread\_create: Success}'' on Linux distros
\item ``\texttt{a.out: pthread\_create: Error 0}'' on Solaris
\item ``\texttt{a.out: pthread\_create: Unknown error: 0}'' on FreeBSD
\item or something else based on the system and the concrete message it uses for
\texttt{errno} equal to 0, unless \texttt{errno} is already set otherwise.
\end{itemize}

The Linux approach might confuse the programmer as leaving \texttt{errno} zero
does not have to mean the function did not fail, as we just showed.  FreeBSD
makes it obvious that something is not entirely right.  Example that shows such
a situation: \example{pthreads/wrong-err-use.c}. The correct code could look
like this:

\begin{verbatim}
int e;

if ((e = pthread_create(&thr, NULL, thrfn, NULL)) != 0)
        errx(1, "pthread_create: %s", strerror(e));
\end{verbatim}

\item \label{ERRNO_IN_THREADS} Other functions that use \texttt{errno} work the
same with POSIX threads as each thread has its own \texttt{errno}.  In that
case, it is redefined using a function (which can either return the value or an
address which is dereferenced).  Check \texttt{/usr/include/bits/errno.h} on
Linux if interested.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Example: thread creation}
{\catcode95=12\catcode38=12
\begin{center}
\input{img/tex/threads.pstex_t}
\end{center}}
\end{slide}

\begin{itemize}
\item This is a trivial example.  The process (main thread) creates two more
threads and waits for them to finish.  This process thus have 3 threads in
total.
\end{itemize}

%%%%%

\pdfbookmark[1]{pthread\_create}{thrcreate}

\begin{slide}
\label{PTHREAD_T}
\sltitle{Thread creation}
\funml{int \funnm{pthread\_create}(\=pthread\_t *\emph{thread},
\\\>const pthread\_attr\_t *\emph{attr},
\\\>void *(*\emph{start\_fn})(void*), void *\emph{arg});}
\begin{itemize}
\item creates a new thread, puts its ID to \emph{thread}
\item with attributes from \texttt{attr}, eg. its stack size,
\texttt{NULL} means default attributes
\item function \emph{start\_fn}() will be started in the thread using argument
\emph{arg}.  After the function returns, the thread ceases to exist.
\item with the \texttt{pthread\_attr\_t} objects can be manipulated using
\funnm{pthread\_attr\_init}(), \funnm{pthread\_attr\_destroy}(),
\funnm{pthread\_attr\_setstackaddr}(), etc\dots{}
\end{itemize}
\end{slide}

\begin{itemize}
\item Be careful not to use this:
\begin{alltt}
for (i = 0; i < N; i++)
    pthread\_create(&tid, attr, start\_routine, &i);
\end{alltt}

It looks like we pass each thread its index.  However, before the started thread
gets scheduled to run, a next iteration might happen, modifying \texttt{i}.
\item \label{WRONG_USE_OF_ARG} Examples: \example{pthreads/wrong-use-of-arg.c},
\example{pthreads/correct-use-of-arg.c}.
\item If you need to pass only one value, you could use the following
(\textbf{note that it is implementation specific in the C standard so it is not
portable});

\begin{alltt}
assert(sizeof (void *) >= sizeof (int));
for (i = 0; i < N; i++)
    pthread\_create(&tid, attr, start\_routine, (void *)(intptr\_t)i);
\end{alltt}

\dots and in function \texttt{void *start\_routine(void *arg)} cast the pointer
back to integer.

\begin{alltt}
printf("thread \%d started\bs{}n", (int)arg);
\end{alltt}

\label{INT_AS_ARG} Example: \example{pthreads/int-as-arg.c}
\item If we need to pass more bytes than it is the size of the pointer, you must
pass a pointer to memory where the passed data is stored, or use global
variables.  Accessing global variables must be synchronized, of course.  More on
that on page \pageref{THREADSYNCHRONIZATION}.
\item \label{PTHREAD_CREATE_CYCLE} \texttt{pthread\_t} is a transparent type and
its implementation is not of your concern.  Usually it is an integer though used
to map to the native threads provided by the system.  If you create several
threads, you need to pass a different address for a \texttt{pthread\_t} variable
otherwise you will not be able to further manipulate with the threads from the
main thread, eg. waiting for them to finish.
\end{itemize}

%%%%%

\pdfbookmark[1]{pthread\_self, pthread\_key\_create}{pthreadkey}
\label{THREAD_ATTRS}

\begin{slide}
\sltitle{Thread private attributes}
\begin{itemize}
\item instruction pointer
\item stack (automatic variables)
\item thread ID, available through\\
\texttt{pthread\_t \funnm{pthread\_self}(void);}
\item scheduling priority and policy
\item value of \texttt{errno}
\item thread specific data -- a pair of
\texttt{(pthread\_key\_t \emph{key}, void *\emph{ptr})} 
    \begin{itemize}
    \item a key created by \funnm{pthread\_key\_create}() is visible from all
    threads
    \item in every thread the key may be associated with a different value via
    \funnm{pthread\_setspecific}()
    \end{itemize}
\end{itemize}
\end{slide}

\begin{itemize}
\item Each thread has a fixed size stack which \emsl{does not automatically
increase.}  It is usually anywhere from 64 kilobytes to a few megabytes.  If you
cross that limit, the program will quite probably crash.  If you want a stack of
a greater size than what is the system default, you have to use \emph{attr} when
creating a thread.  Example: \example{pthreads/pthread-stack-overflow.c}
\item You can read more about thread specific data on page
\pageref{THREAD_SPECIFIC_DATA}.
\item Each thread also has its own signal mask.  More on that on page
\pageref{PTHREADSIGMASK}.
\end{itemize}

%%%%%

\pdfbookmark[1]{pthread\_exit, pthread\_join, pthread\_detach}{pthreadexit}

\begin{slide}
\sltitle{Terminating the calling thread}
\texttt{void \funnm{pthread\_exit}(void *\emph{val\_ptr});}
\begin{itemize}
\item terminates the calling thread, it is similar to \funnm{exit}() for
processes
\end{itemize}
\texttt{int \funnm{pthread\_join}(pthread\_t \emph{thr},
void **\emph{val\_ptr});}
\begin{itemize}
\item waits for thread \emph{thr} to finish, the value passed to
\funnm{pthread\_exit}() or the return value is stored in the location referenced
by \emph{val\_ptr}
\end{itemize}
\texttt{int \funnm{pthread\_detach}(pthread\_t \emph{thr});}
\begin{itemize}
\item indicate that storage for the \emph{thr} can be reclaimed when the thread
terminates.  \funnm{pthread\_join}() can no longer be used.
\end{itemize}
\end{slide}

\begin{itemize}
\item If \funnm{pthread\_exit}() is not used, it is implicitly called when the
thread terminates with the value from the function \texttt{return}.
\item The contents the finishing thread stack is undefined so you should not use
pointers to the function local variables from memory pointed to by
\emph{val\_ptr}.
\item If you do not intend to call \funnm{pthread\_join}(), you need to call
\funnm{pthread\_det\-ach}() or use the attributes (see below).  If you do not, a
memory needed to carry information for a subsequent \funnm{pthread\_join}() will
not be freed.  It is a similar situation as with accumulated zombies.  You can
just call it like this in the thread function:
\begin{alltt}
pthread\_detach(pthread\_self());
\end{alltt}
\item You can also set the thread attributes when creating the thread, using
\funnm{p\-thr\-ead\_attr\_setdetachstate}() with
\texttt{PTHREAD\_CREATE\_DETACHED} on the attribute variable and then use that
in \funnm{pthread\_create}().  Example on setting the attributes:
\example{pthreads/set-detachstate.c}
\item You can use \texttt{NULL} as \emph{val\_ptr} in \funnm{pthread\_join}(),
telling the system you are not interested in the return value.
\item Any thread can wait for another thread, not just the one that created it.
\item We recommend to always check the return value of \funnm{pthread\_join}()
to make sure you wait for the right thread.  If you use an incorrect thread ID,
the funtion returns immediatelly with an error.
\item In contrast to waiting for processes to finish, \emsl{one cannot wait for
any thread to finish}.  The rationale is that since there is not parent--child
relation, it was not deemed necessary.  However, some system provide that
functionality, eg.  on Solaris you can use \texttt{0} for a thread ID in
\funnm{thr\_join}().  If you needed this functionality with POSIX thread API, it
is easy to set threads as \emph{detached} and use a condition variable together
with a global variable.  More on that on page \pageref{CONDITION_VARIABLES}.
\item \label{PTHREAD_JOIN} Examples: \example{pthreads/pthread-join.c},
\example{pthreads/pthread-detach-join.c}
\end{itemize}


%%%%%

\pdfbookmark[1]{pthread\_once}{pthreadonce}

\begin{slide}
\sltitle{Initialization}
\funml{int \funnm{pthread\_once}(\=pthread\_once\_t *\emph{once\_control},
\\\>void (*\emph{init\_routine})(void));}
\begin{itemize}
\item in \emph{once\_control} you pass a pointer to statically initialized
variable \\ \texttt{pthread\_once\_t
\emph{once\_control} = PTHREAD\_ONCE\_INIT;}
\item first thread that calls \funnm{pthread\_once}() calls
\emph{init\_routine()}.  Other threads will not call the function, and if it has
not finished yet, will block waiting for it to finish.
\item you can use it for dynamic initialization of global data in libraries
where multiple threads may be using the library API at the same time
\end{itemize}
\end{slide}

\begin{itemize}
\item In the program itself you probably will not need this function.  You can
just call the initialization function before you create the first thread.
\item It is undefined if \emph{once\_control} is a local variable or does not
have an expected value.
\end{itemize}

%%%%%

\pdfbookmark[1]{pthread\_cancel, pthread\_setcancelstate, pthread\_setcanceltype}{pthreadcancel}

\begin{slide}
\sltitle{Cancel execution of a thread}
\setlength{\baselineskip}{0.9\baselineskip}
\texttt{int \funnm{pthread\_cancel}(pthread\_t \emph{thread});}
\begin{itemize}
\item cancel \emph{thread}.  Depends on:
\end{itemize}
\texttt{int \funnm{pthread\_setcancelstate}(int \emph{state},
int *\emph{old});}
\begin{itemize}
\item sets new state and returns the old value:
    \begin{itemize}
    \item \texttt{PTHREAD\_CANCEL\_ENABLE} \dots{} cancelation allowed
    \item \texttt{PTHREAD\_CANCEL\_DISABLE} \dots{} cancellation requests
    against the target thread are held pending
    \end{itemize}
\end{itemize}
\texttt{int \funnm{pthread\_setcanceltype}(int \emph{type}, int *\emph{old});}
\begin{itemize}
\item \texttt{PTHREAD\_CANCEL\_ASYNCHRONOUS} \dots{} immediate cancellation
\item \texttt{PTHREAD\_CANCEL\_DEFERRED} \dots{} cancellation requests are held
pending until a cancellation point is reached.
\end{itemize}
\end{slide}

\begin{itemize}
\item Cancellation points will occur when a thread is executing functions
specified in the standard, like \funnm{open}(), \funnm{read}(),
\funnm{accept}(), etc.  The full list is usually in the
\texttt{pthread\_setcancelstate} man page.
\item The \funnm{pthread\_testcancel}() function creates a cancellation point in
the calling thread.  The \funnm{pthread\_testcancel}() function has no effect if
cancelability is disabled.
\item Be very careful with the use of \texttt{PTHREAD\_CANCEL\_ASYNCHRONOUS} as
it may lead to data inconsitency as the cancellation may happen any time, even
in your critical sections.
\item Cleanup functions are called on cancellation, see page
\pageref{PTHREAD_CLEANUP}.  For example, if cancelling a thread holding a mutex,
you could use the cleanup function to unlock it.
\item Functions \funnm{pthread\_setcancelstate}() and
\funnm{pthread\_setcanceltype}() provide similar functionality to threads as is
manipulating a signal mask to processes.
\item \label{PTHREAD_CANCEL} Example: \example{pthreads/pthread-cancel.c}
\end{itemize}

%%%%%

\pdfbookmark[1]{pthread\_key\_create, pthread\_key\_delete,
pthread\_setspecific, pthread\_getspecific}{pthreadglobals}

\begin{slide}
\sltitle{Global variables per thread}
\funml{int \funnm{pthread\_key\_create}(\=pthread\_key\_t *\emph{key},
\\\>void (*\emph{destructor})(void *));}
\begin{itemize}
\item creates a key that can be associated with a value of
\texttt{(void *)} type.  Function \emph{destructor()} are called for all keys
whose value is not \texttt{NULL} on thread termination.
\end{itemize}
\texttt{int \funnm{pthread\_key\_delete}(pthread\_key\_t \emph{key});}
\begin{itemize}
\item deletes the key, does not change the associated data
\end{itemize}
\funml{int \funnm{pthread\_setspecific}(\=pthread\_key\_t \emph{key},
\\\>const void *\emph{value});}
\begin{itemize}
\item sets pointer \emph{value} to \emph{key}
\end{itemize}
\texttt{void *\funnm{pthread\_getspecific}(pthread\_key\_t \emph{key});}
\begin{itemize}
\item returns the value of \emph{key}
\end{itemize}
\end{slide}

\begin{itemize}
\item \label{THREAD_SPECIFIC_DATA} Common global variables and dynamically
allocated data is common to all threads.  Thread specific data provides a way to
create a global variable per thread.  Note the difference between that and a
local variable in the thread function.  The local variable is not visible in
other functions called from the thread function.  Thread specific data is a very
useful feature.  Imagine you have existing multithreading code using a global
storage place which suffers from lots of contention.  You can easily create a
thread specific data to create a storage place per thread with minimal changes
to the original code.
\item When you create a key, \texttt{NULL} is associated with it.  If you do not
need the destructor function, use \texttt{NULL}.
\item Destructors are called in unspecified order on all keys with a value
different from \texttt{NULL}.  Its value is set to \texttt{NULL} and the
original value is used as a parameter to the destructor.  If, after all the
destructors have been called for all non-\texttt{NULL} values with associated
destructors, there are still some non-\texttt{NULL} values with associated
destructors, then the process is repeated.  If, after at least
\texttt{PTHREAD\_DESTRUCTOR\_ITERATIONS} iterations of destructor calls for
outstanding non-NULL values, there are still some non-\texttt{NULL} values with
associated destructors, the implementation may (it usually does otherwise you
could end up with an infinite loop) stop calling destructors.
\end{itemize}

%%%%%

\pdfbookmark[1]{pthread\_cleanup\_push, pthread\_cleanup\_pop}{pthreadcleanup}

\begin{slide}
\sltitle{Cleanup functions}
\begin{itemize}
\item each thread has a stack of cleanup routines called when functions
\funnm{pthread\_exit}() or \funnm{pthread\_cancel}() are called (but not when
\texttt{return} is used).  Routines are run from the top of the stack down.
\item after cleanup functions are called, thread specific data destructors are
called in unspecified order
\end{itemize}
\funml{void \funnm{pthread\_cleanup\_push}(\=void (*\emph{routine})(void *),
\\\>void *\emph{arg});}
\begin{itemize}
\item add \emph{routine} to the top of the stack
\end{itemize}
\texttt{void \funnm{pthread\_cleanup\_pop}(int \emph{execute});}
\begin{itemize}
\item removed a routing from the top of the stack.  Will call the routine if
\emph{execute} is non-zero
\end{itemize}
\end{slide}

\label{PTHREAD_CLEANUP}

\begin{itemize}
\item Cleanup functions are called as \texttt{routine(arg)}.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{\funnm{fork}() and POSIX threads}
\prgchars
\begin{itemize}
\item it is necessary to define semantics of \funnm{fork}() in multithreaded
applications.  The standard says:

\begin{itemize}
\item the calling process contains the exact copy of the calling thread,
including all the mutex states
\item other threads are not propagated to the new process
\item if such other threads held allocated memory, the memory will remain
allocated but lost
\item mutexes locked in other threads will remain locked for ever
\end{itemize}
\item creating a process from a multithreaded application makes sense for
subsequent \funnm{exec}(), for example,  including \funnm{popen}() or
\funnm{system}()
\end{itemize}
\end{slide}

\begin{itemize}
\item No cleanup routines or thread specific data destructors are called for
threads not propagated to the new process.
\item \label{FORKALL} Note that the way how \funnm{fork}() works also depends on
the system used.  For example, in Solaris before version 10 (ie. before 2005),
\funnm{fork}() in the \texttt{libthread} library (different from
\texttt{libpthread}) was the same as \funnm{forkall}().
\item Examples: \example{pthreads/fork.c},
\example{pthreads/fork-not-in-main.c}, and also \example{pthreads/forkall.c}
\item \label{ATFORK} You can use \funnm{pthread\_atfork}() to set handlers that
are executed before \funnm{fork}() is called in the parent, and then after
\funnm{fork}() is called both in the parent and its child.  Such handlers are
very useful who use \funnm{fork}() not only for a wrapper around \funnm{exec}().
After \funnm{fork}(), all variables in the child are in the state as in the
parent, so if a thread not propagated to the child held a mutex (see page
\pageref{MUTEXES}), the mutex stays
locked in the child, and trying to lock in the child will lead to a deadlock.
However, if the parent in the \emph{pre-fork} handler locks all the mutexes, and
then unlocks them in the \emph{post-fork} handler (both for the parent and the
child), you will avoid such deadlocks.  When locking mutexes in the
pre-fork handler, other threads are still running so the mutexes held by them
can be released (usually each thread exits a crititcal section in a short time
in well written code).  Example: \example{pthreads/atfork.c}.  For more on this
topic, see [Butenhof].
\item See page \pageref{MUTEXES} on why mutexes locked in other threads on
\funnm{fork}() stay locked forever.
\end{itemize}

%%%%%

\pdfbookmark[1]{pthread\_sigmask}{pthreadsigmask}

\begin{slide}
\sltitle{Signály a vlákna}
\prgchars
\begin{itemize}
\item signály mohou být generovány pro proces (voláním
\texttt{kill}), nebo pro vlákno (chybové události, volání
\texttt{pthread\_kill}). 
\item nastavení obsluhy signálù je stejné pro v¹echna vlákna
procesu, ale masku blokovaných signálù má ka¾dé vlákno vlastní,
nastavuje se funkcí 
\end{itemize}
\funml{int \funnm{pthread\_sigmask}(\=int \emph{how},
const sigset\_t *\emph{set},\\\> sigset\_t *\emph{oset});}
\begin{itemize}
\item signál urèený pro proces o¹etøí v¾dy právì jedno vlákno, které
nemá tento signál zablokovaný. 
\item lze vyhradit jedno vlákno pro synchronní pøíjem signálù pomocí volání
\texttt{sigwait}. Ve v¹ech vláknech se signály zablokují.
\end{itemize}
\end{slide}

\label{PTHREADSIGMASK}

\begin{itemize}
\item Jestli¾e je pro signál nastaveno ukonèení procesu, skonèí celý proces,
nejen jedno vlákno.
\item Vytvoøené vlákno dìdí nastavení signálové masky od vlákna, které ho
vytvoøilo
\item Analogicky k pou¾ití \texttt{sigwait} s procesy (stra\-na
\pageref{SIGWAIT}) -- zablokujte pøíslu¹né signály ve v¹ech vlák\-nech, vèetnì
vlákna, ve kterém chcete zpracovávávat signály pomocí \texttt{sigwait}.
\emsl{Tento zpùsob zpracování signálù bývá èasto jediný opravdu doporuèovaný pro
vlákna}, a navíc je i nejsnáze implementovatelný. Jak vyplývá z pøedchozí
poznámky, staèí zamaskovat signály pouze jednou, a to v hlavním vláknì, proto¾e
maska se pak podìdí pøi ka¾dém volání \texttt{pthread\_create}.
\item V prostøedí vláken nepou¾ívejte \texttt{sigprocmask} (strana
\pageref{SIGPROCMASK}), proto¾e chování tohoto volání není v takovém prostøedí
normou specifikováno. Mù¾e to fungovat, a také nemusí.
\item \label{THREADS_SIGWAIT} Pøíklad: \example{pthreads/sigwait.c}.
\item \emsl{Pozor} na to, ¾e byste nemìli tento zpùsob obsluhy signálù pou¾ívat
pro sig\-nály synchronní jako jsou \texttt{SIGSEGV}, \texttt{SIGILL}, apod. Tyto
signály jsou ge\-ne\-ro\-va\-né pøímo pro vlákno, tak¾e pokud je zablokujete,
vlákno urèené pro synchronní pøíjem signálù je nemusí ``vidìt'', jedinì pokud by
ten signál zpù\-so\-bi\-lo samo, samozøejmì. Dal¹í vìc ale je, ¾e specifikací
není definováno, zda blokování takových signálù tyto signály skuteènì zablokuje,
jak ji¾ bylo zmínìno na stranì \pageref{SPECIALSIGNALS}. Nìkteré sys\-té\-my
tyto signály normálnì doruèí, èím¾ proces ukonèí, viz pøesné znìní:

\begin{quote}
\emph{If any of the SIGFPE, SIGILL, SIGSEGV, or SIGBUS signals are generated
while they are blocked, the result is undefined, unless the signal was generated
by the kill() function, the sigqueue() function, or the raise() function.}
\end{quote}

Pøíklad: \example{pthreads/sigwait-with-sync-signals.c}. Tento pøíklad ukazuje,
¾e na Solarisu 10, Solarisu 11, FreeBSD 7.2 a Linux distribuci, která se hlásí
jako ``Gentoo Base System release 1.12.13'', je signál \texttt{SIGSEGV} doruèen
a proces zabit bez ohledu na to, zda je maskován. Na¹el jsem ale i systém, který
po zamaskování signál nedoruèí -- FreeBSD 6.0. Synchronní signály by ale mìlo
být v¾dy mo¾né zachytit (pøed zavoláním \texttt{exit}), viz strana
\pageref{SPECIALSIGNALS}, kde je i pøíklad.

\end{itemize}


%%%%%

\begin{slide}
\sltitle{Thread synchronization in general}

\begin{itemize}
\item most of the programs employing threads needs to share data between them
\item or needs to execute given actions in certain order
\item \dots{}all of this needs to \emsl{synchronize} running threads activity
\item for processes it is necessary to make some effort to actually share data,
for threads on the other hand it is necessary to maintain natural data sharing.
\item will describe:
\begin{itemize}
\item mutexes
\item conditional variables
\item read-write locks
\end{itemize}
\end{itemize}
\end{slide}

\label{THREADSYNCHRONIZATION}

\begin{itemize}
\item Process synchronization is described on pages
\pageref{SYNCHRONIZATION} to \pageref{SYNCHRONIZATIONEND}.
\item Using mutexes and conditional variables it is possible to construct any
other synchronization model.
\item The exact behavior of synchronization primitives is largely determined by
the scheduler, that decides which of the threads waiting for unlock will be
waked up after the unlock happens. This leads to classical problems such as
\emph{thundering horde} (lots of threads waiting for unlock)
or \emph{priority inversion} (thread holding a lock has lower priority than
the thread waiting for the lock).
\end{itemize}

%%%%%
%%%%%

\pdfbookmark[1]{pthread\_mutex\_init, pthread\_mutex\_destroy}{pthreadinit}

\begin{slide}
\sltitle{Thread synchronization: mutexes (1)}

\begin{itemize}
\item the simplest way how to ensure synchronized access to shared data between
threads
\item inicialization of statically defined mutex:
\end{itemize}

\texttt{pthread\_mutex\_t mutex = PTHREAD\_MUTEX\_INITIALIZER;}

\begin{itemize}
\item inicialization of dynamically allocated mutex \texttt{mx} with attributes
\texttt{attr} (these are set using \texttt{pthread\_mutexattr\_...};
if \texttt{attr} is \texttt{NULL}, defaultní attributes will be used)
\end{itemize}

\funml{int \funnm{pthread\_mutex\_init}(\=pthread\_mutex\_t *\emph{mx},
\\\>const pthread\_mutexattr\_t *\emph{attr});}

\begin{itemize}
\item after done using the mutex it is possible to destroy it:
\end{itemize}

\texttt{int \funnm{pthread\_mutex\_destroy}(pthread\_mutex\_t *\emph{mx});}
\end{slide}

\label{MUTEXES}

\begin{itemize}
\item Mutex = \emph{mutual exclusion}
\item Special form of Dijkstra semaphores -- the difference between mutexes and
binary semaphores is that \emsl{mutex has an owner and locked mutex must be
unlocked only by the thread that acquied it.} This is not the case with
semephores. In order to check whether given mutex was locked by different thread
when acquiring it, it is necessary to test return value of
\texttt{p\-thread\_mutex\_lock}, and also have the lock checking set, see below.
\item Mutexes are meant to be held for short time only. They are used for
critical section (see the definition on page \pageref{CRITICALSECTION}),
implementation, similarly to lock-files or semaphores (used like locks).
\item Lock checking is governed by mutex type. By default the mutex type is set to
\texttt{PTHREAD\_MUTEX\_DEF\-AULT}. This type does not define the result of
locking a locked mutex, unlocking a mutex locked by different thread or
unlocking an unlocked mutex. Concrete Unix implementations will map this define
to \texttt{PTHREAD\_MUTEX\_NORMAL} or \texttt{PTHREAD\_\-MUT\-EX\_ERRORCHECK}.
Thus, depending on correct implementation, that locking already locked mutex
will result in deadlock (\texttt{NORMAL}) or not (\texttt{ERRORCHECK}).
In the second case, return value will contain information about the error.
If not tested, the program will wrongly assume that the mutex is locked.
For the \texttt{NORMAL} type the result of the remaining two situations is not
define, for \texttt{ERRORCHECK} an error will be returned. ``Not defined``
means that the thread unlocking a mutex locked by different thread can succeed.
Or not -- everything depends on the implementation at hand. It also means that
the result of such operations is of no interest because these should be avoided.
More info can be found in the POSIX standard or the
\texttt{pth\-read\_mutex\-attr\_set\-ty\-pe} man page.
Checking return values of mutex functions can make the code slightly less
readable however it can be wrapped in a macro. Alternatively, the checks can be
used during development only.
Solaris and Linux use \texttt{NORMAL} type by default, FreeBSD uses
\texttt{ERRORCHECK}.
\label{NOTMYLOCK}
Example: \example{mutexes/not-my-lock.c}.
\item Another type is \texttt{PTHREAD\_MUTEX\_RECURSIVE} that holds count of
lock actions done by given thread. The remaining threads will be granted access
only if the count reaches 0. This mutex cannot be shared between processes.
\item What are recursive mutexes good for ? Let's assume there are two
libraries, \texttt{A} and \texttt{B}. There is a library
function \texttt{A:foo()}, that will acquire a mutex and calls \texttt{B:bar()}
that can in turn call \texttt{A:bar()}, which will try to acquire the same
mutex. Without recursive locks a deadlock will ensue. With recursive mutexes
that's fine if these two calls are done by the same thread (another thread will
get blocked). That is, assuming \texttt{A:foo()} and \texttt{A:bar()} are aware
that the same thread can be already in the critical section.
\item \label{MUTEXTAB} The behavior according to mutex types:
shrnuje tabulka:\\
\\
\raisetab{
\begin{tabular}[t]{r|c|c|c|}
% \cline{2-4}
&\texttt{NORMAL}&\texttt{ERRORCHECK}&\texttt{RECURSIVE}\\
% \cline{2-4}
detects deadlock&N&Y&N/A\\
multi locking&deadlock&error&success\\
unlock by different thread&undefined&error&error\\
unlock unlocked&undefined&error&error\\
can be shared between processes&Y&Y&N
% \cline{2-4}
\end{tabular}}
\item Static mutex initialization using before mentioned macro will set default
attributes. It is possbile to use initializer function also for statically
allocated mutex. If a mutex is dynamically allocated, it is always necessary to
use \texttt{pthread\_mutex\_init}, even if the default attributes are desired or
not.
\item Dynamic mutexes are needed e.g. when a data structure which contains a
mutex protecting it, is dynamically allocated.
In such case before calling \texttt{free} with the data structure, it is first
necessary to properly destroy the mutex (that can also have some memory
allocated). Destroying locked mutex is not defined by the standard.
\item Copying mutexes is also not defined by the standard -- the result of such
operation depends on implementation. It is possible to copy pointer to mutex
and work with that.
\item Mutex destroy means its de-initialization.
\end{itemize}

%%%%%

\pdfbookmark[1]{pthread\_mutex\_lock, pthread\_mutex\_unlock,%
pthread\_mutex\_trylock}{pthreadmutexfncs}

\begin{slide}
\sltitle{Mutexes (2)}

\begin{itemize}
\item to lock and unlock mutex:
\end{itemize}

\texttt{int \funnm{pthread\_mutex\_lock}(pthread\_mutex\_t *\emph{mx});}
\linebreak
and
\linebreak
\texttt{int \funnm{pthread\_mutex\_unlock}(pthread\_mutex\_t *\emph{mx});}

\begin{itemize}
\item If a mutex is already locked, the attempt to acquire it will result on the
thread being locked (depending on mutex type).
It is possible to use:
\end{itemize}

\texttt{int \funnm{pthread\_mutex\_trylock}(pthread\_mutex\_t *\emph{mx});}

\begin{itemize}
\item[\dots] that will attempt to acquire the mutex and if that fails it will
return error
\end{itemize}
\end{slide}

\label{MUTEXES2}

\begin{itemize}
\item Locking a mutex that is being held by another thread is not correct.
Sometimes a (self)deadlock can ensue, see the previous page. If you need to
unlock a mutex locked by different thread, use binary semaphores instead.
\item When creating a program where effectivity is paramount, it is necessary to
think about how many mutexes will be needed and how exactly will be used.
Even a library that was not written with threads in mind can be converted to be
thread-safe (see page \pageref{THREADSAFE}) by inserting arbitrary function from
the library a lock will be acquired and released before the function exits.
Such locked can be called ``giant'' mutex, i.e. there will be lock contention
for every consumer of such library in given program. On the other hand, if using
many mutexes to synchronize access to concrete small sections, lots of time can
be spent in the functions implementing the locking. It is therefore desired to
search for a compromise. (Or use an algorithm that does not require locks at
all)
\item \label{MUTEX_RACE} Examples: \example{mutexes/race.c},
\example{mutexes/race-fixed.c}
\item Mutexes can be shared between processes so that their threads will
synchronize on them. This is done by using shared memory that will be set as an
attribute of such mutexes. See the
\texttt{pthread\_mutexattr\_setpshared} man page.
\end{itemize}


%%%%%

\begin{slide}
\sltitle{Conditional variables (1)}
\begin{itemize}
\item mutexes provide synchronization for shared data
\item conditional variables pass information about the shared data --
for example that the value has changed
\item \dots{}and allows to put threads to sleep and wake them up
\item therefore \emsl{each condition variable is always associated
with exactly one mutex}
\item one mutex can be associated with multiple conditional variables
\item using mutexes and conditional variables it is possible to construct
other synchronization primitives -- semaphores, barries, \dots
\end{itemize}
\end{slide}

\label{CONDITION_VARIABLES}

\begin{itemize}
\item in other words -- conditional variables are handy in situation when a 
thread needs to test the state of \emsl{shared} data (e.g. number of queues
in queue), and voluntarily put itself to sleep, when desired state has not
been reached. The sleeping thread is then woken up by another thread that
changed the state of the data, so the situation which the first thread was
waiting on actually happened (e.g. by inserting a item into queue).
The second thread wakes the first one by calling a designated function.
If no thread is sleeping at the moment, the function will have no effect --
nothing will be saved anywhere, like it never happened.
\item A condition variable, which is opaque type for the programmer, is not
associated with a concrete condition like ``\emph{\texttt{n} is greater than
7}''. Conditional variable can be in fact compared to a flag of certain color;
if it is lifted up, it means that the threads waiting for the flag to be waved
are informed (= woken up) and can use this information according its own
judgement. Some threads can wait for \texttt{n} to be bigger than 7, the other
can be waiting solely for \texttt{n} to change anyhow. It is only up to the
programmer, if for concrete situation uses just one condition variable or
for all situations. For the second situation, the threads waiting on 
\texttt{n == 7} have to always test \texttt{n}, because they know that they
are woken up whenever the variable changed. If the variable is not equal to 7,
it will voluntarily put itself to sleep. How it is explained further,
the \emsl{test is necessary to do after wake up}, even if dedicated conditional
variable is used -- it can happen that the system can wake up the sleeping
thread (because of various implementation reasons) without being caused by
another thread.
\end{itemize}

%%%%%

%%%%%

\pdfbookmark[1]{pthread\_cond\_init, pthread\_cond\_destroy,%
pthread\_cond\_wait}{pthreadcondvarfncs}

\begin{slide}
\sltitle{Conditional variables (2)}
\prgchars
\funml{int \funnm{pthread\_cond\_init}(\=pthread\_cond\_t *\emph{cond},
\\\>const pthread\_condattr\_t *\emph{attr});}
\begin{itemize}
\item initializes conditional variable \texttt{cond} with attributes \texttt{attr}
(they are set with the \texttt{pthread\_condattr\_...()} functions),
\texttt{NULL} = default.
\end{itemize}
\texttt{int \funnm{pthread\_cond\_destroy}(pthread\_cond\_t *\emph{cond});}
\begin{itemize}
\item destroys conditional variable.
\end{itemize}
\funml{int \funnm{pthread\_cond\_wait}(\=pthread\_cond\_t *\emph{cond},
\\\>pthread\_mutex\_t *\emph{mutex});}
\begin{itemize}
\item waits on conditional variable until another thread calls
\funnm{pthread\_cond\_signal()} or \funnm{pthread\_cond\_broadcast()}.
\end{itemize}
\end{slide}

\begin{itemize}
\item It is necessary to test the condition after the thread locks the mutex
and before the \texttt{pthread\_cond\_wait} is called. If the thread does not
peform this operation, it could be put to sleep indefinitely because the 
message from another thread about the condition changing could go ``unnoticed''.
In other words, a thread cannot enter sleep to wait for situation which happened
in the meantime. It does not work like signals which are ``held'' by the system
if they are blocked. It is important to perform this under the protection of
the mutex, to be sure what is the state of the data when calling
\texttt{pthread\_cond\_wait}.
\item The conditional variables API works thanks to the fact that when entering
critical section the mutex is locked by the thread and
\emsl{funkce \texttt{pthread\_cond\_wait} before putting the thread to sleep will
unlock the mutex}. Before exiting from the function the mutex is again locked.
It can therefore happen that the thread is woken while waiting on a conditional
variable and then sleeps again when waiting for the mutex.
There is nothing complicated about this, it is merely mutual exclusion of 
threads in critical section.
\end{itemize}

%%%%%

\pdfbookmark[1]{pthread\_cond\_signal, pthread\_cond\_broadcast,
pthread\_cond\_timedwait}{pthreadcondunblfncs}

\begin{slide}
\sltitle{Conditional variables (3)}
\prgchars
\texttt{int \funnm{pthread\_cond\_signal}(pthread\_cond\_t *\emph{cond});}
\begin{itemize}
\item wakes up one thread waiting on conditional variable
\texttt{cond}.
\end{itemize}
\texttt{int \funnm{pthread\_cond\_broadcast}(pthread\_cond\_t *\emph{cond});}
\begin{itemize}
\item wakes all threads waiting on conditional variable
\texttt{cond}.
\end{itemize}
\funml{int \funnm{pthread\_cond\_timedwait}(\=pthread\_cond\_t *\emph{cond}, 
\\\>pthread\_mutex\_t *\emph{mutex},\\\> const struct timespec *\emph{atime});}
\begin{itemize}
\item waits for \texttt{pthread\_cond\_signal()} or
\texttt{pthread\_cond\_broadcast()} or until the system time to reaches the
\texttt{atime} value.
\end{itemize}
\end{slide}

\begin{itemize}
\item one conditional variable can be used to announce multiple situations
at once -- e.g. when inserting or removal an item to/from a queue.
Because of this, it is necessary to test the condition the thread is waiting
for. Another consequence of this is that it is neccessary to use broadcast
in such situation. Let's assume that both readers and writers are waiting for
condition ``state of queue has changed''. If only single wakeup event is made
after item insertion to the queue, then another writer can be woken up,
which is however waiting for different event -- item removal. Thus, the message
will remain in the queue until a reader is woken up.
\item A thread can be woken up by another thread also in case when a condition
variable is associated with concrete event, which is no longer true after
the waiting thread is woken up.
Let's consider this situation: a thread signals a condition change and right
after that another thread locks the mutex and do an action which invalidates
the condition, e.g. removing a item from a queue when the event was
``there is a messages in the queue''. Thus the thread which is woken up
finds the queue empty. This is another reason why the condition variable
\emsl{always} has to be tested in a cycle.
\item It is also possible that a thread is woken up and the condition is not
true due to concrete implementation. That's another reason to use the cycle.
\item The \texttt{abstime} parameter of the \texttt{pthread\_cond\_timedwait}
function is absolute time, i.e. the timeout expires when system time reaches
the value greater or equal to \texttt{abstime}. The absolute time is used
so that it is not necessary to recompute the time difference after wakeups.
\end{itemize}

%%%%%

\begin{slide}
\label{CONDVAR_USE}
\sltitle{Using conditional variables}
\begin{alltt}
pthread\_cond\_t cond; pthread\_mutex\_t mutex;
...
\emprg{pthread\_mutex\_lock}(&mutex);
while (!condition(data))
    \emblue{pthread\_cond\_wait}(&cond, &mutex);
process\_data(data, ...);
\emprg{pthread\_mutex\_unlock}(&mutex);
...
\emprg{pthread\_mutex\_lock}(&mutex);
produce\_data(data, ...);
\emblue{pthread\_cond\_signal}(&cond);
\emprg{pthread\_mutex\_unlock}(&mutex);
\end{alltt}
\end{slide}

\begin{itemize}
\prgchars
\item The first piece of code is waiting for the condition to change.
If this happens, the data changed and can therefore be processed.
The second piece of code (executed in different thread) prepares the
data so it can be processed. Once ready, it will signal the consumer.
\item The \texttt{pthread\_cond\_wait} function will automatically unlock mutex
and put the thread to sleep. Once the thread is woken up, it will lock the
mutex first (this will be done by the condition variables implementation)
and only after that \texttt{pthread\_cond\_wait} will return.
\item When signalling that something has changed, it does not mean that after
the change the condition will be true. Moreover,
\texttt{pthread\_cond\_wait} can return even if no thread called
\texttt{pthread\_cond\_signal} or \texttt{pthread\_cond\_broadcast}.
This is another reason for testing the condition after wakeup and possibly
going to sleep again.
\item The mutex in the example above is unlocked only after the condition
was signalled however it is not necessary. The signalling can be done
after unlocking and in such case it can be more efficient (depending on
given implementation) because the thread that has been woken up will not
get blocked by the mutex which is held when signalling in critical section.
\item \label{QUEUESIMULATION} Example: \example{cond-variables/queue-simulation.c}
\end{itemize}


%%%%%

\pdfbookmark[1]{pthread\_rwlock\_init, pthread\_rwlock\_rdlock,%
pthread\_rwlock\_tryrdlock}{pthreadrwlockfncs}

\begin{slide}
\sltitle{Read-write locks (1)}
\prgchars
\funml{int \funnm{pthread\_rwlock\_init}(\=pthread\_rwlock\_t *\emph{l},
\\\>const pthread\_rwlockattr\_t *\emph{attr}); }
\begin{itemize}
\item creates a lock with attributes according to \texttt{attr}
(set via \texttt{pthread\_rwlockattr\_...()} functions, \emph{NULL} = default)
\end{itemize}
\texttt{int \funnm{pthread\_rwlock\_destroy}(pthread\_rwlock\_t *\emph{l});}
\begin{itemize}
\item destroys the mutex
\end{itemize}
\texttt{int \funnm{pthread\_rwlock\_rdlock}(pthread\_rwlock\_t *\emph{l});}\\
\texttt{int \funnm{pthread\_rwlock\_tryrdlock}(pthread\_rwlock\_t *\emph{rwlock});}
\begin{itemize}
\item acquires the lock for reading (more than one thread can hold the lock
for reading); if anyone holds the lock for writing, the calling thread is put
to sleep (\texttt{rdlock()}) or returns an error (\texttt{tryrdlock()}).
\end{itemize}
\end{slide}

\label{RWLOCKS}

\begin{itemize}
\item Not a part of POSIX threads from POSIX.1c, rather part of extension
POSIX.1j called ``advanced realtime extensions''.
\item More than one thread can hold the lock for reading or at most one
thread for writing (and no one for reading).
\item Read-write locks are semantically similar to locking files using
funkce \texttt{fcntl}.
\item It is common that given implementation prefers writer threads to
reader threads. E.g. if a lock is owned by writer and some other thread
calls \funnm{pthread\_rwlock\_rdlock} and there is at least one thread
waiting in \funnm{pthread\_rwlock\_wrlock}, the writer will be given 
precedence.
\item There is maximal count of locking operations in given implementation
(inferred from the type that holds the lock count). If the maximum is reached
\funnm{pthread\_rwlock\_rdlock} returns the \texttt{EAGAIN} error.
\end{itemize}


%%%%%

\pdfbookmark[1]{pthread\_rwlock\_wrlock, pthread\_rwlock\_trywrlock,%
pthread\_rwlock\_unlock}{pthreadrwlockfncsw}

\begin{slide}
\sltitle{Read-write locks (2)}
\prgchars
\texttt{int \funnm{pthread\_rwlock\_wrlock}(pthread\_rwlock\_t *\emph{rwlock});}
\begin{itemize}
\item acquires the lock for writing; Blocks if anyone owns the lock for reading
or writing.
\end{itemize}
\texttt{int \funnm{pthread\_rwlock\_trywrlock}(pthread\_rwlock\_t *\emph{rwlock});}
\begin{itemize}
\item like \texttt{pthread\_rwlock\_wrlock()}, however if the lock cannot be
acquired it will return error.
\end{itemize}
\texttt{int \funnm{pthread\_rwlock\_unlock}(pthread\_rwlock\_t *\emph{rwlock});}
\begin{itemize}
\item unlocks the lock
\end{itemize}
\end{slide}

\begin{itemize}
\item \emph{Interesting property}: if a thread waiting on a lock receives
a signal, the signal handler will be invoked and then it will transparently
continue waiting, i.e. there will be no error \texttt{EINTR}.
The same is true for mutexes and condition variables.
\end{itemize}

%%%%%

\pdfbookmark[1]{atomic\_add}{atomicadd}

\begin{slide}
\sltitle{Atomické aritmetické operace}
\begin{itemize}
\item pro architektury, kde operace sèítání není atomická
\item výraznì rychlej¹í ne¾ jiné mechanismy pro získání exkluzivního pøístupu
díky pou¾ití instrukcí na dané platformì zaji¹»ujících atomicitu.
\item nìkteré systémy dodávají funkce pro atomické operace,
(napø. \texttt{atomic\_add(3c)} v Solarisu), obecnì je lep¹í pou¾ít
podporu v C11 standardu pøes \emph{stdatomic.h}.
\item sada volání pro rùzné typy a operace, napø. sèítání:
\end{itemize}
\begin{verbatim}
    #include <stdatomic.h>

    atomic_int acnt;
    atomic_fetch_add(&acnt, 1);
\end{verbatim}
\end{slide}

\begin{itemize}
\item \label{ATOMIC_ADD} Pøíklad \example{race/atomic-add.c} demonstruje
problém se soubìhem pøi sèítání a jeho mo¾ná øe¹ení. Program spustí dvì
vlákna, ka¾dé vlákno pracuje se stejnou globální promìnnou \emsl{x}, do
které v cyklu postupnì pøiète èísla od jedné do velikosti parametru
\emsl{arg}, který program dostane na pøíkazové øádce. Vlákna bì¾í paralelnì,
ka¾dé z nich provádí toto:

\begin{verbatim}
for (i = 1; i < arg; ++i)
        x = x + i;
\end{verbatim}

Poté se sèítání pro kontrolu provede v hlavním vláknu, a dvojnásobek (mìli
jsme dva thready) se porovná s hodnotou globální promìnné \emsl{x}. Pokud
nejsou výsledky stejné, do¹lo k soubìhu (pøeteèení promìnné mù¾eme v této
situaci zcela ignorovat).
\par
Výsledky a èasy bìhu se markantnì li¹í pro situace, kdy program pou¾il
obyèejné sèítání, funkci pro atomickou aritmetiku a zamykání pomocí
mutexù. Je vidìt nìkolikanásobný rozdíl v dobì bìhu mezi pou¾itím
funkce pro atomickou aritmetiku a mutexù, zejména na procesorech hardwarovou
podporou paralelismu.
\item Podobnì existují dal¹í atomické rutiny pro odeèítání, bitové operace
AND a OR, pro pøiøazení hodnoty atd.
\end{itemize}


%%%%%

\pdfbookmark[1]{pthread\_barrier\_init, pthread\_barrier\_wait,%
pthread\_barrier\_destroy}{bariera}

\begin{slide}
\sltitle{Bariéra}
\begin{itemize}
\item bariéra (\emph{barrier}) je zpùsob, jak udr¾et èleny skupiny pohromadì
\item v¹echna vlákna èekají na bariéøe, dokud ji nedosáhne poslední vlákno; pak
mohou pokraèovat
\item typické pou¾ití je paralelní zpracování dat
\end{itemize}
\texttt{int \funnm{pthread\_barrier\_init}(pthread\_barrier\_t *\emph{barrier},
\emph{attr}, unsigned \emph{count});}
\begin{itemize}
\item inicializuje bariéru pro \emph{count} vstupù do ní
\end{itemize}
\texttt{int \funnm{pthread\_barrier\_wait}(pthread\_barrier\_t *\emph{barrier});}
\begin{itemize}
\item zablokuje se dokud není zavolána \emph{count}-krát
\end{itemize}
\texttt{int \funnm{pthread\_barrier\_destroy}(pthread\_barrier\_t *\emph{barrier});}
\begin{itemize}
\item zru¹í bariéru
\end{itemize}
\end{slide}

\label{BARRIER}

\begin{itemize}
\item API pro bariéry je definované od SUSv3, podívejte se napøíklad na
\texttt{pthread\_\-barrier\_init}, je mo¾né je ale jednodu¹e vytvoøit pomocí
mutexù a pod\-mín\-ko\-vých promìnných.
\item Pozor na to, ¾e bariéry jsou nepovinnou èástí POSIXu (patøí do
Advanced realtime threads) a tedy i systém certifikovaný na SUS je nemusí
implementovat, co¾ je pøípad Mac OS X (10.10).
\item bariéru mù¾ete vyu¾ít napø. v situaci, kdy mezi jednotlivými fázemi
zpracování je potøeba provést jistou inicializaci, vlákna pøed ní tedy na sebe
v¾dy musí poèkat, proto¾e inicializace dal¹í fáze mù¾e zaèít a¾ tehdy, kdy
skonèí fáze pøedchozí. Pøíklad \example{pthreads/pthread-barrier.c} ukazuje
pou¾ití ba\-ri\-éry pro nìkolik fází zpracování dat.
\item podmínka pro bariéru je napøíklad hodnota èítaèe rovnající se nule. Ka¾dé
vlákno, které dosáhne bariéry, sní¾í èítaè, který je na zaèátku inicializován na
poèet vláken. Pokud vlákno po dekrementování èítaèe zjistí, ¾e je¹tì není roven
nule, uspí se na podmínkové promìnné.  Pokud dané vlákno je tím vláknem, které
sní¾í èítaè na nulu, místo zavolání \texttt{pthread\_cond\_wait} po¹le
broadcast, který následnì probudí v¹echna vlákna spící na bariéøe
(\texttt{pthread\_cond\_signal} zde nestaèí, chcete probudit v¹echna vlákna, ne
jen jedno!). Pøed spu¹tìním dal¹í fáze zpracování se èítaè reinicializuje na
pùvodní hodnotu. I zde je nutné øe¹it rùzné problémy, napøíklad není mo¾né jen
tak reinicializovat èítaè poté, co bariéry dosáhne poslední vlákno, proto¾e jak
ji¾ víme, vlákna po probuzení z \texttt{pthread\_cond\_wait} musí v¾dy
otestovat, zda èítaè je opravdu nulový a pokud není, opìt se uspí. Tak¾e by se
vám mohlo stát, ¾e by se probudila jen nìkterá vlákna, nebo taky ¾ádná. Je nutné
zresetovat èítaè a¾ po probuzení posledního vlákna. Jak byste to øe¹ili?
\end{itemize}


%%%%%

\pdfbookmark[1]{sem\_init, sem\_post, sem\_wait}{semafory}

\begin{slide}
\sltitle{POSIX Semaphores}
\begin{itemize}
\item semafory pochází z POSIX-1003.1b (real-time extensions)
\item jména funkcí nezaèínají \emsl{pthread\_}, ale \emsl{sem\_}
(\texttt{sem\_init}, \texttt{sem\_post}, \texttt{sem\_wait}, \dots)
\item je mo¾né je pou¾ít s vlákny
\end{itemize}
\end{slide}

\begin{itemize}
\item funkce pro semafory se dr¾í klasické UNIXové sémantiky -- pøi
chybì vracejí -1 a nastaví \texttt{errno}
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Typické pou¾ití vláken}

\begin{itemize}
\item \emsl{pipeline}
\begin{itemize}
\item ka¾dé z vláken provádí svoji operaci nad daty, která se
postupnì pøedávají mezi vlákny
\item ka¾dé vlákno typicky provádí jinou operaci
\item[\dots] zpracování obrázku, kde ka¾dé vlákno provede jiný filtr
\end{itemize}

\item \emsl{work crew}
\begin{itemize}
\item vlákna provádìjí stejnou operaci, ale nad jinými daty
\item[\dots] zpracování obrázku dekompozicí -- ka¾dé vlákno
zpracovává jinou èást obrázku, výsledkem je spojení zpracovaných dat
ze v¹ech vláken; zde se hodí øe¹ení s bariérou
\end{itemize}

\item \emsl{client -- server}
\end{itemize}
\end{slide}

\begin{itemize}
\item dané rozdìl{}ení je jen orientaèní, pou¾ití vláken je samozøejmì
neomezené, toto jsou asi ty tøi nejèastìj¹í pou¾ití
\item V pøípadì modelu klient -- server zpracovává ka¾dé vlákno jeden
po¾adavek od jednoho klienta.
\end{itemize}

%%%%%

\pdfbookmark[1]{thread-safe a reentrant functions}{thrsafe}

\begin{slide}
\sltitle{Thread-safe versus reentrantní}

\begin{itemize}
\item \emph{thead-safe} znamená, ¾e kód mù¾e být volán z více vláken
najednou bez destruktivních následkù
\begin{itemize}
\item do funkce, která nebyla navr¾ena jako thread-safe, je mo¾né
pøidat jeden zámek -- na zaèátku funkce se zamkne, na konci odemkne
\item tento zpùsob ale samozøejmì není pøíli¹ efektivní
\end{itemize}
\item slovem \emph{reentrantní} se typicky myslí, ¾e daná funkce byla navr¾ena s
pøihlédnutím na existenci vláken
\begin{itemize}
\item \dots{}tedy ¾e funkce pracuje efektivnì i ve vícevláknovém
prostøedí
\item taková funkce by se mìla vyvarovat pou¾ití statických dat a pokud mo¾no i
prostøedkù pro synchronizaci vláken, proto¾e bìh aplikace zpomalují
\end{itemize}
\end{itemize}
\end{slide}

\label{THREADSAFE}

\begin{itemize}
\item z vý¹e uvedeného vyplývá, ¾e thread-safe je slab¹í vlastnost ne¾
reentrantní. Napsat thread-safe funkci lze s pou¾itím synchronizaèních
primitiv; pøepsání existující funkci tak, aby byla reentrantní
vy¾aduje mnohem více invence.
\item reentrantní funkce jsou také jediné funkce bezpeènì pou¾itelné v
signal handlerech.
\item v dne¹ní dobì thread-safe vìt¹inou znamená reentrantní, tj. funkce jsou
pøe\-psá\-ny tak, aby pracovaly efektivnì i s vlákny, je ale dobré vìdìt, ¾e
nìkdy to mù¾e vyjadøovat rozdíl.
\item o zamykání knihoven viz také strana \pageref{MUTEXES2}.
\item existuje mno¾ství funkcí, které mohou být thread-safe, ale nikoliv
reentrant, napø. \texttt{gethostbyname}. Bì¾nì tato funkce pou¾ívá
statickou promìnnou, která se znovu pou¾ije pøi ka¾dém volání, tak¾e je
pro pou¾ití v multithreadovém prostøedí nevhodné - není thread-safe.
Nicménì, na FreeBSD 6.0 je tato funkce implementovaná tak, ¾e pou¾ívá
implicitnì thread-local storage pro ulo¾ení výstupních dat a
tím pádem je thread safe. To ji je¹tì ale neèiní úplnì bezpeènou k
pou¾ití (nemluvì o tom, ¾e program , který se spoléhá na takové chování
není portabilní), viz pøíklad \example{reentrant/gethostbyname.c}. O nìco
lep¹í je pou¾ít reentrantní verzi této funkce \texttt{gethostbyname\_r}
(pokud je na daném systému k dispozici), u které lze specifikovat adresu,
kam má ukládat svùj výstup, èím¾ se stává reentrantní. Daleko nejlep¹í
øe¹ení je pou¾ít standardní funkci \texttt{getaddrinfo} (viz strana
\pageref{GETADDRINFO}), která je sama o sobì reentrantní.


\item pøíklad: \example{reentrant/inet\_ntoa.c} - tady je vidìt, ¾e ani
takto napsaná funkce vám nepomù¾e pokud je volaná dvakrát v rámci
jednoho volání \texttt{printf}. Poka¾dé vrací pointer se stejnou adresou
(v jednom threadu), kterou si \texttt{printf} pouze poznamená a pøi
finálním tisku tedy vypí¹e reprezentaci poslední adresy, se kterou byla
\texttt{inet\_ntoa} volána. Na Solarisu je to vidìt pomocí:
\begin{verbatim}
truss -t\!all -u libnsl::inet_ntoa ./a.out
\end{verbatim}
\item Na Solarisu obsahují manuálové stránky knihovních funkcí polo¾ku
\texttt{MT-level} v sekci \texttt{ATTRIBUTES}, která udává zda je mo¾né
funkci pou¾ít v multithreadovém prostøedí a pøípadnì s jakými omezeními.
Tyto úrovnì jsou popsány v manuálové stránce attributes(5).
\end{itemize}

%%%%%

\pdfbookmark[1]{pthread\_set\_name\_np, pthread\_main\_np}{threadnpapis}

\begin{slide}
\sltitle{Nepøenositelná volání}

\begin{itemize}
\item nepøenositelná volání konèí øetìzcem \texttt{\_np} (\emph{non-portable}) a
jednotlivé systémy si takto definují vlastní volání

\item FreeBSD
\begin{itemize}
\item \funnm{pthread\_set\_name\_np}\texttt{(pthread\_t tid, const char *name)}
\item[$\rightarrow$] umo¾òuje pojmenovat vlákno
\end{itemize}

\item Solaris
\begin{itemize}
\item \funnm{pthread\_cond\_reltimedwait\_np}\texttt{(\dots)}
\item[$\rightarrow$] jako timedwait, ale èasový timeout je relativní
\end{itemize}

\item OpenBSD
\begin{itemize}
\item \texttt{int} \funnm{pthread\_main\_np}\texttt{(void)}
\item[$\rightarrow$] umo¾òuje zjistit, zda volající vlákno je hlavní
(= \texttt{main()})
\end{itemize}

\end{itemize}
\end{slide}

\begin{itemize}
\item Tyto informace jsou pro zajímavost, abyste vìdìli, ¾e se s podobnými vìcmi
mù¾ete setkat. Nepøenositelná volání by se mìla pou¾ívat spí¹e pro ladící úèely.
Nikdy nevíte, kdo bude potøebovat vá¹ kód spustit na jiném systému, co¾ se stane
typicky a neèekanì po té, co zrovna opustíte va¹i spoleènost a nemáte ji¾ èas to
opravit.
\item Zjistit, jaká nepøenositelná volání vá¹ systém poskytuje je jednoduché,
tøeba pomocí \texttt{apropos \_np}, nebo o nìco hrubìji (aplikujte na svùj
systém podle lokace manuálových stránek):
\begin{verbatim}
$ cd /usr/share/man
$ find . -name '*_np\.*'
./man3c/mq_reltimedreceive_np.3c
./man3c/mq_reltimedsend_np.3c
./man3c/posix_spawnattr_getsigignore_np.3c
./man3c/posix_spawnattr_setsigignore_np.3c
./man3c/pthread_cond_reltimedwait_np.3c
./man3c/pthread_key_create_once_np.3c
./man3c/pthread_mutex_reltimedlock_np.3c
./man3c/pthread_rwlock_reltimedrdlock_np.3c
./man3c/pthread_rwlock_reltimedwrlock_np.3c
./man3c/sem_reltimedwait_np.3c
\end{verbatim}
\end{itemize}

\pagebreak

\endinput
