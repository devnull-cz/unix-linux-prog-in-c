
changequote([[[, ]]])

\pagebreak
\pdfbookmark[0]{network programming}{site}

\begin{slide}
\sltitle{Contents}
\slidecontents{7}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\label{NETWORKING}

\begin{slide}
\sltitle{Network communication}
\begin{description}
\item[UUCP (UNIX-to-UNIX Copy Program)] -- first application for communication
between UNIX systems connected directly or via modems, in Version~7 UNIX (1978)
\item[sokety (sockets)] -- introduced in 4.1aBSD (1982); socket is one end of a
bidirectional communication channel created between two processes either on the
same computer or across a network.
\item[TLI (Transport Layer Interface)] -- SVR3 (1987); API providing network
communication within the 4th layer of ISO OSI.  Counterpart to the BSD sockets
API.
\item[RPC (Remote Procedure Call)] -- SunOS (1984); provides access to services
running on a remote machine, data transfered in XDR format (External Data
Representation)
\end{description}
\end{slide}

\begin{itemize}
\item There are two main conceptual models for network communication.  ISO
(International Standards Organization) OSI (Open Systems Interconnect), and the
Internet protocol suite (also called TCP/IP).   Each one defines several layers.
If we oversimplify, ISO OSI is very formal, quite complex, has 7 layers, and its
specification is not freely available, while TCP/IP is simpler, not that formal,
with 4 layers, and the specification is freely available via RFCs.  While the
layers of the two models cannot be precisely mapped onto each other, the
corresponding layers are roughly as follows:

\vspace{1.5mm}

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{|l|l|}\hline
ISO OSI & TCP/IP\\
\hline
\hline
application & application\\
presentation & \\
session & \\
\hline
transport & transport\\
\hline
network & internet\\
\hline
link & link\\
physical & \\
\hline
\end{tabular}
\renewcommand{\arraystretch}{1}

\vspace{1.5mm}

We will be working exclusively with the TCP/IP model.

\item UUCP is a historical thing, fully implemented in userland without any
kernel support.  See the \texttt{uucp} man page or Wikipedia for more
information.
\item RPC is implemented as a library linked to applications, uses sockets
and works on top of TCP and UDP.  RPC was developed as a communication protocol
for the \emph{Network Filesystem} (NFS).  There are several mutually
incompatible RPC implementations.
\item TLI is designed from an OSI model-oriented viewpoint, and it corresponds
to the 4th layer -- transport.  TLI API looks similar to sockets.
\item Sockets for communication within the same host are in the
\texttt{AF\_UNIX} domain and their names correspond to special files that
represent the sockets in the filesystem.  \texttt{ls -F} uses the equal sign
``='' to mark a Unix domain socket.
\item Sockets in \texttt{AF\_UNIX} are different from local TCP/IP communication
over the looopback interface \texttt{localhost} (\texttt{127.0.0.1}).  See page
\pageref{SOCKET} for more information on \texttt{AF\_UNIX}.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{TCP/IP basics}
\begin{itemize}
\item protocols
    \begin{itemize}
    \item \emsl{IP (Internet Protocol)} -- principal communications protocol,
    not accessible for a non-privileged user
    \item \emsl{TCP (Transmission Control Protocol)} -- reliable, ordered, and
    error-checked delivery of a stream of bytes
    \item \emsl{UDP (User Datagram Protocol)} -- datagram, connectionless,
    unreliable
    \end{itemize}
\item \emsl{IP address} -- 4 bytes (IPv4) / 16 bytes (IPv6), defines a network
interface, not a computer
\item \emsl{port} -- 2 bytes, application end-points on a host
\item \emsl{DNS (Domain Name System)} --  translates domain names to the
numerical IP addresses 
\end{itemize}
\end{slide}

\begin{itemize}
\item Unix mostly uses protocols from the TCP/IP family.  We will cover TCP and
UDP.  In both protocols, one end of a communication channel is identified by an
IP address and a port.  Those two pieces correspond to a socket.  A TCP
connection is uniquely identified by a pair of sockets.
\item Ports below 1024 are reserved and additional privileges are needed to use
them.  For example, \emph{root} can access those.  See \texttt{/etc/services}
for the textual database of port numbers and corresponding service names.
\item To learn about networking and the Internet in general, we very much
recommend networking lectures by Ji\v{r}\'{i} Peterka.  You can either
attend them at MFF~UK or you can find those online.
\item \emph{IP} -- protocol of the internet layer within the TCP/IP network
stack, provides data transfer between two interfaces identified by an IP
address.  It is unreliable.  Provides routing and fragmentation.  Defined in
RFC~791.  The Internet Control Message Protocol (ICMP), defined in RFC~792, is
an inherent part of the IP protocol.
\item \emph{UDP} -- a simple extension of the IP protocol, only adds protocol
numbers.  Still unreliable and datagram oriented.  Defined in RFC~768.
\item \emph{TCP} -- establishes connections between two points (sockets).
Provides a continuous stream of data, congestion control and reliable
delivery.  To create a connection, a so called \emph{handshake} must be
performed.  The protocol is defined in RFC~793 and other follow-up RFCs.
\item \emph{DNS} -- hieararchicaly organized database, its structure does not
have to follow the IP address structure.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Connection-oriented (TCP), sequential service}
\input{img/tex/tcp_seq.tex}
\end{slide}

\begin{itemize}
\item Note that common \funnm{read}() a \funnm{write}() calls are used.  To
keep the picture readable, all arguments aside from a descriptor \emph{fd} were
intentionally omitted.
\item The server creates one connection and does not accept a new one until the
previous connection finished.  That is why it is called a sequential service.
\item System calls used:
\begin{itemize}
\item \funnm{socket}() -- creates a socket, returns its descriptor.

\item \funnm{bind}() -- binds an IP address and a port number with the socket.
In other words, it assigns a name to an unnamed socket.  The address must be
either one of IP addresses assigned to one of the host network interfaces (the
host where the socket was created), in which case it will only accept connection
requests over that specific interface via that specific IP address, or it can be
a special value \texttt{INADDR\_ANY} (for so called \emph{wildcard sockets},
denoting the connection will be accepted on any IP address on any interface of
the host.
\item \funnm{listen}() -- tells the kernel to start listening on connection
requests on the socket.
\item \funnm{accept}() -- blocks the process until there is a connection
request, then creates the connection and returns a \emsl{new} descriptor which
is used for communicating with the client.  The original socket descriptor can
be used for another \funnm{accept}() call to serve a new connection request from
another client.
\item \funnm{close}() -- closes the connection.
\item \funnm{connect}() -- the client asks to create a connection.  The IP
address and a port number are passed as arguments (omitted in the picture), the
communication is performed through an already existing socket descriptor
\emph{fd}.  In contrast to \funnm{accept}(), a new file descriptor is not
created.
\end{itemize}
\end{itemize}

%%%%%

\pdfbookmark[1]{socket}{socket}

\begin{slide}
\sltitle{Creating a socket: \texttt{socket()}}
\setlength{\baselineskip}{0.9\baselineskip}
\texttt{int \funnm{socket}(int \emph{domain}, int \emph{type},
int \emph{protocol});}
\begin{itemize}
\item creates a socket, returns its descriptor
\item \emph{domain} -- ,,where the communication will take place'': 
    \begin{itemize}
    \item \texttt{AF\_UNIX} \dots{} local communication within a host, its
    address is a filename.  Also \texttt{AF\_LOCAL}.
    \item \texttt{AF\_INET}, \texttt{AF\_INET6} \dots{} internet communication,
    the address is an IP address and port pair
    \end{itemize}
\item \emph{type}:
    \begin{itemize}
    \item \texttt{SOCK\_STREAM} \dots{} connection-oriented reliable service,
    provides bidirectional data stream
    \item \texttt{SOCK\_DGRAM} \dots{} connectionless unreliable service,
    transmits datagram
    \end{itemize}
\item \emph{protocol}: \texttt{0} (default for a given \emph{type})
or a valid protocol number (eg. \texttt{6}~=~TCP, \texttt{17}~=~UDP)
\end{itemize}
\end{slide}

\label{SOCKET}

\begin{itemize}
\item Function is declared in \texttt{<sys/socket.h>} as well as other network
related functions from the previous slide.
\item Sockets use the same name space as file descriptors, ie. the same
descriptor table.  If you write a simple program that only calls
\funnm{socket}(), it will return 3 as that will be the first available slot in
the descriptor table.
\item Connection-oriented communication is always bidirectional and is similar
to pipes.  However, note that pipes may not be bidirectional, see page
\pageref{TWO_WAY_PIPES}.
\item Sometimes you can see constants beginning with \verb#PF_# (meaning
\emph{protocol family}, eg. \texttt{PF\_IN\-ET}, \verb#PF_UNIX#, or
\texttt{PF\_IN\-ET6}) and used in a \funnm{socket}() call. Constants \verb#AF_#
(\emph{address family}) are then used only for naming the sockets.  While it
might make a better sense, the UNIX specification only defines \verb#AF_#
constants.  And if \verb#PF_# constants exist on a system, they are defined via
corresponding \verb#AF_# constants.  We do recommend to use only \verb#AF_#
constants.
\item There are other domains, see the \texttt{socket(2)} manual page.
\item There are also other socket types, for example \texttt{SOCK\_RAW}, for
full protocol access. In order to use \texttt{SOCK\_RAW} you usually need
additional privileges.  That is a reason why a command \texttt{ping}, which
works with ICMP headers of sent packets, might need an SUID privilege:

\begin{verbatim}
$ ls -l /usr/sbin/ping
-r-sr-xr-x   1 root  bin  55680 Nov 14 19:01 /usr/sbin/ping
\end{verbatim}
\end{itemize}

%%%%%

\pdfbookmark[1]{bind}{bind}

\begin{slide}
\sltitle{Naming the socket: \texttt{bind()}}
\funml{int \funnm{bind}(\=int \emph{socket},
const struct sockaddr *\emph{address}, \\\>socklen\_t \emph{address\_len});}
\begin{itemize}
\item binds a \emph{socket} with an address
\item \texttt{struct sockaddr} is universal and not used to fill out the address
    \begin{itemize}
    \item \texttt{sa\_family\_t \emph{sa\_family}} \dots{} domain
    \item \texttt{char \emph{sa\_data}[]} \dots{} address
    \end{itemize}
\item for \texttt{AF\_INET}, \texttt{struct sockaddr\_in} is used:
    \begin{itemize}
    \item \texttt{sa\_family\_t \emph{sin\_family}} \dots{} domain
    (\texttt{AF\_INET}) 
    \item \texttt{in\_port\_t \emph{sin\_port}} \dots{} port number (16 bits) 
    \item \texttt{struct in\_addr \emph{sin\_addr}} \dots{} IP address (32 bits)
    \item \texttt{unsigned char \emph{sin\_zero}[8]} \dots padding
    \end{itemize}
\end{itemize}
\end{slide}

\begin{itemize}
\item \funnm{bind}() assigns a socket its source address for packets being sent
to the other side of the connection which is also the destination address for
data received.  The remote address is set via \funnm{connect}().

\item Structure \texttt{sockaddr} is a universal type used by a kernel.  For
setting addresses based on a specific domain one has to use concrete structures
per domain, see the next slide.  Those specific structures need to be casted to
the universal structure as that is the type required by the \funnm{bind}()
function, for example.  However, it is not recommended to use those structures
as the program will only work for one specific address family -- we will do it
here to show you how it works though.  However, you can use helper functions
that convert names to addresses with no need to work those structures directly.
See \funnm{getaddrinfo}() on page \pageref{GETADDRINF} for more information.
\item You will also need other header files, see the example on page
\pageref{BIND_EXAMPLE}.
\item For domains \texttt{AF\_INET} and \texttt{AF\_INET6}, you can use a
special address that stands for any address on a given host.  Such a socket can
be used to accept connections on any IP address assigned to any interface on the
host.  That address is:
\begin{itemize}
\item For \texttt{AF\_INET}, use \texttt{INADDR\_ANY} (4 zero
bytes corresponding to \texttt{0.0.0.0})
\item With \texttt{AF\_INET6} the situation is more complicated.  You can either
use a constant variable \texttt{in6addr\_any} or a constant
\texttt{IN6ADDR\_ANY\_INIT}.  How\-ever, the constant can be only used to
initialize variables of type \texttt{struct in6\_addr}, not for any assignment.
Both values correspond to \texttt{::} (16 zero bytes).
\end{itemize}
\item You cannot bind the same address to multiple sockets.

\item If \funnm{bind}() is not called, the kernel will assign one of available
ports and the primary IP address on the interface through which the destination
can be accessed.  In general, as a client, you do not need a specific outgoing
port so \funnm{bind}() is usually not needed and the call is typically used only
by servers as they need a specific port number to be contacted (eg. 443 for
HTTPS).  Note that some legacy services though, eg. \texttt{rsh}, require the
client to connect from a privileged port (0-1023).  Such a client must call
\funnm{bind}() to use such a port and also have enough privileges to do that.
\item \emsl{The address and port must always use network byte ordering.} See
page \pageref{BYTE_ORDERING} where different byte orderings were explained.
More information is on page \pageref{HTON}.
\end{itemize}

%%%%%

\pdfbookmark[1]{struct sockaddr\_in}{sockaddrin}

\begin{slide}
\sltitle{Structure for IPv4 addresses}

\begin{itemize}
\item each address family has its structure and a header file
\item the structure is in \funnm{bind}() casted to \texttt{struct sockaddr}
\end{itemize}

\begin{verbatim}

#include <netinet/in.h>
struct sockaddr_in in = { 0 }; /* IPv4 */

in.sin_family = AF_INET;
in.sin_port = htons(2222);
in.sin_addr.s_addr = htonl(INADDR_ANY);

if (bind(s, (struct sockaddr *)&in, sizeof (in)) == -1) ...
\end{verbatim}
\end{slide}

\label{BIND_EXAMPLE}

\begin{itemize}
\item As already mentioned, such code is for demonstration purposes only.
Unless really needed, you should not write code like this but rather use generic
functions for converting names to addresses in which case you do not need to
worry about address families.  Most networking applications are assumed to work
with both IPv4 and IPv6.
\item \texttt{sin\_addr} is a structure itself, of type \texttt{in\_addr}.  That
structure must have at least one member, \texttt{s\_addr} whose type must be
equivalent to a 4 byte integer.  That comes directly for the UNIX specification
for \texttt{netinet/in.h}.
\item Working with \texttt{sockaddr\_in6} is a bit more complicated.  It is in
\texttt{netinet/in.h}, either defined in there directly or the file includes
\texttt{netinet6/in6.h} with the structure definition.
\item We repeat again as it is important -- for both \texttt{AF\_INET} and
\texttt{AF\_INET6}, the port and address must be in the network byte ordering,
see page \pageref{HTON}.
\item As \texttt{INADDR\_ANY} is defined as \texttt{0}, you may see its use
without \funnm{htonl}() (see page \pageref{HTON} for more information on the
function).  Never do it that way.  Next time you put an IP address there, you
may forget to add \funnm{htonl}() and you are going to run into some issues
right away.  And again, if you write code agnostic to specific address families,
you do not need to worry about network byte ordering for addresses and ports
whatsoever.
\item In the \texttt{AF\_UNIX} domain, \texttt{struct
sockaddr\_un} is used, defined in \texttt{<sys/un.h>}:
\begin{itemize}
\item \texttt{sa\_family\_t \emph{sun\_family}} \dots{} domain
\item \texttt{char \emph{sun\_path}[]} \dots{} socket name
\item The size of \emph{sun\_path} has intentionally been left undefined in the
UNIX specification. This is because different implementations use different
sizes.  For example, 4.3~BSD uses a size of 108, and 4.4~BSD uses a size of 104.
Since most implementations originate from BSD versions, the size is typically in
the range 92 to 108.
\end{itemize}
\end{itemize}

%%%%%

\pdfbookmark[1]{listen}{listen}

\begin{slide}
\sltitle{Waiting for connection: \texttt{listen()}}
\texttt{int \funnm{listen}(int \emph{socket}, int \emph{backlog});}
\begin{itemize}
\item specifies willingness to accept incoming connections on \emph{socket}, and
the system starts listening
\item maximum of \emph{backlog} connection requests may wait in the queue to
be served
\item connection requests that do not fit the queue are refused
(\funnm{connect}() returns an error on the other side). 
\item the system waits for a connection on an address previously assigned by
\funnm{bind}()
\end{itemize}
\end{slide}

\begin{itemize}
\item The system may silently adjust \emph{backlog} if it is not in a supported
range.
\item Wildcard sockets are primarily used for servers.  If you need to
distinguish between interfaces, you need a socket per an IP address.  This used
to be used for web servers that distinguished virtual servers based on the IP
address.  However, that is remote past.  To distinguish between virtual servers
running on the same host, a HTTP header \uv{\texttt{Host:}} is used.  Similarly,
the TLS protocol uses \texttt{ServerName}.
\item The fact that the system starts listening on a port means that a TCP
handshake is performed and data is being accepted.  The data is stored
in a fixed length buffer and after it is filled out, the connection is still
active but the TCP window is set to 0 which means the system stopped accepting
further data.  The buffer size is usually a few tens of kilobytes.
\label{UP_TO_LISTEN_ONLY_C} Example: \example{tcp/up-to-listen-only.c}.
\item The example code uses macro \texttt{SOMAXCONN}, required by the UNIX
specification to be in \texttt{sys/socket.h}.  It specifies the maximum queue
length for \funnm{listen}().  As far as we know, Linux, FreeBSD, macOS and
Solaris use value of 128.
\end{itemize}

%%%%%

\pdfbookmark[1]{accept}{accept}

\begin{slide}
\sltitle{Accepting connection: \texttt{accept()}}
\funml{int \funnm{accept}(\=int \emph{socket}, struct sockaddr *\emph{address},
\\\>socklen\_t *\emph{address\_len});}
\begin{itemize}
\item creates a connection between the local, already listening \texttt{socket}
and a remote end
\item returns a new socket descriptor that can be used to communicate with the
remote process.  Original socket can be used to accept another connection.
\item returns a remote IP address/port in \emph{address} unless NULL
\item \emph{*address\_len} is a size of the \emph{address} structure, is updated
with its real size on return
\end{itemize}
\end{slide}

\label{ACCEPT}

\begin{itemize}
\item The ``remote end'' is the socket on which a \funnm{connect}() is
called on a remote Unix host, or it could be possibly something else on other
systems.  Remember that protocols and APIs are two different things.
\item The newly created socket has the same characteristics as \emph{socket}.
For example, if \emph{socket} was non-blocking, the new socket is non-blocking
as well.
\item If more clients running on the same host connect to the same server (ie.
using the same IP address and port), individual connections are distinguished
only by the client side port number.  Do remember that a TCP connection is
uniquely identified by two sockets, ie. ``((addr1, port1), (addr2, port2)).''
\item The \emph{address} may be \texttt{NULL} which means the caller is not
interested in the remote end address.  In that case, \emph{address\_len} should
be \texttt{NULL} as well.
\item If the code is written to be independent of an address family, it should
use \texttt{struct sockaddr\_storage} for \emph{address}.  Any specific address
struct is guaranteed to fit in \texttt{struct sockaddr\_storage}, ie. either
\texttt{struct sockaddr\_in} or \texttt{struct sockaddr\_in6}.  Also see page
\pageref{TCPCLNTEXAMPLE}.
\item \label{TCP_SINK_SERVER_C} Example: \example{tcp/tcp-sink-server.c}
\end{itemize}

\pdfbookmark[1]{connect}{connect}

\begin{slide}
\sltitle{Initiating a connection: \texttt{connect()}}
\funml{int \funnm{connect}(\=int \emph{sock}, struct sockaddr *\emph{address},
\\\>socklen\_t \texttt{address\_len});}
\begin{itemize}
\item attempts to make a connection to a remote socket waiting on \emph{address}
(of \emph{address\_len} length) 
\item if \emph{sock} was not bound before, the kernel will assign an available
local address based on the chosen address family
\item you should close \emph{sock} on a connection failure
\end{itemize}
\end{slide}

\label{CONNECT}

\begin{itemize}
\item As the UNIX specification does not say anything about the socket state
after a connection failure, you should definitely close \emph{sock} before
moving on to create a new socket and trying again.
\item After the connection is created, both the server and client can use normal
\funnm{read}() and \funnm{write}() calls, or \funnm{send}(), \funnm{recv},
\funnm{sendmsg}(), and \funnm{recvmsg}().  Behavior of the functions is similar
as if working with pipes.
\item Example: \label{CONNECT_C} \example{tcp/connect.c}
\item \label{CONNECT_FOR_UDP} For connection-less services (UDP),
\funnm{connect}() may be used as well.  However, it will only set the remote
address so that \funnm{send}() and \funnm{recv}() which do not have a remote
address parameter can be used.
\item We may also call \funnm{connect}() multiple times for a connection-less
service in which case each call sets the remote address again.  If we use
\texttt{NULL} for the remote address, the present address is reset.
\item If the socket is set as non-blocking, see page \pageref{FCNTL},
\funnm{connect}() will not block while waiting to connect.  It will return
\texttt{-1} with \texttt{errno} set to \texttt{EINPROGRESS} (= ``not possible to
create a connection right away'') and the connection request is stored in the
system queue to be processed.  Until the connection is ready, subsequent
\funnm{connect}()s return \texttt{-1} with \texttt{errno} set to
\texttt{EALREADY}.  However, using this way to test the connection readiness is
not the right approach as if the background connection attempt fails, the next
\funnm{connect}() tries to create a new connection and we would end up in a
never ending loop.  The right approach is to use \funnm{select}() or
\funnm{poll}(), see pages \pageref{SELECT} and \pageref{POLL}.  You can also
find there an example using a non-blocking \funnm{connect}(), page
\pageref{NON_BLOCKING_CONNECT}.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Connection-oriented (TCP), parallel service}
\input{img/tex/tcp_par.tex}
\end{slide}

\begin{itemize}
\item For each client connection the server accepts, a new process is created to
process it.  After the connection is finished, the child exits.  The parent
process can accept new connections meanwhile.  So, multiple connections may be
served in parallel.
\item After \funnm{fork}()ing but before starting to use the connection, the
child may \funnm{exec}() -- that is how \texttt{inetd} works, see page
\pageref{INETD}.
\item As you already know, by calling \funnm{waitpid}() you are getting rid of
zombies.  Another way is to set to ignore \texttt{SIGCHLD} in which case you
completely avoid the grave danger of the living dead attack (see page
\pageref{IGNORE_SIG_CHLD}).  You could also catch the signal and call
one of the \funnm{wait}() calls from the handler itself which is fine as the
call is async-signal safe (see page \pageref{ASYNCSIGNALSAFE}).
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Connection-oriented service, parallel \texttt{accept()}}
\input{img/tex/tcp_prefork.tex}
\end{slide}

\begin{itemize}
\item After calling \funnm{bind}() and \funnm{listen}(), the parent creates
several children who sequentially serve connection requests.  Kernel,
non-deterministically from the user point of view, distributes the connection
requests between child processes waiting in \funnm{accept}().  The parent itself
does not serve any connection but possibly \funnm{wait}()s and creates new
processes as needed.
\item The parent should monitor the number of existing children serving
connections as well as the number of queued connections, and spawn new processes
as necessary.  It is a good idea for child processes to voluntarily exit after
serving a certain number of connections to avoid issues like memory leaks to
affect the host as a whole.  Apache can be configured to work like this.
\item All server side ways of serving the connections work with the same client.
The way a client works does not depend on which approach the server choses.
\end{itemize}

\begin{slide}
\sltitle{Datagram services (UDP)}
\input{img/tex/udp.tex}
\end{slide}

\begin{itemize}
\item Both the client and server use the same functions, the client is one that
sends the first datagram.
\item As in TCP, a client does not need \funnm{bind}() unless it requires a
specific local address to bind to.  The server gets the client address from the
received datagram.
\item In contrast to connection-oriented service, the connectionless one has
less overhead and one can use the same socket to communicate with multiple
remote processes.
\item You can use \funnm{connect}() for UDP as well, see page
\pageref{CONNECT_FOR_UDP} for more information.
\end{itemize}

%%%%%

\pdfbookmark[1]{recvfrom}{recvfrom}

\begin{slide}
\sltitle{Receiving message: \texttt{recvfrom()}}
\setlength{\baselineskip}{0.8\baselineskip}
\funml{ssize\_t \funnm{recvfrom}(\=int \emph{sock}, void *\emph{buf},
size\_t \emph{l{}en}, \\\>int \emph{flg}, struct sockaddr *\emph{address},
\\\>socklen\_t *\emph{address\_len});}
\begin{itemize}
\item receives a message from \emph{sock}, stores it to \emph{buf}
of size \emph{l{}en}, puts the sender's address to \emph{address},
and address length to \emph{address\_len}.  Returns message length.
If the message does not fit \emph{l{}en}, extra data is discarded
(\texttt{SOCK\_STREAM} does not divide data, nothing is discarded).
\item flags \emph{flg} can be:
    \begin{itemize}
    \item \texttt{MSG\_PEEK} \dots{} message it considered not read, next
    \texttt{recvfrom} will return it again
    \item \texttt{MSG\_OOB} \dots{} reads urgent (out-of-band)
    data 
    \item \texttt{MSG\_WAITALL} \dots{} waits for the buffer to fill up
    ie. \emph{l{}en} bytes
    \end{itemize}
\end{itemize}
\end{slide}

\begin{itemize}
\item Mainly for \texttt{SOCK\_DGRAM} sockets. Waits for the whole message,
does not return datagram portion. Again, it is possible to set the socket
as non-blocking.
\item \texttt{address\_len} \emsl{must} byt initialized with buffer size if
the address is not \texttt{NULL}. \texttt{NULL} address is used to express that
the caller is not interested in remote's address -- however that is usually
not the case when working with datagrams.
\item Instead of using \texttt{recvfrom} it is possible to use
\texttt{recvmsg} which is more generic.
\item If \texttt{connect} was used then \texttt{recv} can be used instead of
\texttt{recvfrom}.
\item After successful return from \texttt{recvfrom} it is possible to reuse
\texttt{address} and \texttt{address\_len} unchanged for a \texttt{sendto} call.
\item Like \texttt{sendto}, \texttt{recvfrom} is possible to use for connected
service. That said, getting remote's address is better via
\texttt{getpeername}, see page \pageref{GETPEERNAME}.
\item example: \label{UDP_SERVER_C} \example{udp/udp-server.c}
\end{itemize}


%%%%%

\pdfbookmark[1]{sendto}{sendto}

\begin{slide}
\sltitle{Sending message: \texttt{sendto()}}
\funml{ssize\_t \funnm{sendto}(\=int \emph{socket}, void *\emph{msg},
size\_t \emph{l{}en},\\\>int \emph{flags}, struct sockaddr *\emph{addr},
\\\>socklen\_t \emph{addr\_len});}
\begin{itemize}
\item sends a message \emph{msg} via \emph{socket} of \emph{l{}en} bytes to
address \emph{addr} (of \emph{addr\_len} length). 
\item \emph{flags} can carry:
    \begin{itemize}
    \item \texttt{MSG\_EOB} \dots{} finish a record (if supported by the
    protocol)
    \item \texttt{MSG\_OOB} \dots{} send urgent (out-of-band) data
    \end{itemize}
\end{itemize}
\end{slide}

\begin{itemize}
\item Used mainly for \texttt{SOCK\_DGRAM} sockets, because in such situation
we only have socket representing our side of the connection; see the note
for \texttt{accept}. The remote address has to be specified which cannot be
done with \texttt{write}. Moreover, for \emsl{datagram} service the data sent
is considered as whole, i.e. either it is accepted completely or the call
will block -- partial write does not exist. Like with file descriptors, it is
possible to set the socket as non-blocking, see page \pageref{FCNTL}.
\item Instead of using \texttt{sendto} more generic function \texttt{sendmsg}
can be used.
\item If \texttt{connect} was used then \texttt{send} can be used instead of
\texttt{sendto}.
\item Successful return from either \emsl{does not mean successful delivery of
the message to the remote side}, but only instertion of the data to local buffer
which is yet to be sent out.
\item It is possible to use \texttt{sendto} for stream service, however the
address will be ignored. The only reason not to use \texttt{write} would be to
use flags. In this case it is simpler to use \texttt{send}.
\item Example:\label{UDP_CLIENT_C} \example{udp/udp-client.c}.
\end{itemize}

%%%%%

\pdfbookmark[1]{close}{close}

\begin{slide}
\sltitle{Closing socket: \texttt{close()}}
\setlength{\baselineskip}{0.8\baselineskip}
\texttt{int \funnm{close}(int \emph{sock});}
\begin{itemize}
\item close descriptor \emph{sock}, after the last descriptor is closed, close
the socket in kernel
\item for the \texttt{SOCK\_STREAM} socket,
\texttt{SO\_LINGER} flag is important (default is \texttt{.l\_onoff~==~0}, use
\funnm{setsockopt}() with \texttt{struct linger} to change that).
    \begin{itemize}
    \item \texttt{.l\_onoff~==~0} \dots{} \funnm{close}() returns but system
    tries to transfer rest of the data
    \item \texttt{.l\_onoff~==~1~\&\&~.l\_linger~!=~0} \dots{} system tries to
    transfer data until timeout \texttt{l\_linger} expires (in seconds), if it
    fails, return error, otherwise return OK after transferring data.
    \item \texttt{.l\_onoff~==~1~\&\&~.l\_linger~==~0} \dots{} reset the
    connection
    \end{itemize}
\end{itemize}
\end{slide}

\label{CLOSESOCKET}

\begin{itemize}
\item Once closed, TCP socket can remain in transitory state which is defined in
TCP protocol for connection closing. Before the socket is completely destroyed,
it is not possible to use another socket with the same port, unless this
behavior was overriden with the \texttt{SO\_REUSEADDR} flag using the
\texttt{setsockopt} function, see page \pageref{SETSOCKOPT}.
\item Connection reset is abnormal connection termination. In case of TCP
a packet with \texttt{RST} flag is used for such termination. The remote side
will detect this as end of file when reading, the reset will lead to the
\texttt{ECONNRESET} error. Example: \example{tcp/linger.c}.
\end{itemize}

%%%%%

\pdfbookmark[1]{shutdown}{shutdown}

\begin{slide}
\sltitle{Shut down part of a connection: \texttt{shutdown()}}
\texttt{int \funnm{shutdown}(int \emph{socket}, int \emph{how});}
\begin{itemize}
\item shuts down a socket but does not close the descriptor, \emph{how} can be: 
    \begin{itemize}
    \item \texttt{SHUT\_RD} \dots{} shut it down for reading
    \item \texttt{SHUT\_WR} \dots{} for writing
    \item \texttt{SHUT\_RDWR} \dots{} for both
    \end{itemize}
\end{itemize}
\end{slide}

\begin{itemize}
\item After using \texttt{shutdown} it is still necessary to close the
descriptor using \texttt{close}.
\item Normal TCP connection termination each side will signal that no subsequent
writes will follow. This is valid for either \texttt{close} or
\texttt{shutdown(fd, SHUT\_RDWR)}. When using
\texttt{shutdown(fd, SHUT\_WR)} it is still possible to read from the socket.
The remote side will get \texttt{EOF} while reading however it can still write.
\end{itemize}

%%%%%

\pdfbookmark[1]{inet\_pton, inet\_ntop}{ipaddrfncs}

\begin{slide}
\sltitle{Working with IPv4 and IPv6 addresses}
\begin{itemize}
\item binary representation of IP address is hard to read
\item string representation of IP address cannot be used when working with
\texttt{sockaddr} structures
\end{itemize}

\texttt{int \funnm{inet\_pton}(int \emph{af}, const char *\emph{src},
void *\emph{dst});}
\begin{itemize}
\item converts string to binary representation, i.e. something usable for
\texttt{in\_addr} or \texttt{in6\_addr} members of \texttt{sockaddr} structures
\item returns 1 (OK), 0 (wrong address) or -1 (and sets \texttt{errno})
\end{itemize}

\funml{cont char *\funnm{inet\_ntop}(\=int \emph{af}, const void *\emph{src},
\\\>char *\emph{dst}, size\_t \emph{size});}
\begin{itemize}
\item counterpart to \texttt{inet\_pton}; returns \emph{\texttt{dst}} or
\texttt{NULL} (and sets \texttt{errno})
\end{itemize}
\begin{itemize}
\item for both functions \texttt{af} is either \texttt{AF\_INET} or
\texttt{AF\_INET6}
\end{itemize}
\end{slide}

\label{IPv4_IPv6_ADDRESSES}

\begin{itemize}
\item The functions are declared in \texttt{arpa/inet.h}.
\item \texttt{inet\_pton} returns 1 if the conversion successfully happened,
0 if given string is not an address or -1 if \emph{af} is not supported
(\texttt{EAFNOSUPPORT}). \texttt{inet\_ntop} returns \texttt{dst} if everything
is OK otherwise returns \texttt{NULL} with \texttt{errno} set.
\item Addresses and ports in binary form are stored as big endian.
\item \texttt{dst} has to be suffciently sized because there is no parameter
specifying the size. This is not a problem since according to the value of
\texttt{af} appropriate address structure or character array can be passed in.
For maximal lenghts of strings for addresses, 2 macros can be used --
\texttt{INET\_ADDRSTR\-LEN} (16) or \texttt{INET6\_ADDRSTRLEN} (48). 
These values contain space for terminating \texttt{\bs{}0}.
\item \texttt{size} is string size of \texttt{dst}. If not sufficient, the call
will fail and \texttt{ENOSPC} will be set.
\item \texttt{n} stands for \texttt{network}, \texttt{p} stands for
\texttt{presentable}
\item In the past \texttt{inet\_aton} and \texttt{inet\_ntoa} (\texttt{a} as
\texttt{ascii}) were used for IPv4 addresses. Thanks for the functions above
these are now legacy. All these calls are usually documented in the
\texttt{inet} man page.
\item \label{ADDRESSES} Do realize that using these functions it is only
possible to convert one address family once, either IPv4 or IPv6.
When the output can be either, try one and if that fails, fallback to another.
Example: \example{resolving/addresses.c}.
\end{itemize}

%%%%%

\pdfbookmark[1]{setsockopt, getsockopt, getsockname, getpeername}{socketfncs}

\begin{slide}
\sltitle{Dal¹í funkce pro sokety}
\funml{int \funnm{setsockopt}(\=int \emph{socket}, int \emph{level},
int \emph{opt\_name}, \\\>const void *\emph{opt\_value},
socklen\_t \emph{option\_len});}
\begin{itemize}
\item nastavení parametrù soketu
\end{itemize}
\funml{int \funnm{getsockopt}(\=int \emph{socket}, int \emph{level},
int \emph{opt\_name},\\\>void *\emph{opt\_value},
socklen\_t *\emph{option\_len});}
\begin{itemize}
\item pøeètení parametrù soketu
\end{itemize}
\funml{int \funnm{getsockname}(\=int \emph{socket},
struct sockaddr *\emph{address}, \\\>socklen\_t *\emph{address\_len});}
\begin{itemize}
\item zji¹tìní (lokální) adresy soketu
\end{itemize}
\funml{int \funnm{getpeername}(\=int \emph{socket},
struct sockaddr *\emph{address}, \\\>socklen\_t *\emph{address\_len});}
\begin{itemize}
\item zji¹tìní adresy vzdál{}eného soketu (druhého konce spojení)
\end{itemize}
\end{slide}

\label{SETSOCKOPT}
\label{GETPEERNAME}
\label{GETSOCKOPT}

\begin{itemize}
\item hodnota \texttt{level} v \texttt{getsockopt} a \texttt{setsockopt}
je obvykle \verb#SOL_SOCKET#. U \texttt{get\-sock\-opt}, \texttt{option\_len}
\emsl{musí} být inicializována na velikost \texttt{opt\_value}.
\item funkce \texttt{getsockname} se pou¾ívá, kdy¾ nevoláme \texttt{bind}
a potøebujeme zjistit, jaká (lokální!) adresa byla jádrem soketu pøidìlena. 
\item volání \verb#getsockopt(sock, SOL_SOCKET, SO_ERROR, &val, &len)# vrátí
(a vyma¾e) pøíznak chyby na soketu. Asi neju¾iteènìj¹í je pøi zji¹»ování, jak
dopadl neblokující \texttt{connect}, viz strana \pageref{CONNECT}.
\item pøi pou¾ití \verb#SO_REUSEADDR# se dá po uzavøení poslouchajícího
serverového soketu znovu spustit server -- volat \texttt{socket},
\texttt{bind}, \texttt{listen} a \texttt{accept} na stejné adrese a portu
-- i kdy¾ je¹tì dobíhají spojení vytvoøená pøedchozí instancí serveru:

\begin{verbatim}
int opt = 1;
setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
\end{verbatim}

\item Pou¾ití \texttt{setsockopt} s \verb#SO_REUSEADDR# je vidìt napø. v
pøíkladu \example{tcp/reuseaddr.c}. Pozor na to, ¾e musíte udìlat alespoò
jedno spojení, jinak systém nemá na co èekat a opakovaný \texttt{bind} za
sebou se podaøí i tak.
\end{itemize}

%%%%%

\pdfbookmark[1]{htonl, ntohl, htons, ntohs}{byteorderfncs}

\begin{slide}
\sltitle{Poøadí bajtù}
\begin{itemize}
\item sí»ové slu¾by pou¾ívají poøadí bajtù, které se mù¾e li¹it od poøadí
pou¾ívaného na lokálním systému. Pro pøevod lze pou¾ít funkce (makra): 
    \begin{itemize}
    \item\texttt{uint32\_t \funnm{htonl}(uint32\_t \emph{hostlong});}\\
    host $\rightarrow$ sí», 32 bitù 
    \item\texttt{uint16\_t \funnm{htons}(uint16\_t \emph{hostshort});}\\
    host $\rightarrow$ sí», 16 bitù 
    \item \texttt{uint32\_t \funnm{ntohl}(uint32\_t \emph{netlong});}\\
    sí» $\rightarrow$ host, 32 bitù
    \item \texttt{uint16\_t \funnm{ntohs}(uint16\_t \emph{netshort});}\\
    sí» $\rightarrow$ host, 16 bitù 
    \end{itemize}
\item sí»ové poøadí bajtù je big-endian, tj. nejprve vy¹¹í bajt. Pou¾ívá se
hlavnì ve funkcích pracujících s adresami a èísly portù.
\end{itemize}
\end{slide}

\label{HTON}

\begin{itemize}
\item pokud lokální systém pou¾ívá stejné poøadí bajtù jako sí», nedìlají
pøevodní funkce nic.
\item jednoduchý a pøitom vìt¹inou postaèující test na to, zda správnì pøevádíte
poøadí bajtù, je spustit va¹ program proti sobì (pokud to tak lze) na
architekturách s rozdílným uspoøádáním bajtù.


\end{itemize}

%%%%%

\pdfbookmark[1]{getprotobyname, getservbyname}{protonumfncs}

\begin{slide}
\sltitle{Èísla protokolù a portù}
\texttt{struct protoent *\funnm{getprotobyname}(const char *\emph{name});}
\begin{itemize}
\item v polo¾ce \texttt{p\_proto} vrátí èíslo protokolu se jménem \emph{name}
(napø. pro \texttt{"tcp"} vrátí 6). 
\item èísla protokolù jsou ulo¾ena v souboru \texttt{/etc/protocols}. 
\end{itemize}
\funml{struct servent *\funnm{getservbyname}(\=const char *\emph{name},
\\\>const char *\emph{proto});}
\begin{itemize}
\item pro zadané jméno slu¾by \texttt{name} a jméno protokolu \texttt{proto}
vrátí v~polo¾ce \texttt{s\_port} èíslo portu. 
\item èísla portù jsou ulo¾ena v souboru \texttt{/etc/services}. 
\end{itemize}

funkce vrací \texttt{NULL}, kdy¾ v databázi není odpovídající polo¾ka.
\end{slide}

\begin{itemize}
\item výsledek \funnm{getprotobyname} se hodí pro volání \texttt{socket},
výsledek \funnm{getservbyname} pro volání \texttt{bind}.
\item kromì \texttt{getservbyname} existuje je¹tì \texttt{getservbyport}
umo¾òující hledat slu¾bu pomocí èísla portu (pozor, v network byte order !)
a funkce \texttt{getservent} a spol. pro ruèní procházení záznamù.
\item v¹echny tyto funkce prohledávají pouze "oficiální" seznamy slu¾eb
a protokolù, které se nacházejí vìt¹inou v souborech zmínìných na slajdu. 
\item v uvedených souborech je definováno mapování mezi jmény a èísly pro
standardní protokoly a slu¾by.
\item pozor na to, ¾e protokolem zde nemyslíme HTTP, SSH, telnet nebo FTP -- to
jsou zde \emph{slu¾by}, reprezentované èísly portù. Protokol je TCP, UDP,
OSPF, GRE apod., tedy to, co je pøená¹eno v IP paketu v polo¾ce
\texttt{Protocol}, viz strany 11 a 14 v RFC~791.
\item \label{GETBYNAME} pøíklad: \example{resolving/getbyname.c}
\end{itemize}

%%%%%

\pdfbookmark[1]{getaddrinfo}{getaddrinfo}

\label{GETADDRINF}

\begin{slide}
\sltitle{Pøevod hostname na adresy: \texttt{getaddrinfo()}}

\begin{itemize}
\item ze zadaných parametrù pøímo generuje \texttt{sockaddr} struktury
\item pracuje s adresami i s porty
\item její chování je ovlivnitelné pomocí tzv. \emph{hintù}

\funml{int \funnm{getaddrinfo}(\=const char *\emph{nodename},
\\\>const char *\emph{servicename},
\\\>const struct addrinfo *\emph{hint},
\\\>struct addrinfo **\emph{res});}
\item polo¾ky struktury \texttt{addrinfo}:
\texttt{ai\_flags} (pro hinty), \texttt{ai\_family} (address family),
\texttt{ai\_socktype}, \texttt{ai\_protocol}, \texttt{ai\_addrlen},
\texttt{struct sockaddr *ai\_addr} (výsledné adresy),
\texttt{char *ai\_canonname},
\texttt{struct addrinfo *ai\_next} (dal¹í prvek v seznamu)
\end{itemize}
\end{slide}

\begin{itemize}
\item Pøi vyhodnocování dotazù na adresy a jména se pou¾ívají
jmenné slu¾by podle konfigurace v souboru \texttt{/etc/nsswitch.conf}.
\item struktura \texttt{addrinfo} je definována v \texttt{netdb.h}
\item \texttt{getaddrinfo} umí do struktur \texttt{sockaddr} pøevádìt jak
øetìzec který obsahuje hostname, tak øetìzec obsahující IP adresu. Stejnì
je tomu i pro porty.
\item funkce \texttt{getaddrinfo} vrací parametrem \emph{res} seznam
struktur \texttt{sockaddr}, ve kterých jsou ulo¾eny adresy korespondující
k danému vstupu.
\item je rozdíl zda budou adresní struktury dále pou¾ity pro server nebo klient;
pro server napø. staèí jako \emph{nodename} dát \texttt{NULL} (wildcard
socket). Podobnì pro pro polo¾ku \texttt{ai\_flags} struktury
\texttt{addrinfo} pou¾ité pro parametr \emph{hint} a její hodnotu
\texttt{AI\_PASSIVE}.
\item Po skonèení práce s výsledky nezapomeòte zavolat funkci
\texttt{freeaddrinfo}, která uvolní naalokovanou pamìt.
\item \label{GETADDRINFO} pøíklad: \example{resolving/getaddrinfo.c}
\item Døíve se hodnì pou¾ívaly funkce \funnm{gethostbyname} a
\funnm{gethostbyaddr}.  Tyto funkce pracují pouze s IPv4 adresami a jmény,
jsou tak \emsl{pova¾ovány za zastaralé} a jejich pou¾ití se nedoporuèuje.
Místo nich se doporuèuje pou¾ívat obecnìj¹í volání
\texttt{getipnodebyname} a \texttt{getipnodebyaddr} (\texttt{getipnode*}
funkce se nachází v rùzných systémech, nicménì byly nedávno vyjmuty z GNU libc,
tak¾e se na jejich pøítomnost nelze univerzálnì spolehnout. Navíc nejsou
souèástí UNIX standardu.) resp. \texttt{get\-addr\-info}, \texttt{getnameinfo}.
Z tìchto funkcí pouze \texttt{get\-addr\-info} a \texttt{getnameinfo} splòují
standard (POSIX.1-2001).
\item Pochopitelnì, je nutné dobøe uvá¾it, zda existující kód pou¾ívající 
legacy/obsolete funkce je potøeba
pøepisovat. Pokud takovému programu bude IPv4 staèit i nadále, mìnit existující
a funkèní kód nemusí být v¾dy rozumné. \emsl{Nový kód ale v¾dy pi¹te pomocí
nových funkcí}, které podporují IPv4 i IPv6, i pokud byste si mysleli, ¾e vá¹
program nebude IPv6 nikdy pou¾ívat. Za pou¾ití \texttt{gethostbyname},
\texttt{gethostbyaddr} nebo struktur specifických pro IPv4 resp. IPv6 (bez
vá¾ného dùvodu) pùjde u zkou¹ky hodnocení dolù.
\end{itemize}


%%%%%%

\pdfbookmark[1]{getnameinfo}{getnameinfo}

\begin{slide}
\sltitle{Pøevod adresy na hostname: \texttt{getnameinfo()}}

\begin{itemize}
\item protìj¹ek k funkci \texttt{getaddrinfo}
\item jako vstup pracuje s celými \texttt{sockaddr} strukturami, tedy funguje s
IPv4 i IPv6 adresami, narozdíl od funkce \texttt{gethostbyaddr}.
\end{itemize}

\funml{int \funnm{getnameinfo}(\=const struct sockaddr *\emph{sa},
\\\>socklen\_t *\emph{sa\_len},
\\\>char *\emph{nodename},
\\\>socketlen\_t *\emph{nodelen},
\\\>char *\emph{servicename},
\\\>socketlen\_t *\emph{servicelen},
\\\>unsigned \emph{flags});}
\end{slide}

\begin{itemize}
\item \texttt{getnameinfo} provádí v jednom volání funkce konverzi adresy
a èísla portu ulo¾ených ve struktuøe \texttt{sockaddr} na stringy v
závislosti na namingových slu¾bách (tedy standardní cesta pøes naming
backendy v \texttt{/etc/nsswitch.conf}) a hodnotì \texttt{flags}.
Tedy to, co by bylo postaru nutné provádìt pomocí volání \texttt{gethostbyaddr}
a \texttt{getservbyport}.
\item Tato funkce je narozdíl od vý¹e zmínìných legacy funkcí reentrantní
a hodí se tedy pro pou¾ití v prostøedí s thready (alespoò na vìt¹inì systémù).
\item manuálová stránka obsahuje seznam pou¾itelných \texttt{NI\_} flagù pro
\texttt{\emph{flags}} a jejich význam 
\item \label{GETNAMEINFO} pøíklad: \example{resolving/getnameinfo.c}


\end{itemize}

%%%%%

\pdfbookmark[1]{TCP server}{tcpservercode}
\label{TCPSRVEXAMPLE}

\begin{slide}
\sltitle{Pøíklad: TCP server}
\setlength{\baselineskip}{0.9\baselineskip}
\begin{alltt}
struct sockaddr\_storage ca; int nclients = 10, fd, nfd;
struct addrinfo *r, *rorig, hi;
memset(&hi, 0, sizeof (hi)); hi.ai\_family = AF\_UNSPEC;
hi.ai\_socktype = SOCK\_STREAM; hi.ai\_flags = AI\_PASSIVE;
\emprg{getaddrinfo}(NULL, portstr, &hi, &rorig);
for (r = rorig; r != NULL; r = r->ai\_next) \{
    fd = \emprg{socket}(r->ai\_family, r->ai\_socktype,
        r->ai\_protocol);
    if (!\emprg{bind}(fd, r->ai\_addr, r->ai\_addrlen)) break;
\}
\emprg{freeaddrinfo}(rorig); \emprg{listen}(fd, nclients);
for (;;) \{ sz = sizeof(ca);
    nfd = \emprg{accept}(fd, (struct sockaddr *)&ca, &sz);
    /* Komunikace s klientem */
    close(newsock);
\}
\end{alltt}
\end{slide}

\begin{itemize}
\item Toto je obecná kostra serveru. Argument \texttt{portstr} je jediný
vstupní parametr. První úspì¹ný bind ukonèí procházení seznamu adres.
\item Takto napsaný server bude na systému, který podporuje IPv6 i IPv4
pøijímat spojení v obou adresních rodinách na tomté¾ socketu. Spojení
z IPv4 klientù budou mít jako zdrojovou adresu tzv. \emph{IPv4-mapped IPv6
adresu}, která v sobì obsahuje IPv4 adresu
(napø. \texttt{::FFFF:78.128.192.1}).
\item V¹imnìte si, ¾e není nutné témìø nic pøetypovávat na pointer na
strukturu \texttt{sockaddr}. Jedinou výjimkou je volání \texttt{accept}.
Pro volání \texttt{accept} se pou¾ívá struktura typu
\texttt{sockaddr\_storage} co¾ je obecný "kontejner" schopný pojmout prvky
struktury \texttt{sockaddr\_in} i \texttt{sockaddr\_in6}.
\item \texttt{socket} a \texttt{bind} se volají pro v¹echny vrácené
\texttt{sockaddr} struktury dokud pro jednu z nich \texttt{bind} neuspìje
nebo se seznam nevyèerpá.
\item Problém: nekontrolují se nìkteré návratové hodnoty a neobsahuje
volání uvolòující alokované entity, napø. uzavøení socketu v pøípadì chyby
volání \texttt{bind}. Stejnì tak se neøe¹í situace kdy se vyèerpá seznam
bez toho aby \texttt{bind} uspìl (to lze detekovat pomocí kontroly
nenulovosti pointeru \texttt{r} za koncem prvního cyklu).
\end{itemize}

%%%%%

\pdfbookmark[1]{TCP client}{tcpclientcode}
\label{TCPCLNTEXAMPLE}

\begin{slide}
\sltitle{Example: TCP client}
\begin{alltt}
int fd; struct addrinfo *r, *rorig, hi;
memset(&hi, 0, sizeof (hi)); hi.ai\_family = AF\_UNSPEC;
hi.ai\_socktype = SOCK\_STREAM;
\emprg{getaddrinfo}(hoststr, portstr, &hi, &r);
for (rorig = r; r != NULL; r = r->ai\_next) \{
    fd = \emprg{socket}(r->ai\_family, r->ai\_socktype,
        r->ai\_protocol);
    if (\emprg{connect}(fd, (struct sockaddr *)r->ai\_addr,
        r->ai\_addrlen) == 0)
            break;
\}
\emprg{freeaddrinfo}(resorig);
/* communication with server */
close(fd);
\end{alltt}
\end{slide}

\begin{itemize}
\item Toto je obecná kostra TCP klienta. Argumenty \texttt{hoststr} a
\texttt{portstr} jsou jediné vstupní parametry. První úspì¹ný
\texttt{connect} ukonèí procházení adres pro daný host.
\item V pøíkladu vyu¾íváme automatického pøidìl{}ení volného portu systémem
pøi volání \texttt{connect} (nepøedcházelo mu volání \texttt{bind}).
\item postupnì se volá \texttt{connect} na v¹echny vrácené
\texttt{sockaddr} struktury (v \texttt{addrinfo} strukturách) pro daný
host do té doby, ne¾ se podaøí spojit.
\item Problém: neobsahuje kontrolu návratových hodnot volání.
Stejnì tak se neøe¹í situace kdy se vyèerpá seznam
bez toho aby \texttt{connect} uspìl (to lze detekovat pomocí kontroly
nenulovosti pointeru \texttt{r} za koncem prvního cyklu). Nebo se
neuzavírá socket pøi neúspì¹ném volání \texttt{connect}, tj.
je to file descriptor leak.
\end{itemize}

%%%%%

\pdfbookmark[1]{select}{select}

\begin{slide}
\sltitle{Èekání na data: \texttt{select()}}
\setlength{\baselineskip}{0.9\baselineskip}
\funml{int \funnm{select}(\=int \emph{nfds}, fd\_set *\emph{readfds},
\\\>fd\_set *\emph{writefds}, fd\_set *\emph{errorfds},
\\\>struct timeval *\emph{timeout});}
\begin{itemize}
\item zjistí, které ze zadaných deskriptorù jsou pøipraveny pro
ètení, zápis, nebo na kterých do¹lo k výjimeènému stavu. Pokud ¾ádný
takový deskriptor není, èeká do vypr¹ení èasu \texttt{timeout}
(\texttt{NULL} \dots èeká se libovolnì dlouho). Parametr \texttt{nfds}
udává rozsah testovaných deskriptorù (\texttt{0,~...,~\emsl{nfds-1}}). 
\item pro nastavení a test masek deskriptorù slou¾í funkce: 
    \begin{itemize}
    \item \texttt{void \funnm{FD\_ZERO}(fd\_set *\emph{fdset})} \dots{}
    inicializace 
    \item \texttt{void \funnm{FD\_SET}(int \emph{fd}, fd\_set *\emph{fdset})}
    \dots nastavení  
    \item \texttt{void \funnm{FD\_CLR}(int \emph{fd}, fd\_set *\emph{fdset})}
    \dots{} zru¹ení
    \item \texttt{int \funnm{FD\_ISSET}(int \emph{fd}, fd\_set *\emph{fdset})}
    \dots{} test 
    \end{itemize}
\end{itemize}
\end{slide}

\label{SELECT}

\begin{itemize}
\item \emsl{Motivace:} jestli¾e chceme èíst data z více deskriptorù, je mo¾né,
pokud jde o soubor, rovnou jej otevøít s pøíznakem \texttt{O\_NONBLOCK}, anebo
tento pøíznak kdykoli nastavit na deskriptoru pomocí volání \texttt{fncnl} s
druhým parametrem \texttt{O\_SETFL} (ne \texttt{O\_SETFD}, viz strana
\pageref{FCNTL}). Neblokujícím \texttt{read} pak støídavì testujeme jednotlivé
deskriptory, a mezi ka¾dým kolem testù tøeba pou¾ít \texttt{sleep(1)}. Nevýhody
jsou aktivní èekání, re¾ie pøepínání mezi módem u\-¾i\-va\-tel\-ským a jádra,
mo¾ná prodleva (a¾ do délky va¹eho èekání mezi jednotlivými koly), a také to, ¾e
neslo¾íte zkou¹ku (viz strana \pageref{SLEEP1}). Správné øe¹ení této situace je
pou¾ít napøíklad \texttt{select} a následnì zavolat \texttt{read} na ty
deskriptory, které volání \texttt{select} ohlásí jako \emph{pøipravené}.
\item \label{BUSY_WAITING_C} Pøíklad na busy waiting:
\example{select/busy-wait.c}. V¹imnìte si, ¾e novì vytvoøený soket v pøíkladu
je bez flagu \texttt{O\_NONBLOCK}, viz strana \pageref{ACCEPT}, tak¾e je nutné
flag nastavit.


\item \emph{Pøipravený} (\emph{ready}) znamená, ¾e \texttt{read} nebo
\texttt{write} s vynulovaným pøíznakem \texttt{O\_NONBLOCK} by se
\emsl{ne}zablokovalo, tedy ne nutnì ¾e nìjaká data jsou pøi\-pra\-ve\-na
(\texttt{read} napø. mù¾e vrátit 0 pro end-of-file nebo -1 pro chybu)
\item Mno¾ina \texttt{errorfds} je pro výjímky v závislosti na typu deskriptoru;
pro socket to je napøíklad pøíchod urgentních dat (flag \texttt{URG} v TCP
hlavièce).
Neznamená to, ¾e na daném deskriptoru do¹lo k chybì ! Chyba s nastaveným
\texttt{errno} se zjistí z ostatních mno¾in po návratovém kódu -1
provedeného volání, tj. napøíklad \texttt{read}.
\item Pøi volání jsou v mno¾inách deskriptory, které chceme testovat, po návratu
zùstanou nastavené jen ty deskriptory, na kterých nastala testovaná událost.
\emsl{Je nutné je tedy pøed dal¹ím voláním \texttt{select} znovu nastavit.}
Typicky to jsou bitové masky, ale nemusí tomu být tak; z pozice programátora je
to samozøejmì jedno. Procházení pøes vrácené mno¾iny je nutné dìlat po jednom
deskriptoru, pøes \texttt{FD\_ISSET}.
\item Funkce \texttt{select} je pou¾itelná i pro èekání na mo¾nost zápisu do
roury nebo soketu -- èeká se, a¾ druhá strana nìco pøeète a uvolní se místo v
bufferu pro dal¹í data.
\item Místo mno¾iny pro deskriptory je mo¾né uvést NULL, speciální pøípad pøi
nastavení v¹ech mno¾in na NULL je volání, které se pouze zablokuje do pøíchodu
signálu nebo do vypr¹ení time-outu.
\item Po návratu je nutné otestovat ka¾dý deskriptor zvlá¹», není k dispozici
volání, které by vám vytvoøilo mno¾inu pøipravených deskriptorù.
\item Pokud obsluhuje sí»ový server více portù, mù¾e volat \texttt{select}
na pøíslu¹né deskriptory soketù a následnì \texttt{accept} na deskriptory,
pro které \texttt{select} ohlásil pøíchod ¾ádosti klienta (pøipravenost ke
ètení).
\item Volání \texttt{connect} na neblokujícím soketu se hned vrátí, navázání
spojení ohlásí následný \texttt{select} jako pøipravenost k zápisu. Více viz
strana \pageref{CONNECT}.
\item Dal¹í mo¾nost pou¾ití \texttt{select} je sí»ový server, který v jednom
procesu obsluhuje paralelnì nìkolik klientù. Pomocí \texttt{select} se
testuje stav deskriptorù odpovídajících spojení s jednotlivými klienty a pøes
deskriptory pøi\-pra\-ve\-né pro ètení/zápis se komunikuje. Aby se mohli
pøipojovat noví klienti, testuje se i deskriptor soketu, který se pou¾ívá pro
\texttt{accept}. Vyu¾ívá se toho, ¾e \texttt{select} ohlásí deskriptor s
èekající ¾ádostí klienta o spojení jako pøipravený pro ètení. Na takový
deskriptor je mo¾né volat \texttt{accept}.
\item Pozor na to, ¾e \texttt{select} \emsl{mù¾e} zmìnit strukturu
\texttt{timeval}, existuje nové volání \texttt{pselect}, které kromì dal¹ích
zmìn strukturu pro timeout nezmìní.
\item Pro \emsl{nfds} je mo¾né pou¾ít \texttt{FD\_SETSIZE}, co¾ je systémová
konstanta pro maximální poèet deskriptorù. Není to ale nejlep¹í øe¹ení, proto¾e
tato konstanta je sice vìt¹inou jen 1024 na 32-bitových systémech, na Solarisu
to v¹ak pro 64-bitové architektury je u¾ 65536. Pøedpokládám podobné chování i
pro ostatní systémy.
\item Pokud se èas nastaví na 0, tedy teï nemluvíme o nastavení ukazatele na
\texttt{NULL}, \texttt{select} se dá pou¾ít pro tzv. \emph{polling} -- zjistí
souèasný stav a hned se vrátí.
\item Pøíklad: \label{SELECT_C} \example{select/select.c}
\item \texttt{select} lze pou¾ít na zji¹»ování stavu po volání
\texttt{connect} na neblokující socket. Zda spojení probìhlo úspì¹nì se
dozvíte z funkce \texttt{getsockopt} s \texttt{opt\_name} nastaveným na
\texttt{SO\_ERROR}, viz strana \pageref{GETSOCKOPT}.
\label{NON_BLOCKING_CONNECT} Pøíklad: \example{tcp/non-blocking-connect.c}.


\end{itemize}

%%%%%

\begin{slide}
\sltitle{Pøíklad: pou¾ití \texttt{select()}}
\begin{itemize}
\item Deskriptor \texttt{fd} odkazuje na soket, pøepisuje sí»ovou
komunikaci na terminál a naopak.
\end{itemize}
\setlength{\baselineskip}{0.8\baselineskip}
\begin{alltt}
int sz; fd\_set rfdset, efdset; char buf[BUFSZ];
for(;;) \{
    \emprg{FD\_ZERO}(&rfdset); \emprg{FD\_SET}(0, &rfdset);
    \emprg{FD\_SET}(fd, &rfdset); efdset = rfdset;
    \emprg{select}(fd+1, &rfdset, NULL, &efdset, NULL);
    if(\emprg{FD\_ISSET}(0, &efdset))
        /* Výjimka na stdin */ ;
    if(\emprg{FD\_ISSET}(fd, &efdset))
        /* Výjimka na fd */ ;
    if(\emprg{FD\_ISSET}(0, &rfdset)) \{
        sz = read(0, buf, BUFSZ); write(fd, buf, sz); \}
    if(\emprg{FD\_ISSET}(fd, &rfdset)) \{
        sz = read(fd, buf, BUFSZ); write(1,buf,sz); \}
\}
\end{alltt}
\end{slide}

\begin{itemize}
\item Zde je typické pou¾ití \texttt{select}, kdy je tøeba èíst data
souèasnì ze dvou zdrojù. Tento pøíklad pøedpokládá, ¾e deskriptory
\texttt{0} a \texttt{fd} jsou nastaveny jako neblokující.
\item Pøed ka¾dým voláním \texttt{select} se musí znovu nastavit mno¾iny
deskriptorù.
\item Lep¹í øe¹ení je pou¾ít \texttt{select} i na zápis. Logika øízení je pak
taková, ¾e pro ka¾dý smìr datové komunikace máme samostatný buffer. Pøíslu¹ný
ètecí deskriptor bude v mno¾inì pro ètení v \texttt{select}, právì kdy¾ je
buffer prázdný. Naopak zápisový deskriptor bude v mno¾inì pro zápis, právì kdy¾
je buffer neprázdný.
\item \label{WRITE_SELECT_C} \texttt{select} uspí proces i pøi kontrole
pøipravenosti k zápisu, pokud data nejsou z druhé strany ètena.
To jde jednodu¹e nasimulovat pomocí programu, který se jen pøipojí
(provede TCP handshake), ale nic neète.
Viz pøíklad a komentáø v \example{select/write-select.c}.
\end{itemize}

%%%%%

\pdfbookmark[1]{poll}{poll}

\begin{slide}
\sltitle{Èekání na data: \texttt{poll()}}
\texttt{int \funnm{poll}(struct pollfd \emph{fds}[], nfds\_t \emph{nfds},
int \emph{timeout});}
\begin{itemize}
\item èeká na událost na nìkterém z deskriptorù v poli \texttt{fds}
o \texttt{nfds} prvcích po dobu \texttt{timeout} ms (\texttt{0}
\dots{} vrátí se hned, \texttt{-1} \dots{} èeká se libovolnì dlouho). 
\item prvky struktury \texttt{pollfd}:
    \begin{itemize}
    \item \texttt{fd} \dots{} èíslo deskriptoru 
    \item \texttt{events} \dots{} oèekávané události, OR-kombinace
    \texttt{POLLIN} (lze èíst), \texttt{POLLOUT} (lze psát), atd. 
    \item \texttt{revents} \dots{} události, které nastaly, pøíznaky jako
    v \texttt{events}, navíc napø. \texttt{POLLERR} (nastala chyba)
    \end{itemize}
\end{itemize}
\end{slide}

\label{POLL}

\begin{itemize}
\item Tato funkce je obdoba volání \texttt{select}.
\item argument \emph{timeout} je v milisekundách
\item Existujících pøíznakù pro pou¾ití je mnohem více, viz manuálová stránka.
\item Na Solarisu je \texttt{poll} systémové volání, \texttt{select} pak
knihovní funkce implementovaná pomocí \texttt{poll}, a \texttt{poll} je
tam preferováno.
\texttt{poll} je nutné pou¾ít v pøípadì, ¾e chcete testovat deskriptor
vìt¹í nebo rovný \texttt{FD\_SETSIZE}. \emsl{To je hlavní rozdíl mezi voláními
\texttt{select} a \texttt{poll}.} Dal¹í rozdíl je ten, ¾e není tøeba nastavovat
deskriptory po ka¾dém volání \texttt{poll}, ani nulovat \texttt{revents}.
\item Èas nastavený na -1 je to samé jako \texttt{NULL} u \texttt{select}.
\item Pokud nastavíte poèet deskriptorù na 0 (a mìli byste pak pro \texttt{fds}
pou¾ít \texttt{NULL}), mù¾ete \texttt{poll} jednodu¹e vyu¾ít pro èekání s men¹í
granularitou ne¾ po sekundách nabízené voláním \texttt{sleep}. Pøíklad:
\label{POLL_SLEEP_C} \example{sleep/poll-sleep.c} Tento "trik" ov¹em nefunguje
na macOS, tak¾e se na nìj nelze spoléhat.
\begin{itemize}
\item Mimochodem, jiný zpùsob, jak dosáhnout men¹í granularity ne¾ je jedna
sekunda je volání \texttt{nanosleep}, které je ale definované roz¹íøením POSIX.4
a tedy nemusí být v¾dy k dispozici. Pøíklad: \example{sleep/nanosleep.c}.
\end{itemize}
\end{itemize}

\endinput
