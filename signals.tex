
\pdfbookmark[0]{signals}{signals}
\begin{slide}
\sltitle{Obsah}
\begin{itemize}
\item úvod, vývoj UNIXu a C, programátorské nástroje
\item základní pojmy a konvence UNIXu a jeho API
\item pøístupová práva, periferní zaøízení, systém souborù
\item process manipulation, program execution
\item \emsl{signály}
\item synchronizace a komunikace procesù
\item sí»ová komunikace
\item vlákna, synchronizace vláken
\item ??? - bude definováno pozdìji, podle toho kolik zbyde èasu
\end{itemize}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

changequote([[[, ]]])

\begin{slide}
\sltitle{Introduction to signals}
\begin{itemize}
\item for notifying a process of asynchronous events, and for exception handling
\item mechanism of an interrupt available in user level
\item signal categories:
    \begin{itemize}
    \item \emsl{asynchronous events} happening independently of the main program
    flow, eg. a signal sent from another process, a timer expiration
    (\texttt{SIGALRM}), terminal disconnect (\texttt{SIGHUP}), or pressing
    \texttt{Ctrl-C} (\texttt{SIGINT})
    \item \emsl{exceptions} caused by a running process, eg.
    attempt to access a restricted area of memory (\texttt{SIGSEGV})
    \end{itemize}
\end{itemize}
\end{slide}

\label{SIGNALS}

\begin{itemize}
\item Interrupts can be viewed as a mean of communication between the CPU and
the OS kernel while signals are for communication between the kernel and
processes.
\item After returning from the handler, if that happens, the process continues
exactly from the place where the interruption happened.
\item Historically, signals were provided as a mechanism to forcefully terminate
processes.  That is why the function for sending signals is called
\funnm{kill}.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Introduction to signals (continued)}
\begin{itemize}
\item it is the simplest interprocess communication -- it only carries
information that an event happened
\begin{itemize}
\item there is a real-time POSIX extension that allows for more information,
more on that later
\end{itemize}
\item mostly processed asynchronously -- a signal interrupts the current process
flow and a \emph{signal handler} is invoked
\item signals are identified by numbers, represented by names like
\texttt{SIGSEGV}, \texttt{SIGCHLD}, or \texttt{SIGKILL}
\item name are usually \texttt{\#define}s, see \texttt{/usr/include/signal.h} or
\texttt{/usr/include/sys/signal.h}
\end{itemize}
\end{slide}

\begin{itemize}
\item The real-time extension is POSIX-1003.1b.
\pageref{REALTIMEEXTENSIONS}.
\item You can process signals in a synchronous way, see \funnm{sigwait} on page
\pageref{SIGWAIT}.
\end{itemize}

%%%%%

\pdfbookmark[1]{kill}{kill}

\begin{slide}
\sltitle{Sending signals}
\texttt{int \funnm{kill}(pid\_t \emph{pid}, int \emph{sig});}
\begin{itemize}
\item sends signal \emph{sig} to a process or a process group
based on value of \emph{pid}: 
    \begin{itemize}
    \item \texttt{> 0} \dots{} to process with \emph{pid}
    \item \texttt{== 0} \dots{} to all processes in the same group
    \item \texttt{== -1} \dots{} to all aside from system processes
    \item \texttt{< -1} \dots{} to processes in a group \texttt{abs(pid)} 
    \end{itemize}
\item \texttt{sig == 0} means the system only checks whether the process has
enough privileges to send a signal without sending it
\item whether a process may send other process a signal depends on UID of both
processes
\end{itemize}
\end{slide}

\label{KILLSYSCALL}

\begin{itemize}
\item Traditionally, process with EUID~==~0 can send a signal to any other
process.  However, some systems optionally provide fine grain privileges and the
situation there is different even for root.  That is out of scope for this class
though.  \item Sending a signal to another process:
    \begin{itemize}
    \item Linux, Solaris: RUID or EUID of the process that sent the signal must
    match the real UID or saved SUID of the target process.
    \item FreeBSD: EUID of the processes must match
    \end{itemize}
\item Example: \example{signals/killing-myself.c}
\item 0 signal can be also used for a simple check for the specific process
existence, see \example{signals/check-existence.c}.
\end{itemize}

%%%%%

\pdfbookmark[1]{Handling signals}{sighandle}

\begin{slide}
\sltitle{Handling signals}
\begin{itemize}
\item unless a process sets it otherwise, each signal triggers a specific
default action, one of:
    \begin{itemize}
    \item terminate the process (\emsl{exit}) 
    \item terminate and dump a core (\emsl{core})
    \item ignore the signal (\emsl{ignore})
    \item stop the process (\emsl{stop})
    \item resume the process (\emsl{continue}) 
    \end{itemize}
\item process can either set to ignore a specific signal\dots
\item \dots{}or can handle the signal via a user-defined function,
called a \emsl{handler}
\end{itemize}

Signals \texttt{SIGKILL} and \texttt{SIGSTOP} \emsl{always} trigger an implicit
action, ie. exit or stop, respectively.
\end{slide}

\begin{itemize}
\item Creating a core dump means to store the contents of the process virtual
address space to a file.  Usually such file has a word \texttt{core} in its
filename.  Some systems, eg. macOS, may not generate core dumps by default even
if its for signals with default core dump action.
\item Most of the signals implicitly terminate the process, some create a core
dump on top of that to enable a post-mortem analysis.
\item The reason why \funnm{exec} replaces all user set handlers to its implicit
action (see also page \pageref{EXEC}) is obvious -- code of the original
handlers no longer exists after the \funnm{exec} call finishes.
\item You can learn the signal numbers and their names using the \texttt{-l}
option for the \texttt{kill(1)} command.  Without the argument, it will print
the list of all signals with their corresponding numbers.  Example:

\begin{verbatim}
$ kill -l SIGPIPE
13
\end{verbatim}
\item For each signal, you can learn what is its implicit action by checking a
manual page for function \funnm{signal} or possibly for \emph{signal.h}.
\end{itemize}

%%%%%

\pdfbookmark[1]{Signal listing}{siglist}

\begin{slide}
\sltitle{Signal listing (1)}

We could divide signals into a few groups\dots

\emsl{Detected errors:}

\begin{tabular}{ll}
\texttt{SIGBUS} & bus error, eg. wrong alignment (core) \\
\texttt{SIGFPE} & floating point exception (core) \\
\texttt{SIGILL} & illegal instructions (core) \\
\texttt{SIGPIPE} & write on a pipe with no reader (exit) \\
\texttt{SIGSEGV} & sigmentation violation (core) \\
\texttt{SIGSYS} & non-existent system call invoked (core) \\
\texttt{SIGXCPU} & CPU time limit exceeded (core) \\
\texttt{SIGXFSZ} & file size limit exceeded (core)\\
\end{tabular}
\end{slide}

\begin{itemize}
\item Those signals are generated on an error in a program.
\item For signals \texttt{SIGBUS}, \texttt{SIGFPE}, \texttt{SIGILL}, and
\texttt{SIGSEGV} the standard does not specify what exactly has to be the
reason but usually those are errors detected by hardware.
Examples: \example{signals/sigsegv.c}, \example{signals/div-by-zero.c}.
\item \label{SPECIALSIGNALS} \emsl{For those four signals, there are some
special rules as well} (for details, see section \emph{2.4 Signal Concepts} in
SUSv4):
\begin{itemize}
\item If set as ignored by function \funnm{sigaction}, the program behavior
after such a signal is delivered is undefined.
\item Return value of the handler is undefined.
\item If such a signal is masked while the signal is being delivered, the
program behavior is undefined.
\end{itemize}
\item Bottom line is that if a hardware generated error is real (ie. the signal
is not send via \funnm{kill} or similar functions), the process may never get
over that error at all.  It is not safe to ignore such errors, continue after
returning from a handler, or mask such signals.  You can catch such signals
though, the standard does not prohibit that.  However, if you do, you should do
so only to deal with the situation and exit.
You can check \example{signals/catch-SIGSEGV.c}. More information and another
example can be found on page \pageref{THREADS_SIGWAIT}.
\item Note: if the standard specifies any behavior as \emph{undefined}, it means
the specification does not state what should happend and that whatever happens
does not violate the standard.  So, if you trigger such a behavior and your
computer burns down or even flies off to the Moon, possibly still in flames,
that does not violate the standard either.
\end{itemize}

\begin{slide}
\sltitle{Signal listing (2)}

\emsl{Signals generated by a user or application:}

\begin{tabular}{ll}
\texttt{SIGABRT} & abort program (core) \\
\texttt{SIGHUP} & terminal line hangup (exit) \\
\texttt{SIGINT} & interrupt program via \texttt{Ctrl-C} (exit) \\
\texttt{SIGKILL} & kill program (exit, \emsl{cannot be caught or ignored})\\
\texttt{SIGQUIT} & quit program via \texttt{Ctrl-\bs} (core) \\
\texttt{SIGTERM} & software termination signal (exit) \\
\texttt{SIGUSR1} & user-defined signal 1 (exit) \\
\texttt{SIGUSR2} & user-defined signal 2 (exit) \\
\end{tabular}
\end{slide}

\begin{itemize}
\item Signal \texttt{SIGHUP} is often used as a way to let a daemon know its
configuration file changed and that it should re-read it.
\item \texttt{SIGINT} and \texttt{SIGQUIT} are usually generated from a terminal
via \texttt{Ctrl-C} and \texttt{Ctrl-\bs}, respectively, and could be redefined
using the command \texttt{stty} or via a function \funnm{tcsetattr}.  In order
to generate core files, your system must allow it.  Check command
\texttt{ulimit}.
\item \label{SIGKILL} As \texttt{SIGKILL} cannot be handled, use it only if you
know what you are doing.  For example, if a running process does not respond to
user input nor any signal.  Many applications, mainly daemons, rely on the fact
that they are sent \texttt{SIGTERM} on termination, which they often handle and
perform pre-exit actions.  For example, flushing the database, removing
temporary files and file locks, etc.  So, do not use \texttt{SIGKILL} right away
because "it's the simplest way to kill a process" as you might run in trouble.
\item Example on using \texttt{SIGQUIT} on Solaris:

\begin{verbatim}
$ sleep 10
^\Quit (core dumped)
$ mdb core
Loading modules: [ libc.so.1 ld.so.1 ]
> $c
libc.so.1`__nanosleep+0x15(8047900, 8047908)
libc.so.1`sleep+0x35(a)
main+0xbc(2, 8047970, 804797c)
_start+0x7a(2, 8047a74, 8047a7a, 0, 8047a7d, 8047b91)
>
\end{verbatim}
\item \texttt{SIGTERM} is the default signal for command \texttt{kill(1)}.
\item \texttt{SIGUSR1} and \texttt{SIGUSR2} are not used by any system call and
are available for use to the user.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Signal listing (3)}

\emsl{Job control:}

\begin{tabular}{ll}
\texttt{SIGCHLD} & child status has changed (ignore)\\
\texttt{SIGCONT} & continue after stop (continue) \\
\texttt{SIGSTOP} & stop (stop; \emsl{cannot be caught or ignored}) \\
\texttt{SIGTSTP} & stop from terminal \texttt{Ctrl-Z} (stop) \\
\texttt{SIGTTIN} & background read attempted from control terminal (stop) \\
\texttt{SIGTTOU} & background write attempted to control terminal (stop) \\
\end{tabular}

\end{slide}

\begin{itemize}
\item Those used to be part of a non-mandatory POSIX extension but now they are
required by POSIX.1-2008.  See also page \pageref{UNIXSTANDARDS}.
\item Only one process at any given time can read from its process group control
terminal but multiple processes can write to it at the same time.
\item Stopping a process group from a terminal, usually via \texttt{Ctrl-Z}, is
done with signal \texttt{SIGTSTP}, not \texttt{SIGSTOP}; a program thus can
catch the signal. \label{SIGTSTP}
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Signal listing (4)}

\emsl{Timers:}

\begin{tabular}{ll}
\texttt{SIGALRM} & timer expired (exit) \\
\texttt{SIGPROF} & profiling timer alarm (exit; see \funnm{setitimer}(2)) \\
\texttt{SIGVTALRM} & virtual time alarm (exit; also see \funnm{setitimer}(2)) \\
\end{tabular}

\emsl{Miscelaneous:}

\begin{tabular}{ll}
\texttt{SIGPOLL} & event occured on explicitly watched file descriptor (exit) \\
\texttt{SIGTRAP} & trace trap (core) \\
\texttt{SIGURG} & urgent condition present on socket (ignore) \\

\end{tabular}
\end{slide}

\begin{itemize}
\item \texttt{SIGALRM} and related function \funnm{alarm} is used for setting
timer alarms, useful for implementation of timeouts, for example.
\end{itemize}

%%%%%

\pdfbookmark[1]{sigaction}{sigaction}

\begin{slide}
\sltitle{Setting actions for signals}
\begin{minipage}{\slidewidth}\vspace{-1\baselineskip}\texttt{\begin{tabbing}
int \funnm{sigaction}(\=int \emph{sig},
const struct sigaction *\emph{act},\\\> struct sigaction *\emph{oact});
\end{tabbing}}
\end{minipage}
\begin{itemize}
\item assigns an action \emph{act} for a signal \emph{sig},
previous setting is returned in \emph{oact}, if non-zero
\item structure \texttt{sigaction} contains:
    \begin{itemize}
    \item \texttt{void (*\emph{sa\_handler})(int)} \dots{} \texttt{SIG\_DFL},
    \texttt{SIG\_IGN}, or a handler address (ie. a handler function name)
    \item \texttt{sigset\_t \emph{sa\_mask}} \dots{} signals blocked while in
    handler; plus \emph{sig} is blocked by default
    \item \texttt{int \emph{sa\_flags}} \dots{} \texttt{SA\_RESETHAND} (handler
    is reset to \texttt{SIG\_DFL} at the moment the signal is delivered),
    \texttt{SA\_RESTART} (restart pending calls), \texttt{SA\_NODEFER}
    (do not block \emph{sig} while in handler)
    \end{itemize}
\end{itemize}
\end{slide}

\begin{itemize}
\item kdy¾ je \texttt{act == NULL}, pouze se zjistí nastavení obsluhy, nemìní
se. Jestli¾e nás pøedchozí nastavení nezajímá, lze pou¾ít \texttt{oact ==
NULL}.
\item pokud není nastaveno \texttt{SA\_RESTART}, systémová volání aktivní v
bodì pøíchodu signálu skonèí s chybou \texttt{EINTR}.  Restartování nemusí
fungovat pro v¹echna systémová volání, napø. na FreeBSD je \texttt{select}
pøeru¹en signálem v¾dy, i kdy¾ je nastaveno \texttt{SA\_RESTART} (pozn: nemusí
být pravda u souèasných verzí, nezkou¹el jsem to na nich).
\item pozor na problém vzájemného vylouèení mezi procesem a handlerem, popø.
mezi handlery pro rùzné signály. Jestli¾e je nastaveno \texttt{SA\_NODEFER},
mìl by být handler reentrantní.
\item \label{ASYNCSIGNALSAFE} \emsl{v handleru signálu by se mìly pou¾ívat pouze
funkce, které jsou pro takové pou¾ití bezpeèné.} Musí buï být reentrantní, nebo
je nutné zajistit, aby nepøi¹el signál v nevhodnou dobu (napø. uvnitø funkce
pøijde signál, v jeho¾ handleru se volá stejná funkce). Minimální skupina
funkcí, které musí být tzv. \emsl{\emph{async-signal-safe}}, je vyjmenována v
SUSv3 v sekci \emph{System Interfaces: General Information $\Rightarrow$ Signal
Concepts $\Rightarrow$ Signal Actions (2.4.3)}. Jednotlivé systémy mohou
samozøejmì definovat i dal¹í takové funkce. Zda funkce je nebo není bezpeènì
pou¾itelná v handleru by mìlo být jasné z manuálové stránky; na Solarisu je tato
informace v¾dy v sekci \emph{ATTRIBUTES}.
\item proè mù¾e nastat problém, kdy¾ pou¾ijete v handleru signálu jinou funkci
ne¾ async-signal-safe? Je to jednoduché -- pøedstavte si, ¾e kdy¾ program
vykonává funkci, která není async-signal-safe, pøijde signál a v handleru se
vyvolá funkce stejná. Pokud funkce není pro takové pou¾ití napsaná, tak mù¾e
dojít napøíklad k nekonzistenci statických dat ve funkci pou¾itých, pøípadnì k
uváznutí (dead lock) apod. Právì kvùli tomu, ¾e v handlerech lze bezpeènì pou¾ít
jen podmno¾inu existujících volání, se v handleru èasto pouze nastaví globální
promìnná oznaèující pøíchod pøíslu¹ného signálu a ta se následnì testuje,
napøíklad v cyklu serveru, který vyøizuje po¾adavky nebo programu který
zpracovává události. Zpomalení obsluhy signálu je minimální, proto¾e funkce
která èeká na dal¹í po¾adavek je typicky pøeru¹itelná signálem a v takovém
pøípadì ihned vrací \texttt{EINTR}. Následuje kontrola globální(ch)
promìnné(ých) na to, zda byl pøijmut nìjaký signál.
Viz pøíklad \example{signals/event-loop.c}.
\item funkce \texttt{sigaction} je obecnìj¹í ne¾ star¹í funkce
\texttt{signal} a \texttt{sigset}, kte\-ré zde ani nezmiòuji. Doporuèuji
pou¾ívat pouze \texttt{sigaction}. Pou¾ití \texttt{signal} není napøíklad
správné s vlákny, viz specifikace: ``Use of this function is unspecified in a
multi-threaded process.''
\item \label{SIGNAL_VS_SIGACTION} Pozor na to, ¾e chování funkce
\texttt{signal()} se mù¾e li¹it podle systému. Na\-pøík\-lad na FreeBSD zùstává
handler stále nastaven, na Solarisu je z dùvodu zachování zpìtné kompatibility
handler pøed jeho vyvoláním resetován na \texttt{SIG\_DFL}. Funkce pøíznaku
\texttt{SA\_RESETHAND} je právì to, aby bylo mo¾né simulovat pùvodní chování
funkce \texttt{signal()}, které bývá implementováno pomocí systémového volání
\texttt{sigaction()}. Pøíklad na rozdíl mezi funkcemi \texttt{signal()} a
\texttt{sig\-action()}: \example{signal/signal-vs-sigaction.c}.
\item (nebudete nejspí¹ potøebovat) pro výskok z handleru signálu jinam ne¾ na
místo vzniku signálu se dají pou¾ít funkce \texttt{sigsetjmp} a
\texttt{siglongjmp}. Pozor na to, ¾e v tomto pøípadì si musíme být jisti, ¾e v
okam¾iku pøíchodu signálu není program uvnitø ne-reentrantní funkce. Výskokem z
handleru do hlavního programu není vykonávání takové funkce ukonèeno a mohou
nastat stejné problémy jako pøi volání ne-reentrantní funkce pøímo z handleru.
\item \label{REALTIMEEXTENSIONS} If your system supports a part of POSIX.1b
called \emph{Realtime Signals Extension} (RTS), it is possible to use the
extension if you use flag \texttt{SA\_SIGINFO}.  In that case a
\texttt{sa\_sigaction} member of the structure \texttt{sigaction} must be used
for the handler, not \texttt{sa\_handler}.  The new handler has three parameters
and it is possible to learn the PID of a signalling process, its UID, and more.
See manual page \texttt{signal.h(3HEAD)} on Solaris, the online SUS
specification of the header file, or the book [POSIX.4], page
\pageref{REF_PROGRAMMING}.  More information is also on page \pageref{POSIX} and
\pageref{SIGWAITINFO}.  Examples: \example{sig\-nals/siginfo.c},
\example{sig\-nals/sigqueue.c}.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Pøíklad: èasovì omezený vstup}
\setlength{\baselineskip}{0.8\baselineskip}
\begin{alltt}
void handler(int sig)
\{ write(2," !!! TIMEOUT !!! \bs{}n", 17); \}

int main(void) 
\{
    char buf[1024]; struct sigaction act; int sz;
    act.sa\_handler = handler;
    \emprg{sigemptyset}(&act.sa\_mask);
    act.sa\_flags = 0;
    \emprg{sigaction}(SIGALRM, &act, NULL);
    \emprg{alarm}(5);
    sz = read(0, buf, 1024);
    alarm(0);
    if (sz > 0)
        write(1, buf, sz);
    return (0);
\}
\end{alltt}
\end{slide}

\label{SIGALRM}

\begin{itemize}
\item lze pou¾ívat i èasovaèe s jemnìj¹ím rozli¹ením ne¾ 1 s.
Nastavují a testují se funkcemi \texttt{setitimer} a
\texttt{getitimer}. Pøi vypr¹ení posílají signály procesu, který
èasovaèe nastavil podle prvního argumentu \emph{which}:
\begin{itemize}
\item \texttt{ITIMER\_REAL} \dots{} mìøí reálný èas, posílá \texttt{SIGALRM}
\item \texttt{ITIMER\_VIRTUAL} \dots{} mìøí virtuální èas (pouze èas, kdy proces
bì¾í), posílá \texttt{SIGVTALRM}
\item \texttt{ITIMER\_PROF} \dots{} mìøí virtuální èas a èas, kdy systém bì¾í
na konto procesu, posílá \texttt{SIGPROF}
\end{itemize}
\item pozn: v¹imìte si, ¾e aèkoliv by to svádìlo pou¾ít pro tisk hlá¹ky v
pøíkladu funkci \texttt{fprintf} apod., nemusel by to být dobrý nápad, proto¾e
nemusí být bezpeèná pro pou¾ití v handleru signálu, viz strana
\pageref{ASYNCSIGNALSAFE}.
\item pøíklad: \example{signals/alarm.c}
\end{itemize}

%%%%%

\pdfbookmark[1]{sigprocmask, sigpending}{sigblock}

\begin{slide}
\sltitle{Blokování signálù}
\begin{itemize}
\item blokované signály budou procesu doruèeny a zpracovány a¾ po
odblokování. 
\end{itemize}
\begin{minipage}{\slidewidth}\texttt{\begin{tabbing}
int \funnm{sigprocmask}(\=int \emph{how}, const sigset\_t *\emph{set},\\
\>sigset\_t *\emph{oset});
\end{tabbing}}
\end{minipage}
\begin{itemize}
\item nastaví masku blokovaných signálù a vrátí starou masku. 
\item \emph{how} -- \texttt{SIG\_BLOCK} pro pøidání signálù co se mají
blokovat, pro odebrání \texttt{SIG\_UNBLOCK}, pro
kompletní zmìnu masky \texttt{SIG\_SETMASK}
\item pro manipulaci s maskou signálù slou¾í funkce:
\texttt{sigaddset()}, \texttt{sigdelset()}, \texttt{sigemptyset()},
\texttt{sigfillset()}, \texttt{sigismember()}
\end{itemize}
\texttt{int \funnm{sigpending}(sigset\_t *\emph{set});}
\begin{itemize}
\item vrátí èekající zablokované signály.
\end{itemize}
\end{slide}

\label{SIGPROCMASK}

\begin{itemize}
\item Je rozdíl mezi ignorováním a blokováním signálu. Ignorovaný signál jádro
zahodí a proces ho nedostane, blokovaný signál proces dostane po jeho
odblokování.
\item Závisí na implementaci, zda pøi vícenásobném doruèení stejného signálu
procesu, který má tento signál zablokovaný, bude signál po odblokování o¹etøen
jednou nebo vícekrát.
\item V pøípadì roz¹íøení signálù z POSIX.4 (strana
\pageref{REALTIMEEXTENSIONS}), tj. pou¾ití pøíznaku \texttt{SA\_SIGINFO}, jsou
signály doruèované pøes frontu a tedy se ¾ádný násobný výs\-kyt stejného signálu
neztratí.
\item Argument \texttt{oset} pro získání pùvodní masky mù¾e být \texttt{NULL},
stejnì jako mù¾e být nastavený na \texttt{NULL} i parametr druhý, tj.
\texttt{set}. Ve speciálním pøípadì, kdy jsou oba parametry nulové, funkce
\texttt{sigprocmask} nedìlá nic.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Pøíklad: blokování signálù}
\setlength{\baselineskip}{0.8\baselineskip}
\begin{alltt}
sigset\_t sigs, osigs; struct sigaction sa;
sigfillset(&sigs); \emprg{sigprocmask}(SIG\_BLOCK, &sigs, &osigs);
switch(cpid = fork()) \{
    case -1: /* Chyba */
        \emprg{sigprocmask}(SIG\_SETMASK, &osigs, NULL);
        ...
    case 0: /* Synovský proces */
        sa.sa\_handler = h\_cld; sigemptyset(&sa.sa\_mask);
        sa.sa\_flags = 0;
        \emprg{sigaction}(SIGINT, &sa, NULL);
        \emprg{sigprocmask}(SIG\_SETMASK, &osigs, NULL);
        ...
    default: /* Rodièovský proces */
        \emprg{sigprocmask}(SIG\_SETMASK, &osigs, NULL);
        ...
\}
\end{alltt}
\end{slide}

\begin{itemize}
\item \label{SIGNALBLOCKINGEXAMPLE} pøíklad ukazuje situaci, kdy proces vytváøí
potomky pomocí \texttt{fork} a je potøeba, aby potomci mìli jiný handler
signálù ne¾ rodièovský proces. Funguje to proto, ¾e volání \texttt{fork} nemìní
masky signálù, viz strana
\pageref{FORK}.
\item pro jednoduchost v pøíkladu blokuji v¹echny signály, i kdy¾ na stranách
\pageref{SPECIALSIGNALS} a \pageref{THREADS_SIGWAIT} je vysvìtleno, proè to není
správné pou¾ití maskování.
\item blokování je vhodné pou¾ít tam, kde o¹etøení pøeru¹ení uprostøed
posloupnosti operací by bylo pøíli¹ slo¾ité, nebo kde korektní o¹etøení není
jinak mo¾né. V uvedeném pøíkladì by bez blokování signálù mohl synovský proces
dostat signál døív, ne¾ stihne zmìnit handler.
\item dal¹í pøíklad je proces, který pøi vypr¹ení timeoutu pøeru¹í provádìnou
posloupnost operací voláním \texttt{siglongjmp} zevnitø handleru signálu. Je
po\-tøe\-ba zablokovat signál \texttt{SIGALRM} bìhem provádìní atomických
podposloupností (tj. takových, které se musí provést buï celé, nebo vùbec ne).
\end{itemize}

%%%%%

\label{SIGWAIT}
\pdfbookmark[1]{pause, sigsuspend, sigwait}{sigwait}

\begin{slide}
\sltitle{Èekání na signál}
\texttt{int \funnm{pause}(void);}
\begin{itemize}
\item pozastaví volající proces do pøíchodu (neblokovaného) signálu
\end{itemize}
\texttt{int \funnm{sigsuspend}(const sigset\_t *\emph{sigmask});}
\begin{itemize}
\item jako \texttt{pause()}, ale navíc po dobu èekání masku
blokovaných signálù zmìní na \texttt{sigmask}
\end{itemize}
\texttt{int \funnm{sigwait}(const sigset\_t *\emph{set}, int *\emph{sig});}
\begin{itemize}
\item èeká na pøíchod signálu z mno¾iny \texttt{set} (tyto signály
musí být pøedtím zablokované), èíslo signálu vrátí v \texttt{sig}. Vrací 0 nebo
èíslo chyby.
\item nevolá se handler signálu (to ale není v normì jednoznaènì
definováno)
\end{itemize}
\end{slide}

\begin{itemize}
\item Neblokovaný signál v \texttt{pause} a \texttt{sigsuspend} vyvolá handler a
po jeho skonèení program opustí signál zachycující funkci a pokraèuje dále.
Pokud má ale signál proces ukonèit (napø. nemaskovaný \texttt{SIGTERM} bez
handleru), stane se tak.
\item Pomocí tìchto funkcí a blokování signálù se implementuje synchronní
obsluha signálù. Proces nejprve zablokuje signály, které ho zajímají, a pak na
nì ve vhod\-ných chvílích buï èeká, nebo jen testuje (pomocí
\texttt{sigpending}), zda signál pøi¹el, a pokud ne, pokraèuje dál.
\item \label{SIGWAIT} Funkce \texttt{sigwait} byla pøidána s POSIX-1003.1c
roz¹íøením (vlákna) a je to ``jediný'' správný zpùsob, jak obsluhovat
asynchronní signály v multi-vláknové aplikaci. To ¾e byla pøidána s vlákny je
potvrzeno i tím, ¾e v pøípadì problémù vrací pøímo èíslo chyby.
\item \label{SIGWAITINFO} Existují i pøíbuzné
podobnì se jmenující funkce \texttt{sigwaitinfo} a \texttt{sigtimedwait},
definované s roz¹íøením POSIX-1003.1\emsl{b} (real-time). Fungují na podobném
principu, ale na rozdíl od \texttt{sigwait} pracují s \texttt{errno} a je z nich
mo¾né získat více informací díky struktuøe \texttt{siginfo\_t}, viz strana
\pageref{REALTIMEEXTENSIONS}. Je tedy mo¾né je pou¾ít místo \texttt{sigwait}.
\item Pøíklad (signál se pou¾ije pro synchronizaci dvou procesù komunikujících
pøes sdílenou pamì»): \example{signals/sigwait.c}
\item \emsl{Pozor} na to, ¾e byste nemìli tento zpùsob obsluhy signálù pou¾ívat
pro sig\-nály synchronní jako jsou \texttt{SIGSEGV}, \texttt{SIGILL}, apod. Více
se doètete na stranách \pageref{SPECIALSIGNALS} a \pageref{THREADS_SIGWAIT}. 
\end{itemize}

\endinput
