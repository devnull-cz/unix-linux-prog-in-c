
\pdfbookmark[0]{signals}{signals}
\begin{slide}
\sltitle{Obsah}
\begin{itemize}
\item úvod, vývoj UNIXu a C, programátorské nástroje
\item základní pojmy a konvence UNIXu a jeho API
\item pøístupová práva, periferní zaøízení, systém souborù
\item process manipulation, program execution
\item \emsl{signály}
\item synchronizace a komunikace procesù
\item sí»ová komunikace
\item vlákna, synchronizace vláken
\item ??? - bude definováno pozdìji, podle toho kolik zbyde èasu
\end{itemize}
\end{slide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

changequote([[[, ]]])

\begin{slide}
\sltitle{Introduction to signals}
\begin{itemize}
\item for notifying a process of asynchronous events, and for exception handling
\item mechanism of an interrupt available in user level
\item signal categories:
    \begin{itemize}
    \item \emsl{asynchronous events} happening independently of the main program
    flow, eg. a signal sent from another process, a timer expiration
    (\texttt{SIGALRM}), terminal disconnect (\texttt{SIGHUP}), or pressing
    \texttt{Ctrl-C} (\texttt{SIGINT})
    \item \emsl{exceptions} caused by a running process, eg.
    attempt to access a restricted area of memory (\texttt{SIGSEGV})
    \end{itemize}
\end{itemize}
\end{slide}

\label{SIGNALS}

\begin{itemize}
\item Interrupts can be viewed as a mean of communication between the CPU and
the OS kernel while signals are for communication between the kernel and
processes.
\item After returning from the handler, if that happens, the process continues
exactly from the place where the interruption happened.
\item Historically, signals were provided as a mechanism to forcefully terminate
processes.  That is why the function for sending signals is called
\funnm{kill}.
\item A nice example of an asynchronous event is while on Linux you send
a \texttt{SIGUSR1} to the \texttt{dd} command to print I/O statistics to
standard error output.  Start \texttt{dd} first, then send a couple of
\texttt{USR1} signals its way, like this:

\begin{verbatim}
$ kill -USR1 $(pgrep -f "dd if=/dev/zero of=/dev/null")
\end{verbatim}

You will see something like this:

\begin{verbatim}
$ dd if=/dev/zero of=/dev/null
9179287+0 records in
9179286+0 records out
4699794432 bytes (4.7 GB, 4.4 GiB) copied, 1.79083 s, 2.6 GB/s
14211424+0 records in
14211423+0 records out
7276248576 bytes (7.3 GB, 6.8 GiB) copied, 2.76889 s, 2.6 GB/s
\end{verbatim}
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Introduction to signals (continued)}
\begin{itemize}
\item it is the simplest interprocess communication -- it only carries
information that an event happened
\begin{itemize}
\item there is a real-time POSIX extension that allows for more information,
more on that later
\end{itemize}
\item mostly processed asynchronously -- a signal interrupts the current process
flow and a \emph{signal handler} is invoked
\item signals are identified by numbers, represented by names like
\texttt{SIGSEGV}, \texttt{SIGCHLD}, or \texttt{SIGKILL}
\item name are usually \texttt{\#define}s, see \texttt{/usr/include/signal.h} or
\texttt{/usr/include/sys/signal.h}
\end{itemize}
\end{slide}

\begin{itemize}
\item The real-time extension is POSIX-1003.1b.
\pageref{REALTIMEEXTENSIONS}.
\item You can process signals in a synchronous way, see \funnm{sigwait} on page
\pageref{SIGWAIT}.
\end{itemize}

%%%%%

\pdfbookmark[1]{kill}{kill}

\begin{slide}
\sltitle{Sending signals}
\texttt{int \funnm{kill}(pid\_t \emph{pid}, int \emph{sig});}
\begin{itemize}
\item sends signal \emph{sig} to a process or a process group
based on value of \emph{pid}: 
    \begin{itemize}
    \item \texttt{> 0} \dots{} to process with \emph{pid}
    \item \texttt{== 0} \dots{} to all processes in the same group
    \item \texttt{== -1} \dots{} to all aside from system processes
    \item \texttt{< -1} \dots{} to processes in a group \texttt{abs(pid)} 
    \end{itemize}
\item \texttt{sig == 0} means the system only checks whether the process has
enough privileges to send a signal without sending it
\item whether a process may send other process a signal depends on UID of both
processes
\end{itemize}
\end{slide}

\label{KILLSYSCALL}

\begin{itemize}
\item Traditionally, process with EUID~==~0 can send a signal to any other
process.  However, some systems optionally provide fine grain privileges and the
situation there is different even for root.  That is out of scope for this class
though.  \item Sending a signal to another process:
    \begin{itemize}
    \item Linux, Solaris: RUID or EUID of the process that sent the signal must
    match the real UID or saved SUID of the target process.
    \item FreeBSD: EUID of the processes must match
    \end{itemize}
\item Example: \example{signals/killing-myself.c}
\item 0 signal can be also used for a simple check for the specific process
existence, see \example{signals/check-existence.c}.
\end{itemize}

%%%%%

\pdfbookmark[1]{Handling signals}{sighandle}

\begin{slide}
\sltitle{Handling signals}
\begin{itemize}
\item unless a process sets it otherwise, each signal triggers a specific
default action, one of:
    \begin{itemize}
    \item terminate the process (\emsl{exit}) 
    \item terminate and dump a core (\emsl{core})
    \item ignore the signal (\emsl{ignore})
    \item stop the process (\emsl{stop})
    \item resume the process (\emsl{continue}) 
    \end{itemize}
\item process can either set to ignore a specific signal\dots
\item \dots{}or can handle the signal via a user-defined function,
called a \emsl{handler}
\end{itemize}

Signals \texttt{SIGKILL} and \texttt{SIGSTOP} \emsl{always} trigger an implicit
action, ie. exit or stop, respectively.
\end{slide}

\begin{itemize}
\item Creating a core dump means to store the contents of the process virtual
address space to a file.  Usually such file has a word \texttt{core} in its
filename.  Some systems, eg. macOS, may not generate core dumps by default even
if its for signals with default core dump action.
\item Most of the signals implicitly terminate the process, some create a core
dump on top of that to enable a post-mortem analysis.
\item The reason why \funnm{exec} replaces all user set handlers to its implicit
action (see also page \pageref{EXEC}) is obvious -- code of the original
handlers no longer exists after the \funnm{exec} call finishes.
\item You can learn the signal numbers and their names using the \texttt{-l}
option for the \texttt{kill(1)} command.  Without the argument, it will print
the list of all signals with their corresponding numbers.  Example:

\begin{verbatim}
$ kill -l SIGPIPE
13
\end{verbatim}
\item For each signal, you can learn what is its implicit action by checking a
manual page for function \funnm{signal} or possibly for \emph{signal.h}.
\end{itemize}

%%%%%

\pdfbookmark[1]{Signal listing}{siglist}

\begin{slide}
\sltitle{Signal listing (1)}

We could divide signals into a few groups\dots

\emsl{Detected errors:}

\begin{tabular}{ll}
\texttt{SIGBUS} & bus error, eg. wrong alignment (core) \\
\texttt{SIGFPE} & floating point exception (core) \\
\texttt{SIGILL} & illegal instructions (core) \\
\texttt{SIGSEGV} & sigmentation violation (core) \\
\texttt{SIGPIPE} & write on a pipe with no reader (exit) \\
\texttt{SIGSYS} & non-existent system call invoked (core) \\
\texttt{SIGXCPU} & CPU time limit exceeded (core) \\
\texttt{SIGXFSZ} & file size limit exceeded (core)\\
\end{tabular}
\end{slide}

\begin{itemize}
\item Those signals are generated on an error in a program.
\item For the first four signals -- \texttt{SIGBUS}, \texttt{SIGFPE},
\texttt{SIGILL}, and \texttt{SIGSEGV} the standard does not specify what exactly
has to be the reason but usually those are errors detected by hardware.
Try the following examples, and check the return value with ``\texttt{kill -l
\$?}'': \example{signals/sigsegv.c},
\example{signals/div-by-zero.c}.
\item \label{SPECIALSIGNALS} \emsl{For those four signals, there are some
special rules as well} (for details, see section \emph{2.4 Signal Concepts} in
SUSv4):
\begin{itemize}
\item If set as ignored by function \funnm{sigaction}, the program behavior
after such a signal is delivered is undefined.
\item The behavior of a process is undefined after it returns from a
signal-catching function.
\item If such a signal is masked while the signal is being delivered, the
program behavior is undefined.
\end{itemize}
\item Bottom line is that if a hardware generated error is real (ie. the signal
is not send via \funnm{kill} or similar functions), the process may never get
over that error at all.  It is not safe to ignore such errors, continue after
returning from a handler, or mask such signals.  You can catch such signals
though, the standard does not prohibit that.  However, if you do, you should do
so only to deal with the situation and exit.
You can check \example{signals/catch-SIGSEGV.c}. More information and another
example can be found on page \pageref{THREADS_SIGWAIT}.
\item Note: if the standard specifies any behavior as \emph{undefined}, it means
the specification does not state what should happend and that whatever happens
does not violate the standard.  So, if you trigger such a behavior and your
computer burns down or even flies off to the Moon, possibly still in flames,
that does not violate the standard either.
\end{itemize}

\begin{slide}
\sltitle{Signal listing (2)}

\emsl{Signals generated by a user or application:}

\begin{tabular}{ll}
\texttt{SIGABRT} & abort program (core) \\
\texttt{SIGHUP} & terminal line hangup (exit) \\
\texttt{SIGINT} & interrupt program via \texttt{Ctrl-C} (exit) \\
\texttt{SIGKILL} & kill program (exit, \emsl{cannot be caught or ignored})\\
\texttt{SIGQUIT} & quit program via \texttt{Ctrl-\bs} (core) \\
\texttt{SIGTERM} & software termination signal (exit) \\
\texttt{SIGUSR1} & user-defined signal 1 (exit) \\
\texttt{SIGUSR2} & user-defined signal 2 (exit) \\
\end{tabular}
\end{slide}

\begin{itemize}
\item Signal \texttt{SIGHUP} is often used as a way to let a daemon know its
configuration file changed and that it should re-read it.
\item \texttt{SIGINT} and \texttt{SIGQUIT} are usually generated from a terminal
via \texttt{Ctrl-C} and \texttt{Ctrl-\bs}, respectively, and could be redefined
using the command \texttt{stty} or via a function \funnm{tcsetattr}.  In order
to generate core files, your system must allow it.  Check command
\texttt{ulimit}.
\item \label{SIGKILL} As \texttt{SIGKILL} cannot be handled, use it only if you
know what you are doing.  For example, if a running process does not respond to
user input nor any signal.  Many applications, mainly daemons, rely on the fact
that they are sent \texttt{SIGTERM} on termination, which they often handle and
perform pre-exit actions.  For example, flushing the database, removing
temporary files and file locks, etc.  So, do not use \texttt{SIGKILL} right away
only because "it's the simplest way to kill a process" as you might run in
trouble.
\item Example on using \texttt{SIGQUIT} on Solaris:

\begin{verbatim}
$ sleep 10
^\Quit (core dumped)
$ mdb core
Loading modules: [ libc.so.1 ld.so.1 ]
> $c
libc.so.1`__nanosleep+0x15(8047900, 8047908)
libc.so.1`sleep+0x35(a)
main+0xbc(2, 8047970, 804797c)
_start+0x7a(2, 8047a74, 8047a7a, 0, 8047a7d, 8047b91)
>
\end{verbatim}
\item \texttt{SIGTERM} is the default signal for command \texttt{kill(1)}.
\item \texttt{SIGUSR1} and \texttt{SIGUSR2} are not used by any system call and
are available for use to the user.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Signal listing (3)}

\emsl{Job control:}

\begin{tabular}{ll}
\texttt{SIGCHLD} & child status has changed (ignore)\\
\texttt{SIGCONT} & continue after stop (continue) \\
\texttt{SIGSTOP} & stop (stop; \emsl{cannot be caught or ignored}) \\
\texttt{SIGTSTP} & stop from terminal \texttt{Ctrl-Z} (stop) \\
\texttt{SIGTTIN} & background read attempted from control terminal (stop) \\
\texttt{SIGTTOU} & background write attempted to control terminal (stop) \\
\end{tabular}

\end{slide}

\begin{itemize}
\item Those used to be part of a non-mandatory POSIX extension but now they are
required by POSIX.1-2008.  See also page \pageref{UNIXSTANDARDS}.
\item Only one process at any given time can read from its process group control
terminal but multiple processes can write to it at the same time.
\item Stopping a process group from a terminal, usually via \texttt{Ctrl-Z}, is
done with signal \texttt{SIGTSTP}, not \texttt{SIGSTOP}; a program thus can
catch the signal. \label{SIGTSTP}
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Signal listing (4)}

\emsl{Timers:}

\begin{tabular}{ll}
\texttt{SIGALRM} & timer expired (exit) \\
\texttt{SIGPROF} & profiling timer alarm (exit; see \funnm{setitimer}(2)) \\
\texttt{SIGVTALRM} & virtual time alarm (exit; also see \funnm{setitimer}(2)) \\
\end{tabular}

\emsl{Miscelaneous:}

\begin{tabular}{ll}
\texttt{SIGPOLL} & event occured on explicitly watched file descriptor (exit) \\
\texttt{SIGTRAP} & trace trap (core) \\
\texttt{SIGURG} & urgent condition present on socket (ignore) \\

\end{tabular}
\end{slide}

\begin{itemize}
\item \texttt{SIGALRM} and related function \funnm{alarm} is used for setting
timer alarms, useful for implementation of timeouts, for example.
\end{itemize}

%%%%%

\pdfbookmark[1]{sigaction}{sigaction}

\begin{slide}
\sltitle{Setting actions for signals}
\begin{minipage}{\slidewidth}\vspace{-1\baselineskip}\texttt{\begin{tabbing}
int \funnm{sigaction}(\=int \emph{sig},
const struct sigaction *\emph{act},\\\> struct sigaction *\emph{oact});
\end{tabbing}}
\end{minipage}
\begin{itemize}
\item assigns an action \emph{act} for a signal \emph{sig},
previous setting is returned in \emph{oact}, if non-zero
\item structure \texttt{sigaction} contains:
    \begin{itemize}
    \item \texttt{void (*\emph{sa\_handler})(int)} \dots{} \texttt{SIG\_DFL},
    \texttt{SIG\_IGN}, or a handler address (ie. a handler function name)
    \item \texttt{sigset\_t \emph{sa\_mask}} \dots{} signals blocked while in
    handler; plus \emph{sig} is blocked by default
    \item \texttt{int \emph{sa\_flags}} \dots{} \texttt{SA\_RESETHAND} (handler
    is reset to \texttt{SIG\_DFL} at the moment the signal is delivered),
    \texttt{SA\_RESTART} (restart pending calls), \texttt{SA\_NODEFER}
    (do not block \emph{sig} while in handler)
    \end{itemize}
\end{itemize}
\end{slide}

\begin{itemize}
\item If \texttt{act == NULL} you only get the present setting and nothing is
changed.  You are not interested in previous setting, use \texttt{NULL} for
\emph{oact}.
\item If \texttt{SA\_RESTART} is not set, the system call interrupted by the
signal will return an error with \texttt{errno} set to \texttt{EINTR} (some
calls actually return directly the \texttt{errno} value but that is not relevant
now).  However, resetting the call will not work for all system calls.  You
should consult the the documentation for your system if you intend to use it.
On Linux, check the \texttt{signal(7)} manual page.  Example:
\example{signals/interrupted-read.c}.
\item Beware of deadlocks (will be discussed in the chapter on synchronization).
If you set \texttt{SA\_NODEFER}, your handler needs to be reentrant.
\item \label{ASYNCSIGNALSAFE} \emsl{You should only use functions in a safe way
from a handler}.  By safe it is meant either use reentrant functions or you need
to make sure the signal is not delivered in the wrong time (for example, the
signal is delivered within a function and the same function is called from the
handler, and the function is not ready for that).  Minimal set of functions
that must be \emsl{\emph{async-signal-safe}} is listed in SUSv4 in section
\emph{System Interfaces: General Information $\Rightarrow$ Signal Concepts
$\Rightarrow$ Signal Actions (2.4.3)}.  Systems can extend the list, of course.
Whether a function is safe to use in a signal handler or not should be
documented in its manual page.
\item Using static data in a function would generally be a problem for its
asynchronous signal safety.  It can lead to corrupt data, deadlocks, etc.  As
the set of functions safe to use in a handler is limited, one way to use the
signals is only to set a global variable in the handler and test it later, for
example in a loop that processes some events.  As a function waiting for an
event is typically interruptible by a signal (see above), setting the global
variable and testing it later does not experience any real delay.  Example:
\example{signals/event-loop.c}.
\item There is also a simplified signal facility \funnm{signal}().  We recommend
to use \funnm{sigaction}() only.  Behavior of \funnm{signal}() is not specified
with threads, for example.  It can also behave in a very different way on
different systems, some keep the handler set after delivering the signal, some
reset it to \texttt{SIG\_DFL}.  Check \example{signals/signal-vs-sigaction.c} if
interested.
\item \label{REALTIMEEXTENSIONS} If your system supports a part of POSIX.1b
called \emph{Realtime Signals Extension} (RTS), it is possible to use the
extension if you use flag \texttt{SA\_SIGINFO}.  In that case a
\texttt{sa\_sigaction} member of the structure \texttt{sigaction} must be used
for the handler, not \texttt{sa\_handler}.  The new handler has three parameters
and it is possible to learn the PID of a signalling process, its UID, and more.
See manual page \texttt{signal.h(3HEAD)} on Solaris, the online SUS
specification of the header file, or the book [POSIX.4], page
\pageref{REF_PROGRAMMING}.  More information is also on page \pageref{POSIX} and
\pageref{SIGWAITINFO}.  Examples: \example{sig\-nals/siginfo.c},
\example{sig\-nals/sigqueue.c}.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Example: setting time limit for read}
\setlength{\baselineskip}{0.8\baselineskip}
\begin{alltt}
void handler(int sig)
\{ write(2," !!! TIMEOUT !!! \bs{}n", 17); \}

int main(void) 
\{
    char buf[1024]; struct sigaction act; int sz;
    act.sa\_handler = handler;
    \emprg{sigemptyset}(&act.sa\_mask);
    act.sa\_flags = 0;
    \emprg{sigaction}(SIGALRM, &act, NULL);
    \emprg{alarm}(5);
    sz = read(0, buf, 1024);
    alarm(0);
    if (sz > 0)
        write(1, buf, sz);
    return (0);
\}
\end{alltt}
\end{slide}

\label{SIGALRM}

\begin{itemize}
\item lze pou¾ívat i èasovaèe s jemnìj¹ím rozli¹ením ne¾ 1 s.
Nastavují a testují se funkcemi \texttt{setitimer} a
\texttt{getitimer}. Pøi vypr¹ení posílají signály procesu, který
èasovaèe nastavil podle prvního argumentu \emph{which}:
\begin{itemize}
\item \texttt{ITIMER\_REAL} \dots{} mìøí reálný èas, posílá \texttt{SIGALRM}
\item \texttt{ITIMER\_VIRTUAL} \dots{} mìøí virtuální èas (pouze èas, kdy proces
bì¾í), posílá \texttt{SIGVTALRM}
\item \texttt{ITIMER\_PROF} \dots{} mìøí virtuální èas a èas, kdy systém bì¾í
na konto procesu, posílá \texttt{SIGPROF}
\end{itemize}
\item pozn: v¹imìte si, ¾e aèkoliv by to svádìlo pou¾ít pro tisk hlá¹ky v
pøíkladu funkci \texttt{fprintf} apod., nemusel by to být dobrý nápad, proto¾e
nemusí být bezpeèná pro pou¾ití v handleru signálu, viz strana
\pageref{ASYNCSIGNALSAFE}.
\item Example: \example{signals/alarm.c}
\end{itemize}

%%%%%

\pdfbookmark[1]{sigprocmask, sigpending}{sigblock}

\begin{slide}
\sltitle{Blokování signálù}
\begin{itemize}
\item blokované signály budou procesu doruèeny a zpracovány a¾ po
odblokování. 
\end{itemize}
\begin{minipage}{\slidewidth}\texttt{\begin{tabbing}
int \funnm{sigprocmask}(\=int \emph{how}, const sigset\_t *\emph{set},\\
\>sigset\_t *\emph{oset});
\end{tabbing}}
\end{minipage}
\begin{itemize}
\item nastaví masku blokovaných signálù a vrátí starou masku. 
\item \emph{how} -- \texttt{SIG\_BLOCK} pro pøidání signálù co se mají
blokovat, pro odebrání \texttt{SIG\_UNBLOCK}, pro
kompletní zmìnu masky \texttt{SIG\_SETMASK}
\item pro manipulaci s maskou signálù slou¾í funkce:
\texttt{sigaddset()}, \texttt{sigdelset()}, \texttt{sigemptyset()},
\texttt{sigfillset()}, \texttt{sigismember()}
\end{itemize}
\texttt{int \funnm{sigpending}(sigset\_t *\emph{set});}
\begin{itemize}
\item vrátí èekající zablokované signály.
\end{itemize}
\end{slide}

\label{SIGPROCMASK}

\begin{itemize}
\item Je rozdíl mezi ignorováním a blokováním signálu. Ignorovaný signál jádro
zahodí a proces ho nedostane, blokovaný signál proces dostane po jeho
odblokování.
\item Závisí na implementaci, zda pøi vícenásobném doruèení stejného signálu
procesu, který má tento signál zablokovaný, bude signál po odblokování o¹etøen
jednou nebo vícekrát.
\item V pøípadì roz¹íøení signálù z POSIX.4 (strana
\pageref{REALTIMEEXTENSIONS}), tj. pou¾ití pøíznaku \texttt{SA\_SIGINFO}, jsou
signály doruèované pøes frontu a tedy se ¾ádný násobný výs\-kyt stejného signálu
neztratí.
\item Argument \texttt{oset} pro získání pùvodní masky mù¾e být \texttt{NULL},
stejnì jako mù¾e být nastavený na \texttt{NULL} i parametr druhý, tj.
\texttt{set}. Ve speciálním pøípadì, kdy jsou oba parametry nulové, funkce
\texttt{sigprocmask} nedìlá nic.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Pøíklad: blokování signálù}
\setlength{\baselineskip}{0.8\baselineskip}
\begin{alltt}
sigset\_t sigs, osigs; struct sigaction sa;
sigfillset(&sigs); \emprg{sigprocmask}(SIG\_BLOCK, &sigs, &osigs);
switch(cpid = fork()) \{
    case -1: /* Chyba */
        \emprg{sigprocmask}(SIG\_SETMASK, &osigs, NULL);
        ...
    case 0: /* Synovský proces */
        sa.sa\_handler = h\_cld; sigemptyset(&sa.sa\_mask);
        sa.sa\_flags = 0;
        \emprg{sigaction}(SIGINT, &sa, NULL);
        \emprg{sigprocmask}(SIG\_SETMASK, &osigs, NULL);
        ...
    default: /* Rodièovský proces */
        \emprg{sigprocmask}(SIG\_SETMASK, &osigs, NULL);
        ...
\}
\end{alltt}
\end{slide}

\begin{itemize}
\item \label{SIGNALBLOCKINGEXAMPLE} pøíklad ukazuje situaci, kdy proces vytváøí
potomky pomocí \texttt{fork} a je potøeba, aby potomci mìli jiný handler
signálù ne¾ rodièovský proces. Funguje to proto, ¾e volání \texttt{fork} nemìní
masky signálù, viz strana
\pageref{FORK}.
\item pro jednoduchost v pøíkladu blokuji v¹echny signály, i kdy¾ na stranách
\pageref{SPECIALSIGNALS} a \pageref{THREADS_SIGWAIT} je vysvìtleno, proè to není
správné pou¾ití maskování.
\item blokování je vhodné pou¾ít tam, kde o¹etøení pøeru¹ení uprostøed
posloupnosti operací by bylo pøíli¹ slo¾ité, nebo kde korektní o¹etøení není
jinak mo¾né. V uvedeném pøíkladì by bez blokování signálù mohl synovský proces
dostat signál døív, ne¾ stihne zmìnit handler.
\item dal¹í pøíklad je proces, který pøi vypr¹ení timeoutu pøeru¹í provádìnou
posloupnost operací voláním \texttt{siglongjmp} zevnitø handleru signálu. Je
po\-tøe\-ba zablokovat signál \texttt{SIGALRM} bìhem provádìní atomických
podposloupností (tj. takových, které se musí provést buï celé, nebo vùbec ne).
\end{itemize}

%%%%%

\label{SIGWAIT}
\pdfbookmark[1]{pause, sigsuspend, sigwait}{sigwait}

\begin{slide}
\sltitle{Èekání na signál}
\texttt{int \funnm{pause}(void);}
\begin{itemize}
\item pozastaví volající proces do pøíchodu (neblokovaného) signálu
\end{itemize}
\texttt{int \funnm{sigsuspend}(const sigset\_t *\emph{sigmask});}
\begin{itemize}
\item jako \texttt{pause()}, ale navíc po dobu èekání masku
blokovaných signálù zmìní na \texttt{sigmask}
\end{itemize}
\texttt{int \funnm{sigwait}(const sigset\_t *\emph{set}, int *\emph{sig});}
\begin{itemize}
\item èeká na pøíchod signálu z mno¾iny \texttt{set} (tyto signály
musí být pøedtím zablokované), èíslo signálu vrátí v \texttt{sig}. Vrací 0 nebo
èíslo chyby.
\item nevolá se handler signálu (to ale není v normì jednoznaènì
definováno)
\end{itemize}
\end{slide}

\begin{itemize}
\item Neblokovaný signál v \texttt{pause} a \texttt{sigsuspend} vyvolá handler a
po jeho skonèení program opustí signál zachycující funkci a pokraèuje dále.
Pokud má ale signál proces ukonèit (napø. nemaskovaný \texttt{SIGTERM} bez
handleru), stane se tak.
\item Pomocí tìchto funkcí a blokování signálù se implementuje synchronní
obsluha signálù. Proces nejprve zablokuje signály, které ho zajímají, a pak na
nì ve vhod\-ných chvílích buï èeká, nebo jen testuje (pomocí
\texttt{sigpending}), zda signál pøi¹el, a pokud ne, pokraèuje dál.
\item \label{SIGWAIT} Funkce \texttt{sigwait} byla pøidána s POSIX-1003.1c
roz¹íøením (vlákna) a je to ``jediný'' správný zpùsob, jak obsluhovat
asynchronní signály v multi-vláknové aplikaci. To ¾e byla pøidána s vlákny je
potvrzeno i tím, ¾e v pøípadì problémù vrací pøímo èíslo chyby.
\item \label{SIGWAITINFO} Existují i pøíbuzné
podobnì se jmenující funkce \texttt{sigwaitinfo} a \texttt{sigtimedwait},
definované s roz¹íøením POSIX-1003.1\emsl{b} (real-time). Fungují na podobném
principu, ale na rozdíl od \texttt{sigwait} pracují s \texttt{errno} a je z nich
mo¾né získat více informací díky struktuøe \texttt{siginfo\_t}, viz strana
\pageref{REALTIMEEXTENSIONS}. Je tedy mo¾né je pou¾ít místo \texttt{sigwait}.
\item Pøíklad (signál se pou¾ije pro synchronizaci dvou procesù komunikujících
pøes sdílenou pamì»): \example{signals/sigwait.c}
\item \emsl{Pozor} na to, ¾e byste nemìli tento zpùsob obsluhy signálù pou¾ívat
pro sig\-nály synchronní jako jsou \texttt{SIGSEGV}, \texttt{SIGILL}, apod. Více
se doètete na stranách \pageref{SPECIALSIGNALS} a \pageref{THREADS_SIGWAIT}. 
\end{itemize}

\endinput
