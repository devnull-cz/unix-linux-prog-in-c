%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pdfbookmark[0]{signály}{signals}
\begin{slide}
\sltitle{Obsah}
\begin{itemize}
\item úvod, vývoj UNIXu a C, programátorské nástroje
\item základní pojmy a konvence UNIXu a jeho API
\item pøístupová práva, periferní zaøízení, systém souborù
\item process manipulation, program execution
\item \emsl{signály}
\item synchronizace a komunikace procesù
\item sí»ová komunikace
\item vlákna, synchronizace vláken
\item ??? - bude definováno pozdìji, podle toho kolik zbyde èasu
%\item závìreèná v¹ehochu» podle toho, kolik zbude èasu (bezpeènost,
%locales, pseudoterminály, X Window) 
\end{itemize}
\end{slide}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Signály

changequote([[[, ]]])

\begin{slide}
\sltitle{Signals}
\begin{itemize}
\item for notifying a process of asynchronous events, and exception handling
\item mechanism of an interrupt available in user level
\item signal categories
    \begin{itemize}
    \item \emsl{exceptions} caused by a running process, eg.
    attempt to access a restricted area of memory (\texttt{SIGSEGV})
    \item \emsl{asynchronous events} happening independently of the main program
    flow, eg. a signal from another process, a timer expiration
    (\texttt{SIGALRM}), terminal disconnect (\texttt{SIGHUP}), or pressing
    \texttt{Ctrl-C} (\texttt{SIGINT})
    \end{itemize}
\item it is the simplest interprocess communication -- it only carries
information that an event happened
\item mostly processed asynchronously -- a signal interrupts the current process
flow and a \emph{signal handler} are invoked
\end{itemize}
\end{slide}

\label{SIGNALS}

\begin{itemize}
\item Interrupts can be viewed as a mean of communication between the CPU and
the OS kernel while signals are for communication between the kernel and
processes.
\item There is no other information bound to the signal other than its signal
number.  That is, unless the real-time extension POSIX-1003.1b is used, see page
\pageref{REALTIMEEXTENSIONS}.
\item After returning from the handler, if that happens, the process continues
exactly from the place where the interruption happened.
\item Historically, signals were provided as a mechanism to forcefully terminate
processes.  That is why the function for sending signals is called
\funnm{kill}.
\item You can process signals in a synchronous way, see \funnm{sigwait} on page
\pageref{SIGWAIT}.
\end{itemize}

%%%%%

\pdfbookmark[1]{kill}{kill}

\begin{slide}
\sltitle{Sending signals}
\texttt{int \funnm{kill}(pid\_t \emph{pid}, int \emph{sig});}
\begin{itemize}
\item sends signal \emph{sig} to a process or a process group
based on value of \emph{pid}: 
    \begin{itemize}
    \item \texttt{> 0} \dots{} to process with \emph{pid}
    \item \texttt{== 0} \dots{} to all processes in the same group
    \item \texttt{== -1} \dots{} to all aside from system processes
    \item \texttt{< -1} \dots{} to processes in a group \texttt{abs(pid)} 
    \end{itemize}
\item \texttt{sig == 0} means the system only checks whether the process has
enough privileges to send a signal without sending it
\item whether a process may send other process a signal depends on UID of both
processes
\end{itemize}
\end{slide}

\label{KILLSYSCALL}

\begin{itemize}
\item Traditionally, process with EUID~==~0 can send a signal to any other
process.  However, some systems optionally provide fine grain privileges and the
situation there is different even for root.  That is out of scope for this class
though.  \item Sending a signal to another process:
    \begin{itemize}
    \item Linux, Solaris: RUID or EUID of the process that sent the signal must
    match the real UID or saved SUID of the target process.
    \item FreeBSD: EUID of the processes must match
    \end{itemize}
\item Example: \priklad{signals/killing-myself.c}
\item 0 signal can be also used for a simple check for the specific process
existence, see \priklad{signals/check-existence.c}.
\end{itemize}

%%%%%

\pdfbookmark[1]{Handling signals}{sighandle}

\begin{slide}
\sltitle{Handling signals}
\begin{itemize}
\item unless a process sets it otherwise, each signal triggers a specific
default action, one of:
    \begin{itemize}
    \item terminate the process (\emsl{exit}) 
    \item terminate and dump a core (\emsl{core})
    \item ignore the signal (\emsl{ignore})
    \item stop the process (\emsl{stop})
    \item resume the process (\emsl{continue}) 
    \end{itemize}
\item process can either set to ignore a specific signal\dots
\item \dots{}or can handle the signal via a user-defined function,
called a \emsl{handler}
\end{itemize}

Signals \texttt{SIGKILL} and \texttt{SIGSTOP} \emsl{always} trigger an implicit
action, ie. exit or stop, respectively.
\end{slide}

\begin{itemize}
\item Creating a core dump means to store the contents of the process virtual
address space to a file.  Usually such file has a word \texttt{core} in its
filename.  Some systems, eg. macOS, may not generate core dumps by default even
if its for signals with default core dump action.
\item Most of the signals implicitly terminate the process, some create a core
dump on top of that to enable a post-mortem analysis.
\item The reason why \funnm{exec} replaces all user set handlers to its implicit
action (see also page \pageref{EXEC}) is obvious -- code of the original
handlers no longer exists after the \funnm{exec} call finishes.
\item You can learn the signal numbers and their names using the \texttt{-l}
option for the \texttt{kill(1)} command.  Without the argument, it will print
the list of all signals with their corresponding numbers.  Example:

\begin{verbatim}
$ kill -l SIGPIPE
13
\end{verbatim}
\item For each signal, you can learn what is its implicit action by checking a
manual page for function \funnm{signal} or possibly for \emph{signal.h}.
\end{itemize}

%%%%%

\pdfbookmark[1]{Signal listing}{siglist}

\begin{slide}
\sltitle{Signal listing (1)}

We could divide signals into a few groups\dots

\emsl{Detected errors:}

\begin{tabular}{ll}
\texttt{SIGBUS} & bus error, eg. wrong alignment (core) \\
\texttt{SIGFPE} & floating point exception (core) \\
\texttt{SIGILL} & illegal instructions (core) \\
\texttt{SIGPIPE} & write on a pipe with no reader (exit) \\
\texttt{SIGSEGV} & sigmentation violation (core) \\
\texttt{SIGSYS} & non-existent system call invoked (core) \\
\texttt{SIGXCPU} & CPU time limit exceeded (core) \\
\texttt{SIGXFSZ} & file size limit exceeded (core)\\
\end{tabular}
\end{slide}

\begin{itemize}
\item Those signals are generated on an error in a program.
\item For signals \texttt{SIGBUS}, \texttt{SIGFPE}, \texttt{SIGILL}, and
\texttt{SIGSEGV} the standard does not specify what exactly has to be the
reason but usually those are errors detected by hardware.
Examples: \priklad{signals/sigsegv.c}, \priklad{signals/div-by-zero.c}.
\item \label{SPECIALSIGNALS} \emsl{For those four signals, there are some
special rules as well} (for details, see section \emph{2.4 Signal Concepts} in
SUSv4):
\begin{itemize}
\item If set as ignored by function \funnm{sigaction}, the program behavior
after such a signal is delivered is undefined.
\item Return value of the handler is undefined.
\item If such a signal is masked while the signal is being delivered, the
program behavior is undefined.
\end{itemize}
\item Bottom line is that if a hardware generated error is real (ie. the signal
is not send via \funnm{kill} or similar functions), the process may never get
over that error at all.  It is not safe to ignore such errors, continue after
returning from a handler, or mask such signals.  You can catch such signals
though, the standard does not prohibit that.  However, if you do, you should do
so only to deal with the situation and exit.
You can check \priklad{signals/catch-SIGSEGV.c}. More information and another
example can be found on page \pageref{THREADS_SIGWAIT}.
\item Note: if the standard specifies any behavior as \emph{undefined}, it means
the specification does not state what should happend and that whatever happens
does not violate the standard.  So, if you trigger such a behavior and your
computer burns down or even flies off to the Moon, possibly still in flames,
that does not violate the standard either.
\end{itemize}

\begin{slide}
\sltitle{Pøehled signálù (2)}

\emsl{generované u¾ivatelem nebo aplikací:}

\begin{tabular}{ll}
\texttt{SIGABRT} & ukonèení procesu (core) \\
\texttt{SIGHUP} & odpojení terminálu (exit) \\
\texttt{SIGINT} & stisk speciální klávesy \texttt{Ctrl-C} (exit) \\
\texttt{SIGKILL} & zru¹ení procesu (exit, \emsl{nelze o¹etøit ani ignorovat})\\
\texttt{SIGQUIT} & stisk speciální klávesy \texttt{Ctrl-\bs} (core) \\
\texttt{SIGTERM} & zru¹ení procesu (exit) \\
\texttt{SIGUSR1} & u¾ivatelsky definovaný signál 1 (exit) \\
\texttt{SIGUSR2} & u¾ivatelsky definovaný signál 2 (exit) \\
\end{tabular}
\end{slide}

\begin{itemize}
\item signál \texttt{SIGHUP} se èasto pou¾ívá jako zpùsob, jak oznámit bì¾ícímu
démonu, ¾e se zmìnil jeho konfiguraèní soubor a má si ho proto znovu naèíst.
\item \texttt{SIGINT} a \texttt{SIGQUIT} jsou obvykle generovány z terminálu
(\texttt{Ctrl-C} a \texttt{Ctrl-\bs}) a lze je pøedefinovat pøíkazem
\texttt{stty} nebo pomocí funkce \texttt{tcsetattr}.
Pro to aby se mohl vygenerovat core file je zapotøebí mít to povolené v
systémové konfiguraci a limitech, v shellu se toho dosáhne pøíkazem
\texttt{ulimit}.
\item \label{SIGKILL} vzhledem k tomu, ¾e \texttt{SIGKILL} nelze zachytit, jej
pou¾ívejte jen v nutných pøí\-padech; typickým pøípadem je to, ¾e bì¾ící proces
ji¾ nelze ukonèit jiným signálem. Mnoho aplikací, hlavnì démonù, spoléhá na to,
¾e vynucené u\-kon\-èe\-ní signálem je pøes \texttt{SIGTERM}. Tento signál si
zachytí a provede ukonèovací operace -- napøíklad ulo¾ení aktuální databáze na
disk, smazání doèasných souborù apod. Pou¾ívat rovnou \texttt{SIGKILL} proto, ¾e
proces to ``v¾dycky zabije'', je neznalost vìci, která se vám mù¾e dost vymstít.
\item ukázka na \texttt{SIGQUIT} na Solarisu:

\begin{verbatim}
$ sleep 10
^\Quit (core dumped)
$ mdb core
Loading modules: [ libc.so.1 ld.so.1 ]
> $c
libc.so.1`__nanosleep+0x15(8047900, 8047908)
libc.so.1`sleep+0x35(a)
main+0xbc(2, 8047970, 804797c)
_start+0x7a(2, 8047a74, 8047a7a, 0, 8047a7d, 8047b91)
>
\end{verbatim}
\item \texttt{SIGTERM} je defaultní signál pro pøíkaz \texttt{kill(1)}
\item \texttt{SIGUSR1} a \texttt{SIGUSR2} nejsou pou¾ity ¾ádným systémovým
voláním a jsou plnì k dispozici u¾ivateli
\end{itemize}


%%%%%

\begin{slide}
\sltitle{Pøehled signálù (3)}

\emsl{job control:}

\begin{tabular}{ll}
\texttt{SIGCHLD} & zmìna stavu synovského procesu (ignore)\\
\texttt{SIGCONT} & pokraèování pozastaveného procesu (continue) \\
\texttt{SIGSTOP} & pozastavení (stop, \emsl{nelze o¹etøit ani ignorovat}) \\
\texttt{SIGTSTP} & pozastavení z terminálu \texttt{Ctrl-Z} (stop) \\
\texttt{SIGTTIN} & ètení z terminálu procesem na pozadí (stop) \\
\texttt{SIGTTOU} & zápis na terminál procesem na pozadí (stop) \\
\end{tabular}

\begin{itemize}
\item souèástí nepovinného POSIX roz¹íøení, existují pouze kdy¾ v
\texttt{<unistd.h>} je definováno makro \texttt{\_POSIX\_JOB\_CONTROL}
\end{itemize}

\end{slide}

\begin{itemize}
\item platí, ¾e nikdy není povoleno více procesùm najednou èíst z
kontrolního terminálu, ale více procesù najednou mù¾e na terminál
zapisovat.
\item pozastavení skupiny procesù spustìné z terminálu (èasto pøes
\texttt{Ctrl-Z}) se pro\-vádí signálem \texttt{SIGTSTP}, ne \texttt{SIGSTOP};
aplikace tedy tento signál mù¾e zachytit. \label{SIGTSTP}
\end{itemize}


%%%%%

\begin{slide}
\sltitle{Pøehled signálù (4)}

\emsl{èasovaèe:}

\begin{tabular}{ll}
\texttt{SIGALRM} & plánované èasové pøeru¹ení (exit) \\
\texttt{SIGPROF} & vypr¹ení profilujícího èasovaèe (exit) \\
\texttt{SIGVTALRM} & vypr¹ení virtuálního èasovaèe (exit) \\
\end{tabular}

\emsl{rùzné:}

\begin{tabular}{ll}
\texttt{SIGPOLL} & testovatelná událost (exit) \\
\texttt{SIGTRAP} & ladicí pøeru¹ení (core) \\
\texttt{SIGURG} & urgentní událost na soketu (ignore) \\

\end{tabular}
\end{slide}

\begin{itemize}
\item \texttt{SIGALRM} a související funkce \texttt{alarm} se pou¾ívají pro
odmìøování èasových intervalù v u¾ivatelském procesu (napø. pøi implementaci
timeoutù).
\end{itemize}

%%%%%

\pdfbookmark[1]{sigaction}{sigaction}

\begin{slide}
\sltitle{Nastavení obsluhy signálù}
\begin{minipage}{\slidewidth}\vspace{-1\baselineskip}\texttt{\begin{tabbing}
int \funnm{sigaction}(\=int \emph{sig},
const struct sigaction *\emph{act},\\\> struct sigaction *\emph{oact});
\end{tabbing}}
\end{minipage}
\begin{itemize}
\item nastaví obsluhu signálu \texttt{sig} podle \texttt{act} a
vrátí pøedchozí nastavení v~\texttt{oact}. 
\item obsah struktury \texttt{sigaction}: 
    \begin{itemize}
    \item \texttt{void (*\emph{sa\_handler})(int)} \dots{} \texttt{SIG\_DFL},
    \texttt{SIG\_IGN}, nebo adresa handleru 
    \item \texttt{sigset\_t \emph{sa\_mask}} \dots{} signály blokované v
    handleru, navíc je blokován signál \texttt{sig}
    \item \texttt{int \emph{sa\_flags}} \dots{} \texttt{SA\_RESETHAND} (pøi
    vstupu do handleru nastavit \texttt{SIG\_DFL}), \texttt{SA\_RESTART}
    (restartovat pøeru¹ená systémová volání), \texttt{SA\_NODEFER} (neblokovat
    signál \texttt{sig} bìhem obsluhy)
    \end{itemize}
\end{itemize}
\end{slide}

\begin{itemize}
\item kdy¾ je \texttt{act == NULL}, pouze se zjistí nastavení obsluhy, nemìní
se. Jestli¾e nás pøedchozí nastavení nezajímá, lze pou¾ít \texttt{oact ==
NULL}.
\item pokud není nastaveno \texttt{SA\_RESTART}, systémová volání aktivní v
bodì pøíchodu signálu skonèí s chybou \texttt{EINTR}.  Restartování nemusí
fungovat pro v¹echna systémová volání, napø. na FreeBSD je \texttt{select}
pøeru¹en signálem v¾dy, i kdy¾ je nastaveno \texttt{SA\_RESTART} (pozn: nemusí
být pravda u souèasných verzí, nezkou¹el jsem to na nich).
\item pozor na problém vzájemného vylouèení mezi procesem a handlerem, popø.
mezi handlery pro rùzné signály. Jestli¾e je nastaveno \texttt{SA\_NODEFER},
mìl by být handler reentrantní.
\item \label{ASYNCSIGNALSAFE} \emsl{v handleru signálu by se mìly pou¾ívat pouze
funkce, které jsou pro takové pou¾ití bezpeèné.} Musí buï být reentrantní, nebo
je nutné zajistit, aby nepøi¹el signál v nevhodnou dobu (napø. uvnitø funkce
pøijde signál, v jeho¾ handleru se volá stejná funkce). Minimální skupina
funkcí, které musí být tzv. \emsl{\emph{async-signal-safe}}, je vyjmenována v
SUSv3 v sekci \emph{System Interfaces: General Information $\Rightarrow$ Signal
Concepts $\Rightarrow$ Signal Actions (2.4.3)}. Jednotlivé systémy mohou
samozøejmì definovat i dal¹í takové funkce. Zda funkce je nebo není bezpeènì
pou¾itelná v handleru by mìlo být jasné z manuálové stránky; na Solarisu je tato
informace v¾dy v sekci \emph{ATTRIBUTES}.
\item proè mù¾e nastat problém, kdy¾ pou¾ijete v handleru signálu jinou funkci
ne¾ async-signal-safe? Je to jednoduché -- pøedstavte si, ¾e kdy¾ program
vykonává funkci, která není async-signal-safe, pøijde signál a v handleru se
vyvolá funkce stejná. Pokud funkce není pro takové pou¾ití napsaná, tak mù¾e
dojít napøíklad k nekonzistenci statických dat ve funkci pou¾itých, pøípadnì k
uváznutí (dead lock) apod. Právì kvùli tomu, ¾e v handlerech lze bezpeènì pou¾ít
jen podmno¾inu existujících volání, se v handleru èasto pouze nastaví globální
promìnná oznaèující pøíchod pøíslu¹ného signálu a ta se následnì testuje,
napøíklad v cyklu serveru, který vyøizuje po¾adavky nebo programu který
zpracovává události. Zpomalení obsluhy signálu je minimální, proto¾e funkce
která èeká na dal¹í po¾adavek je typicky pøeru¹itelná signálem a v takovém
pøípadì ihned vrací \texttt{EINTR}. Následuje kontrola globální(ch)
promìnné(ých) na to, zda byl pøijmut nìjaký signál.
Viz pøíklad \priklad{signals/event-loop.c}.
\item funkce \texttt{sigaction} je obecnìj¹í ne¾ star¹í funkce
\texttt{signal} a \texttt{sigset}, kte\-ré zde ani nezmiòuji. Doporuèuji
pou¾ívat pouze \texttt{sigaction}. Pou¾ití \texttt{signal} není napøíklad
správné s vlákny, viz specifikace: ``Use of this function is unspecified in a
multi-threaded process.''
\item \label{SIGNAL_VS_SIGACTION} Pozor na to, ¾e chování funkce
\texttt{signal()} se mù¾e li¹it podle systému. Na\-pøík\-lad na FreeBSD zùstává
handler stále nastaven, na Solarisu je z dùvodu zachování zpìtné kompatibility
handler pøed jeho vyvoláním resetován na \texttt{SIG\_DFL}. Funkce pøíznaku
\texttt{SA\_RESETHAND} je právì to, aby bylo mo¾né simulovat pùvodní chování
funkce \texttt{signal()}, které bývá implementováno pomocí systémového volání
\texttt{sigaction()}. Pøíklad na rozdíl mezi funkcemi \texttt{signal()} a
\texttt{sig\-action()}: \priklad{signal/signal-vs-sigaction.c}.
\item (nebudete nejspí¹ potøebovat) pro výskok z handleru signálu jinam ne¾ na
místo vzniku signálu se dají pou¾ít funkce \texttt{sigsetjmp} a
\texttt{siglongjmp}. Pozor na to, ¾e v tomto pøípadì si musíme být jisti, ¾e v
okam¾iku pøíchodu signálu není program uvnitø ne-reentrantní funkce. Výskokem z
handleru do hlavního programu není vykonávání takové funkce ukonèeno a mohou
nastat stejné problémy jako pøi volání ne-reentrantní funkce pøímo z handleru.
\item \label{REALTIMEEXTENSIONS} If your system supports a part of POSIX.1b
called \emph{Realtime Signals Extension} (RTS), it is possible to use the
extension if you use flag \texttt{SA\_SIGINFO}.  In that case a
\texttt{sa\_sigaction} member of the structure \texttt{sigaction} must be used
for the handler, not \texttt{sa\_handler}.  The new handler has three parameters
and it is possible to learn the PID of a signalling process, its UID, and more.
See manual page \texttt{signal.h(3HEAD)} on Solaris, the online SUS
specification of the header file, or the book [POSIX.4], page
\pageref{REF_PROGRAMMING}.  More information is also on page \pageref{POSIX} and
\pageref{SIGWAITINFO}.  Examples: \priklad{sig\-nals/siginfo.c},
\priklad{sig\-nals/sigqueue.c}.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Pøíklad: èasovì omezený vstup}
\setlength{\baselineskip}{0.8\baselineskip}
\begin{alltt}
void handler(int sig)
\{ write(2," !!! TIMEOUT !!! \bs{}n", 17); \}

int main(void) 
\{
    char buf[1024]; struct sigaction act; int sz;
    act.sa\_handler = handler;
    \emprg{sigemptyset}(&act.sa\_mask);
    act.sa\_flags = 0;
    \emprg{sigaction}(SIGALRM, &act, NULL);
    \emprg{alarm}(5);
    sz = read(0, buf, 1024);
    alarm(0);
    if (sz > 0)
        write(1, buf, sz);
    return (0);
\}
\end{alltt}
\end{slide}

\label{SIGALRM}

\begin{itemize}
\item lze pou¾ívat i èasovaèe s jemnìj¹ím rozli¹ením ne¾ 1 s.
Nastavují a testují se funkcemi \texttt{setitimer} a
\texttt{getitimer}. Pøi vypr¹ení posílají signály procesu, který
èasovaèe nastavil podle prvního argumentu \emph{which}:
\begin{itemize}
\item \texttt{ITIMER\_REAL} \dots{} mìøí reálný èas, posílá \texttt{SIGALRM}
\item \texttt{ITIMER\_VIRTUAL} \dots{} mìøí virtuální èas (pouze èas, kdy proces
bì¾í), posílá \texttt{SIGVTALRM}
\item \texttt{ITIMER\_PROF} \dots{} mìøí virtuální èas a èas, kdy systém bì¾í
na konto procesu, posílá \texttt{SIGPROF}
\end{itemize}
\item pozn: v¹imìte si, ¾e aèkoliv by to svádìlo pou¾ít pro tisk hlá¹ky v
pøíkladu funkci \texttt{fprintf} apod., nemusel by to být dobrý nápad, proto¾e
nemusí být bezpeèná pro pou¾ití v handleru signálu, viz strana
\pageref{ASYNCSIGNALSAFE}.
\item pøíklad: \priklad{signals/alarm.c}
\end{itemize}

%%%%%

\pdfbookmark[1]{sigprocmask, sigpending}{sigblock}

\begin{slide}
\sltitle{Blokování signálù}
\begin{itemize}
\item blokované signály budou procesu doruèeny a zpracovány a¾ po
odblokování. 
\end{itemize}
\begin{minipage}{\slidewidth}\texttt{\begin{tabbing}
int \funnm{sigprocmask}(\=int \emph{how}, const sigset\_t *\emph{set},\\
\>sigset\_t *\emph{oset});
\end{tabbing}}
\end{minipage}
\begin{itemize}
\item nastaví masku blokovaných signálù a vrátí starou masku. 
\item \emph{how} -- \texttt{SIG\_BLOCK} pro pøidání signálù co se mají
blokovat, pro odebrání \texttt{SIG\_UNBLOCK}, pro
kompletní zmìnu masky \texttt{SIG\_SETMASK}
\item pro manipulaci s maskou signálù slou¾í funkce:
\texttt{sigaddset()}, \texttt{sigdelset()}, \texttt{sigemptyset()},
\texttt{sigfillset()}, \texttt{sigismember()}
\end{itemize}
\texttt{int \funnm{sigpending}(sigset\_t *\emph{set});}
\begin{itemize}
\item vrátí èekající zablokované signály.
\end{itemize}
\end{slide}

\label{SIGPROCMASK}

\begin{itemize}
\item Je rozdíl mezi ignorováním a blokováním signálu. Ignorovaný signál jádro
zahodí a proces ho nedostane, blokovaný signál proces dostane po jeho
odblokování.
\item Závisí na implementaci, zda pøi vícenásobném doruèení stejného signálu
procesu, který má tento signál zablokovaný, bude signál po odblokování o¹etøen
jednou nebo vícekrát.
\item V pøípadì roz¹íøení signálù z POSIX.4 (strana
\pageref{REALTIMEEXTENSIONS}), tj. pou¾ití pøíznaku \texttt{SA\_SIGINFO}, jsou
signály doruèované pøes frontu a tedy se ¾ádný násobný výs\-kyt stejného signálu
neztratí.
\item Argument \texttt{oset} pro získání pùvodní masky mù¾e být \texttt{NULL},
stejnì jako mù¾e být nastavený na \texttt{NULL} i parametr druhý, tj.
\texttt{set}. Ve speciálním pøípadì, kdy jsou oba parametry nulové, funkce
\texttt{sigprocmask} nedìlá nic.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Pøíklad: blokování signálù}
\setlength{\baselineskip}{0.8\baselineskip}
\begin{alltt}
sigset\_t sigs, osigs; struct sigaction sa;
sigfillset(&sigs); \emprg{sigprocmask}(SIG\_BLOCK, &sigs, &osigs);
switch(cpid = fork()) \{
    case -1: /* Chyba */
        \emprg{sigprocmask}(SIG\_SETMASK, &osigs, NULL);
        ...
    case 0: /* Synovský proces */
        sa.sa\_handler = h\_cld; sigemptyset(&sa.sa\_mask);
        sa.sa\_flags = 0;
        \emprg{sigaction}(SIGINT, &sa, NULL);
        \emprg{sigprocmask}(SIG\_SETMASK, &osigs, NULL);
        ...
    default: /* Rodièovský proces */
        \emprg{sigprocmask}(SIG\_SETMASK, &osigs, NULL);
        ...
\}
\end{alltt}
\end{slide}

\begin{itemize}
\item \label{SIGNALBLOCKINGEXAMPLE} pøíklad ukazuje situaci, kdy proces vytváøí
potomky pomocí \texttt{fork} a je potøeba, aby potomci mìli jiný handler
signálù ne¾ rodièovský proces. Funguje to proto, ¾e volání \texttt{fork} nemìní
masky signálù, viz strana
\pageref{FORK}.
\item pro jednoduchost v pøíkladu blokuji v¹echny signály, i kdy¾ na stranách
\pageref{SPECIALSIGNALS} a \pageref{THREADS_SIGWAIT} je vysvìtleno, proè to není
správné pou¾ití maskování.
\item blokování je vhodné pou¾ít tam, kde o¹etøení pøeru¹ení uprostøed
posloupnosti operací by bylo pøíli¹ slo¾ité, nebo kde korektní o¹etøení není
jinak mo¾né. V uvedeném pøíkladì by bez blokování signálù mohl synovský proces
dostat signál døív, ne¾ stihne zmìnit handler.
\item dal¹í pøíklad je proces, který pøi vypr¹ení timeoutu pøeru¹í provádìnou
posloupnost operací voláním \texttt{siglongjmp} zevnitø handleru signálu. Je
po\-tøe\-ba zablokovat signál \texttt{SIGALRM} bìhem provádìní atomických
podposloupností (tj. takových, které se musí provést buï celé, nebo vùbec ne).
\end{itemize}

%%%%%

\label{SIGWAIT}
\pdfbookmark[1]{pause, sigsuspend, sigwait}{sigwait}

\begin{slide}
\sltitle{Èekání na signál}
\texttt{int \funnm{pause}(void);}
\begin{itemize}
\item pozastaví volající proces do pøíchodu (neblokovaného) signálu
\end{itemize}
\texttt{int \funnm{sigsuspend}(const sigset\_t *\emph{sigmask});}
\begin{itemize}
\item jako \texttt{pause()}, ale navíc po dobu èekání masku
blokovaných signálù zmìní na \texttt{sigmask}
\end{itemize}
\texttt{int \funnm{sigwait}(const sigset\_t *\emph{set}, int *\emph{sig});}
\begin{itemize}
\item èeká na pøíchod signálu z mno¾iny \texttt{set} (tyto signály
musí být pøedtím zablokované), èíslo signálu vrátí v \texttt{sig}. Vrací 0 nebo
èíslo chyby.
\item nevolá se handler signálu (to ale není v normì jednoznaènì
definováno)
\end{itemize}
\end{slide}

\begin{itemize}
\item Neblokovaný signál v \texttt{pause} a \texttt{sigsuspend} vyvolá handler a
po jeho skonèení program opustí signál zachycující funkci a pokraèuje dále.
Pokud má ale signál proces ukonèit (napø. nemaskovaný \texttt{SIGTERM} bez
handleru), stane se tak.
\item Pomocí tìchto funkcí a blokování signálù se implementuje synchronní
obsluha signálù. Proces nejprve zablokuje signály, které ho zajímají, a pak na
nì ve vhod\-ných chvílích buï èeká, nebo jen testuje (pomocí
\texttt{sigpending}), zda signál pøi¹el, a pokud ne, pokraèuje dál.
\item \label{SIGWAIT} Funkce \texttt{sigwait} byla pøidána s POSIX-1003.1c
roz¹íøením (vlákna) a je to ``jediný'' správný zpùsob, jak obsluhovat
asynchronní signály v multi-vláknové aplikaci. To ¾e byla pøidána s vlákny je
potvrzeno i tím, ¾e v pøípadì problémù vrací pøímo èíslo chyby.
\item \label{SIGWAITINFO} Existují i pøíbuzné
podobnì se jmenující funkce \texttt{sigwaitinfo} a \texttt{sigtimedwait},
definované s roz¹íøením POSIX-1003.1\emsl{b} (real-time). Fungují na podobném
principu, ale na rozdíl od \texttt{sigwait} pracují s \texttt{errno} a je z nich
mo¾né získat více informací díky struktuøe \texttt{siginfo\_t}, viz strana
\pageref{REALTIMEEXTENSIONS}. Je tedy mo¾né je pou¾ít místo \texttt{sigwait}.
\item Pøíklad (signál se pou¾ije pro synchronizaci dvou procesù komunikujících
pøes sdílenou pamì»): \priklad{signals/sigwait.c}
\item \emsl{Pozor} na to, ¾e byste nemìli tento zpùsob obsluhy signálù pou¾ívat
pro sig\-nály synchronní jako jsou \texttt{SIGSEGV}, \texttt{SIGILL}, apod. Více
se doètete na stranách \pageref{SPECIALSIGNALS} a \pageref{THREADS_SIGWAIT}. 
\end{itemize}

\endinput
