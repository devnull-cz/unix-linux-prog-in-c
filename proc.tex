%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pdfbookmark[0]{manipulace s procesy, spou¹tìní programù}{procesy}
\begin{slide}
\sltitle{Obsah}
\begin{itemize}
\item úvod, vývoj UNIXu a C, programátorské nástroje
\item základní pojmy a konvence UNIXu a jeho API
\item pøístupová práva, periferní zaøízení, systém souborù
\item \emsl{process manipulation, program execution}
\item signály
\item synchronizace a komunikace procesù
\item sí»ová komunikace
\item vlákna, synchronizace vláken
\item ??? - bude definováno pozdìji, podle toho kolik zbyde èasu
%\item závìreèná v¹ehochu» podle toho, kolik zbude èasu (bezpeènost,
%locales, pseudoterminály, X Window) 
\end{itemize}
\end{slide}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Procesy

changequote([[[, ]]])

\pdfbookmark[1]{text/data/bss/stack/heap}{procmem}

\begin{slide}
\sltitle{Process memory layout in userspace}
\begin{center}
\input{img/tex/mem_user.tex}
\end{center}
\end{slide}

\begin{itemize}
\item ka¾dý proces má tøi základní segmenty (pamì»ové segmenty, nemluvíme o
hardwarových segmentech):
    \begin{itemize}
    \item text \dots{} kód programu
    \item data \dots{} inicializované promìnné
    \item zásobník
    \end{itemize}
\item sekce \texttt{text} a \texttt{data} jsou ulo¾eny ve spustitelném souboru
\item sekce pro inicializované i neinicializované promìnné a heap jsou brány
dohromady jako data
\item dále lze do adresového prostoru pøipojit segmenty sdíl{}ené
pamìti (\texttt{shmat}) nebo soubory (\texttt{mmap}).
\item text je sdíl{}en v¹emi procesy, které provádí stejný kód. Datový
segment a zásobník jsou privátní pro ka¾dý proces.
\item ka¾dý systém mù¾e pou¾ívat zcela jiné rozdìl{}ení adresového prostoru
procesu (a typicky tomu tak je). Konkrétní pøíklad je na následujícím slajdu, a
zobrazuje i sekce pro \texttt{mmap} a \emph{heap}.
\item \emph{bss} \dots{} neinicializované promìnné (\texttt{bss}
pochází z assembleru IBM 7090 a znamená \uv{block started by
symbol}). Za bìhu programu tvoøí sekce \texttt{data}, \texttt{bss} a heap
(není na obrázku) dohromady datové segmenty procesu. Velikost heapu lze mìnit
pomocí systémových volání \texttt{brk} a \texttt{sbrk}.
\item poznámka -- neinicializované promìnné jsou statické promìnné, které
(pøe\-kva\-pi\-vì) nejsou inicializované -- tj. globální promìnné nebo promìnné
definované jako \texttt{static} ve funkcích i mimo funkce. Jak víte z pøedná¹ek
o jazyku C, v¹echny tyto promìnné jsou pøi startu programu automaticky
inicializované nulami. Proto není nutné mít jejich hodnotu v binárce. Jakmile
ale nìjakou z takových pro\-mìn\-ných inicializujete, bude ji¾ souèástí datového
segmentu programu na disku.
\item \emph{(u¾ivatelský) zásobník} \dots{} lokální nestatické promìnné,
parametry funkcí (na urèitých architekturách v daných modech - 32-bit x86),
ná\-vra\-to\-vé adresy. Ka¾dý proces má dva zásobníky, jeden
pro u¾ivatelský re¾im a jeden pro re¾im jádra. U¾ivatelský zásobník procesu
automaticky roste podle potøeby (neplatí, pokud se pou¾ívají vlákna, tam má
navíc ka¾dé vlákno zásobník svùj).
\item \emph{oblast user (u-area)} \dots{} obsahuje informace o procesu pou¾ívané
jádrem, které nejsou potøebné, kdy¾ je proces odlo¾en na disku (poèet otevøených
souborù, nastavení o¹etøení signálù, poèet segmentù sdíl{}ené pamìti, argumenty
programu, promìnné prostøedí, aktuální adresáø, atd.). Tato oblast je pøístupná
pouze pro jádro, které v¾dy vidí právì jednu u-oblast patøící právì bì¾ícímu
procesu. Dal¹í informace o procesu, které jádro mù¾e potøebovat i pro jiný ne¾
právì bì¾ící proces, nebo i kdy¾ je proces odlo¾en, jsou ve struktuøe
\texttt{proc}. Struktury \texttt{proc} pro v¹echny procesy jsou stále rezidentní
v pamìti a viditelné v re¾imu jádra.
\end{itemize}


\begin{slide}
\sltitle{Example: Solaris 11 x86 32-bit}
\begin{center}
\includegraphics[width=54mm]{img/eps/x86-memory-proc-mem-layout.eps}  
\end{center}
\end{slide}

\label{SOLARIS_PROC_ADDR_SPACE}

\begin{itemize}
\item z obrázku lze vyèíst nìkolik dal¹ích vìcí:

\begin{itemize}
\item maximální velikost kernelu pro Solaris 11 x86 32-bit je 256 megabajtù
\item mezi namapováním kernelu a pamìtí vyhrazenou pro \texttt{mmap} je volné
místo
\item zásobník roste smìrem k ni¾¹ím adresám a jeho velikost je omezena na 128
megabajtù
\end{itemize}

\item \emph{heap} je èást pamìti, kterou si proces mù¾e zvìt¹ovat pomocí volání
\texttt{brk} a \texttt{sbrk}, a je èasto pou¾ívaná funkcí \texttt{malloc}.
Funguje to tak, ¾e \texttt{malloc} si postupnì zvìt¹uje heap podle potøeby, a
pøiøazenou pamì» internì spravuje a pøidìluje ji procesu po èástech. Kdy¾ tedy
voláte \texttt{free}, neznamená to, ¾e vracíte pamì» systému, ale pouze
internímu alokátoru.
\item oblast pro \texttt{mmap} se pou¾ívá pro mapování souborù, tedy i
sdíl{}ených knihoven. Nìkteré alokátory pou¾ívají internì i tuto pamì»,
napøíklad pro vìt¹í kusy pamìti ¾ádané najednou. Je mo¾né exkluzivnì pou¾ívat
pouze \texttt{mmap}, pro aplikaci je to zcela transparentní. Pøi pou¾ití
\texttt{mmap} je mo¾né pamì» systému vracet (voláním \texttt{munmap}), na rozdíl
od implementace pomocí \texttt{brk}/\texttt{sbrk}.
\item obrázek byl pøevzat z [McDougall-Mauro], a není na nìm oblast pro
neinicializované promìnné. Pokud si ale na tomto systému necháte vypsat adresu
jedné z nich, zjistíte, ¾e inicializované i neinicializované promìnné sdílí
spoleèný datový segment, na obrázku oznaèený jako ,,executable -- DATA''.
Pøíklad: \priklad{pmap/proc-addr-space.c}
\item mapování kernelu není nutné, napøíklad u Solarisu na \emph{amd64}
architektuøe (tj. 64-bit) u¾ kernel do u¾ivatelského prostoru procesu
mapován není.
\item \texttt{brk} ani \texttt{sbrk} nejsou souèástí normy, pøenositelné
aplikace by proto mìly pou¾ívat, pokud podobnou funkcionalitu potøebují, volání
\texttt{mmap}, viz strana \pageref{MMAP}.
\end{itemize}


%%%%%

\begin{slide}
\sltitle{Process memory layout in kernel}
\begin{center}
\input{img/tex/mem_kernel.tex}
\end{center}
\end{slide}

\begin{itemize}
\item proces se dostane do re¾imu jádra buï pøíchodem
\emph{pøeru¹ení vyvolaného procesorem} (výpadek stránky, neznámá
instrukce,...), \emph{èasovaèem} (v pravidelných intervalech je
potøeba aktivovat plánovaè procesù), \emph{periferním zaøízením},
nebo instrukcí synchronního pøeru¹ení (standardní knihovna takto
pøedává øízení jádru, aby obslou¾ilo \emph{systémové volání}).
\item v pamìti je pouze jedna kopie kódu a dat jádra, sdíl{}ená v¹emi
procesy. Kód jádra je v¾dy celý rezidentní v pamìti, není odkládán
na disk.
\item \emph{text jádra} \dots{} kód jádra operaèního systému,
zavedený pøi startu systému a rezidentní v~pamìti po celou dobu bìhu
systému. Nìkteré implementace umo¾òují pøidávat funkèní moduly do
jádra za bìhu (napø. pøi pøidání nového zaøízení se do jádra
dynamicky pøidá nový ovladaè), není proto tøeba kvùli ka¾dé zmìnì
regenerovat jádro a restartovat systém.
\item \emph{data a bss jádra} \dots{} datové struktury pou¾ívané
jádrem, souèástí je i u-oblast právì bì¾ícího procesu.
\item \emph{zásobník jádra} \dots{} samostatný pro ka¾dý proces, je
prázdný, jestli¾e je proces v u¾ivatelském re¾imu (a tedy pou¾ívá
u¾ivatelský zásobník).
\end{itemize}

%%%%%

\pdfbookmark[1]{segmenty - text/data/stack}{memsegments}

\begin{slide}
\sltitle{Process memory segments}
\begin{center}
\input{img/tex/segmenty.tex}
\end{center}
\end{slide}

\begin{itemize}
\item takto vypadá vìt¹inou reprezentace pamì»ových segmentù procesu v jádøe.
\item základním rysem této architektury je tzv. \emph{memory object}, co¾ je
abstrakce mapování mezi kusem pamìti a místem, kde jsou data normálnì ulo¾ena
(tzv. \emph{backing store} nebo \emph{data object}). Takové místo ulo¾ení mù¾e
být napøíklad swap nebo soubor. Adresový prostor procesu je pak mno¾ina
mapování na rùzné datové objekty. Existuje i \emph{anonymní objekt}, který
nemá místo trvalého ulo¾ení (pou¾ívá se napøíklad pro zásobník). Fyzická pamì»
pak slou¾í jako cache pro data tìchto namapovaných datových objektù.
\item tato zde velmi hrubì popsaná architektura se nazývá VM (od \emph{Virtual
Memory}), a objevila se v SunOS 4.0. Na této architektuøe je zalo¾ena
architektura viruální pamìti v SVR4. Více informací viz [Vahalia], pùvodní
èlánek z roku 1987 pøedstavující tuto architekturu: Gingell, R. A., Moran J.
P., Shannon, W.  A. -- \emph{Virtual Memory Architecture in SunOS} nebo
pøedná¹ka o operaèních systémech na MFF (NSWI004 - Operaèní systémy).
\item z jakých segmentù se skládá pamì»ový prostor konkrétního
procesu lze zjistit pomocí pøíkazu \texttt{pmap(1)} (na Solarisu, na NetBSD a v
nìkterých Linuxových distribucích) nebo \texttt{procmap(1)} (v OpenBSD)
nebo \texttt{vmmap(1)} v Mac~OS~X.
\end{itemize}

%%%%%

\pdfbookmark[1]{virtual memory}{virtmem}

\begin{slide}
\sltitle{Virtual memory}
\begin{center}
\input{img/tex/virt_mem.tex}
\end{center}
\end{slide}

\begin{itemize}
\item ka¾dý proces vidí svùj adresový prostor jako souvislý interval
(virtuálních) adres od nuly po nìjakou maximální hodnotu. Pøístupné jsou pouze
ty adresy, na kterých je namapován nìkterý segment procesu (to je právì to
mapování, o kterém se mluví na pøedchozím slajdu).
\item jádro dále rozdìluje pamì» procesu na stránky. Ka¾dá stránka má své
u\-mí\-stì\-ní v~rámci fyzické pamìti. Toto umístìní je dáno stránkovacími
tabulkami jádra a stránky mohou být v rámcích libovolnì promíchány vùèi jejich
poøadí ve virtuální adresovém prostoru. 
\item pokud není stránka právì pou¾ívána, mù¾e být také odlo¾ena na disk.
\item pamì»ový manager jádra zaji¹»uje mapování mezi virtuálními adresami
po\-u\-¾í\-va\-ný\-mi kódem u¾ivatelských procesù i jádra na fyzické adresy a
naètení odlo¾ených stránek z~disku pøi výpadku stránky.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Virtual memory implementation}
\begin{itemize}
\item processes in UNIX use virtual addresses to access physical memory.
The virtual - physical convertion is performed by hardware with the help
of kernel.
\item in case of memory shortage unused parts of memory are stored to
(\emsl{swap}) space on disk. 
\item before SVR2 the \texttt{swapper} process (nowadays
\texttt{sched}) swapped out whole processes. 
\item from SVR2 on (\emsl{demand paging}) is used with \emsl{copy-on-write}.
Pages are allocated only after first use and private pages are copied only
after modification. Freeing and swapping of individual pages is performed
by the \texttt{pageout} process, swapping of whole processes is done only
when critically low on memory.
\end{itemize}
\end{slide}

\begin{description}
\item[pøeklad adres:] pøístup na neplatnou adresu nebo pokus o zápis
do pamìti pouze pro ètení vyvolá signál \texttt{SIGSEGV}.
\item[swap:] odkládací prostor se vytváøí na samostatném oddílu
disku, od SVR4 mù¾e být i v~souboru.
\item[swapper:] proces \texttt{swapper} se sna¾í odlo¾it na disk nìjaký
proces, který není zam\-èen v~pamìti, a na uvolnìné místo zavést døíve
odlo¾ený proces.
\item[demand paging:] pøi ¾ádosti procesu o pamì» se pouze upraví
tabulka stránek. První instrukce adresující obsah stránky vyvolá
výjimku. Jádro ji o¹etøí tím, ¾e alokuje stránku. 
\item[copy-on-write:] více procesù mù¾e sdílet zapisovatelnou
fyzickou stránku, která je ale logicky privátní pro ka¾dý proces
(tato situace nastane napø. po vytvoøení procesu voláním
\texttt{fork}). Dokud procesy z pamìti pouze ètou, pøistupují ke
sdíl{}ené stránce. Pokud se proces pokusí obsah stránky zmìnit, vyvolá
výjimku. Jádro zkopíruje stránku, pøidìlí procesu kopii, která u¾ je
privátní a proces ji mù¾e dále libovolnì mìnit. Ostatní procesy
pou¾ívají stále ne\-zmì\-nì\-nou pùvodní stránku.
\item stránky k odlo¾ení se hledají algoritmem \emph{NRU} (not recently
used): ka¾dá stránka má pøíznaky \texttt{referenced} a
\texttt{modified}, na zaèátku vynulované. Pøi prvním pøístupu se
nastaví \texttt{referenced}, pøi zmìnì \texttt{modified}. Oba
pøíznaky se periodicky nulují. Pøednostnì se uvolòují stránky, které
nejsou modifikované ani pou¾ité. Stránky kódu programu a mapovaných
souborù se neukládají do odkládacího prostoru, ale obnovují se z
pøíslu¹ného souboru.
\end{description}


%%%%%

\pdfbookmark[1]{Process states}{procstates}

\begin{slide}
\sltitle{Stavy procesu}
\begin{center}
\input{img/tex/stavy_proc.tex}
\end{center}
\end{slide}

\begin{itemize}
\item po ukonèení procesu voláním \texttt{exit} nebo v reakci na
signál pøechází proces do stavu mátoha (zombie), proto¾e jádro si
musí pamatovat k èíslu procesu jeho návratovou hodnotu. Celá pamì»
procesu je uvolnìna, zbývá pouze struktura \texttt{proc}. Proces lze
definitivnì zru¹it, a¾ kdy¾ se jeho rodiè zeptá na návratovou
hodnotu voláním typu \texttt{wait}. Kdy¾ nebude pùvodní rodiè k dispozici,
provede volání \texttt{wait} proces \texttt{init}, který pøevzal rodièovství.
\item v dne¹ních UNIXech se obvykle do odkládací oblasti na disku
(swap area) neodkládají celé procesy, ale jednotlivé stránky pamìti.
\item proces je \emph{uspán}, kdy¾ o to sám po¾ádá, napø. zaène
èekat na dokonèení periferní operace. \emph{Preempce} je naopak
nedobrovolné odebrání procesoru plá\-no\-va\-èem.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Process scheduling}
\begin{itemize}
\item \emph{preemptive} -- if a process does not give up CPU
(e.g. by entering a sleep to wait on some event), the CPU is taken away
after time quantum expiration.
\item processes are classified into queues according to priority,
CPU is assigned to the first ready process from queue with biggest priority.
\item SVR4 introduced priority queues and real-time support with guaranteed
maximal response time.
\item contrary to the previous versions, in SVR4 bigger number means
bigger priority.
\end{itemize}
\end{slide}

\begin{itemize}
\item \emsl{základem preemptivního plánování jsou pravidelná pøeru¹ení od
èasovaèe}, která odeberou procesor bì¾ícímu procesu a pøedají øízení jádru
(aktivuje se plánovaè procesù).
\item jiná varianta je nepreemptivní (kooperativní) plánování, kdy proces
bì¾í, dokud se sám nevzdá procesoru, tj. dokud nezavolá takovou systémovou
funkci, která pøepne kontext na jiný proces. Nevýhodou kooperativního
plánování je, ¾e jeden proces mù¾e stále blokovat procesor a ostatní procesy
se nikdy nedostanou na øadu. 
\item UNIX pou¾ívá pro u¾ivatelské procesy pouze preemptivní plánování.
\item tradièní UNIXové \emsl{jádro} funguje kooperativním zpùsobem, tj. proces
bì¾ící v re¾imu jádra není pøeplánován, dokud se sám nevzdá procesoru.
\emsl{Jádra moderních UNIXù jsou ji¾ preemtivní} -- je to hlavnì kvùli real-time
systémùm; tam je potøeba mít mo¾nost bì¾ící proces zbavit procesoru o\-kam\-¾i\-tì,
neèekat na to, a¾ se vrátí z re¾imu jádra nebo se sám uspí. Pozor na a» to
nepletete -- UNIX byl od samého zaèátku preemptivní systém, ale jeho jádro bylo
nepreemptivní.
\item pøi preemptivním plánování mù¾e být proces kdykoliv pøeru¹en a øízení
pøe\-dá\-no jinému procesu. Proces si proto nikdy nemù¾e být jistý, ¾e urèitou
operaci (více ne¾ jednu intstrukci, kromì systémových volání se zaruèenou
a\-to\-miè\-nos\-tí) provede atomicky, bez ovlivnìní ostatními procesy. Pokud
je tøeba zajistit atomiènost nìjaké akce, musí se procesy navzájem
synchronizovat. Pøi kooperativním plánování problém synchronizace odpadá
(atomická posloupnost operací se zajistí tím, ¾e se proces bìhem ní nevzdá
procesoru).
\end{itemize}


%%%%%

\pdfbookmark[1]{Priority classes for process scheduling}{prioclasses}

\begin{slide}
\sltitle{Priority classes}
\setlength{\baselineskip}{0.8\baselineskip}
\begin{itemize}
\item \emsl{system}
    \begin{itemize}
    \item priority 60 to 99 
    \item reserved for system processes (\texttt{pageout},
    \texttt{sched}, \dots) 
    \item fixed priorita 
    \end{itemize}
\item \emsl{real-time}
    \begin{itemize}
    \item priority 100 to 159 
    \item fixed priorita 
    \item a time quantum corresponds to priority value
    \end{itemize}
\item \emsl{time-shared}
    \begin{itemize}
    \item priority 0 to 59 
    \item dynamic 2 part priority, fixed user part and
    dynamic system part -- if a process uses CPU extensively,
    its priority is being decreased (and time quantum increased)
    \end{itemize}
\end{itemize}
\end{slide}

\begin{itemize}
\item systémová tøída je pou¾ívána pouze jádrem, u¾ivatelský proces bì¾ící v
re\-¾i\-mu jádra si ponechává svou plánovací charakteristiku.
\item procesy ve tøídì reálného èasu mají nejvy¹¹í prioritu, proto musí být
správnì nakonfigurovány, aby nezablokovaly zbytek systému.
\item jestli¾e je proces ve tøídì sdíl{}ení èasu uspán a èeká na nìjakou
událost, je mu doèasnì pøiøazena systémová priorita. Po probuzení se takový
proces dostane na procesor døíve, ne¾  ostatní procesy, které nespí.
\item pevná èást priority procesu ve tøídì sdíl{}ení èasu se dá nastavit
pomocí\\ \texttt{int \funnm{setpriority}(int \emph{which}, id\_t \emph{who},
int \emph{prio});}\\ nebo\\ \texttt{int \funnm{nice}(int \emph{in{}cr});} \\
Hodnota \emph{which} udává co bude v argumentu \emph{who}. Pokud je napø.
\emph{which} \emph{PRIO\_PGRP}, bude v \emph{who} èíslo skupiny procesù.
Pozor na volání \funnm{nice} které vrací novou hodnotu nice. Proto¾e je
-1 validní hodnota, je potøeba pøed volání vyèistit \texttt{errno} a pokud
funkce vrátí -1 tak ji zkontrolovat.
\item prioritní tøídu a hodnotu nice daného procesu lze zobrazit pøepínaèem
-l programu ps(1) nebo pomocí specifikace hodnot které se mají vypsat.
\item Pøíklad: hodnoty priority mají na rùzných systémech rùzné ¹kály.
Napø. na Mac~OS~X~10.9 má spu¹tìný proces hodnotu priority 30, po zvý¹ení
hodnoty nice (proces je "hodnìj¹í" na ostatní procesy a dobrovolnì tedy sní¾il
svoji prioritu) se mu hodnota prorita sní¾í na 21 co¾ na Mac~OS~X znamená
i sní¾ení priority:
\begin{verbatim}
$ sleep 200 &
[1] 36877
$ ps -O pri,nice -p $!
  PID PRI NI   TT  STAT      TIME COMMAND
36877  31  0 s003  S      0:00.00 sleep 200
$ renice 10 -p $!
$ ps -O pri,nice -p $!
  PID PRI NI   TT  STAT      TIME COMMAND
36877  21 10 s003  SN     0:00.00 sleep 200
\end{verbatim}
Na Linuxu 3.10 to ale bude vypadat jinak - po zvý¹ení hodnoty nice se zvý¹í i
hodnota priority, to ale v této verzi znamená, ¾e proces bude bì¾et s
prioritou ni¾¹í.
\end{itemize}


%%%%%

\pdfbookmark[1]{process groups}{procgrps}

\begin{slide}
\sltitle{Process groups, controlling terminals}
\begin{itemize}
\item every process belongs to a \emph{process group}
\item each group can have a leading process, so called \emph{group leader}
\item every process can have a \emph{controlling terminal} (usually it is a
login terminal)
\item special file \texttt{/dev/tty} is associated with a controlling terminal
of each process
\item each terminal is associated with a process group called a
\emph{controlling group}
\item \emph{job control} is a mechanism for suspending, resuming, and
terminating process groups and control their access to terminals
\item \emph{session} is a collection of process groups created for the purpose
of job control
\end{itemize}
\end{slide}

\begin{itemize}
\item kdy¾ se u¾ivatel pøihlásí do systému, je vytvoøená nová relace, která se
skládá z jedné skupiny procesù, ve které je jeden proces -- ten který vykonává
u¾ivatelùv shell. Tento proces je zároveò vedoucí této jediné skupiny procesù a
také je vedoucí relace. V pøípadì, ¾e job control je povolen, ka¾dý pøíkaz nebo
kolona pøíkazù vytvoøí novou skupinu procesù, jeden z procesù v ka¾dé skupinì se
v¾dy stane vedoucím procesem dané skupiny. Jedna ze skupin mù¾e bì¾et na
popøedí, ostatní bì¾í na pozadí. Signály, které jsou generované z klávesnice
(tj. stiskem kombinace kláves, nemyslí se tím spu¹tìní pøíkazu \texttt{kill}!),
jsou zaslány pouze skupinì, která bì¾í na popøedí.
\item pokud job control není zapnut, znamená spustìní pøíkazu na pozadí pouze
to, ¾e shell neèeká na jeho ukonèení. Existuje pouze jedna skupina procesù,
signály z klávesnice se posílají v¹em procesùm be¾ícím na popøedí i na pozadí.
Nelze pøesouvat procesy z pozadí na popøedí a naopak.
\item kdy¾ proces, který má kontrolní terminál, otevøe soubor \texttt{/dev/tty},
tak se asociuje se svým kontrolním terminálem. Tj. pokud dva rùzné procesy z
rùzných relací otevøou tento soubor, pøistupují oba k rùzným terminálùm.
\item v bashi se skupina procesù (job) pozastaví pomocí \texttt{Ctrl-Z}, a
rozbìhne pøes ,,\texttt{fg \%N}'' kde \texttt{N} je èíslo jobu podle výpisu
pøíkazu \texttt{jobs}. Více informací viz sekce ,,JOB CONTROL'' v manuálové
strán\-ce pro bash.
\end{itemize}


%%%%%

\pdfbookmark[1]{getpid, getpgrp, getppid, getsid}{getp}

\begin{slide}
\sltitle{Process identification}
\texttt{pid\_t \funnm{getpid}(void);}
\begin{itemize}
\item returns the process ID of the calling process.
\end{itemize}
\texttt{pid\_t \funnm{getpgrp}(void);}
\begin{itemize}
\item returns the PGID of the calling process
\end{itemize}
\texttt{pid\_t \funnm{getppid}(void);} 
\begin{itemize}
\item returns the process ID of the calling process.
\end{itemize}
\texttt{pid\_t \funnm{getsid}(pid\_t \emph{pid});}
\begin{itemize}
\item returns the session ID of the calling process.
for process \texttt{pid} (0 means for the calling process)
\end{itemize}
\end{slide}

\begin{description}
\item[skupiny procesù] umo¾òují posílat signály najednou celé skupinì.
\item[session] (relace, sezení) je kolekce procesù vytvoøená pro úèely øízení
prací (\emph{job control}). Procesy sezení sdílejí jeden \emph{øídící terminál}.
Session zahrnuje jednu nebo více skupin procesù. Max. jedna skupina v rámci
sezení bì¾í na popøedí (\emph{foreground process group}) a má pøístup k øídicímu
terminálu pro vstup i výstup, ostatní bì¾í na pozadí (\emph{background process
groups}) a mají k øídicímu terminálu pøístup volitelnì jen pro výstup nebo vùbec
(nepovolená operace s terminálem pozastaví proces).
\item[rodièovský proces:] Ka¾dý proces (kromì \texttt{swapper}u, pid~==~0) má
rodièe, tj. proces, který ho stvoøil voláním \texttt{fork}. Jestli¾e rodiè
skonèí døíve ne¾ dítì, adoptivním rodièem se stává proces \texttt{init},
který se také postará o uklizení zombie po skonèení procesu.
\end{description}
\begin{itemize}
\item Programatické zji¹»ování informací o ostatních procesech lze pomocí
nestandardních rozhraní (napø. knihovna \texttt{libproc} na Solarisu postavená
na filesystému \texttt{procfs}, který je pøipojen pod \texttt{/proc}).
\item Pozor na to, ¾e zji¹»ovat ¾e rodiè skonèil pomocí kontroly hodnoty
vrácené z \texttt{getppid} na hodnotu 1 (co¾ je bì¾nì proces \texttt{init}
resp. jeho ekvivalent), není portabilní.
\\
V rùzných virtualizovaných prostøedích (PID namespaces v Linux, Zones v
Solarisu) to nemusí platit. Viz pøíklad \priklad{session/getppid.c}.
\end{itemize}


%%%%

\pdfbookmark[1]{setpgrp, setsid}{setp}

\begin{slide}
\sltitle{Creating a new process group/session}
\texttt{int \funnm{setpgid}(pid\_t \emph{pid}, pid\_t \emph{pgid});}
\begin{itemize}
\item sets the PGID of the process specified by pid to pgid.
\end{itemize}
\texttt{pid\_t \funnm{setsid}(void);}
\begin{itemize}
\item creates a new session if the calling process is not a process
group leader
\end{itemize}
\end{slide}

\begin{itemize}
\item pro volání \funnm{setpgid} platí:
\begin{enumerate}
\item pid == pgid : proces s \emph{pid} se stane vedoucím skupiny procesù
\item pid != pgid : proces s \emph{pid} se stane èlenem skupiny procesù
\end{enumerate}
\item Proces, který je¹tì není
vedoucím skupiny procesù, se mù¾e stát vedoucím sezení a zároveò skupiny procesù
voláním \texttt{setsid}. Jestli¾e proces u¾ je vedoucím skupiny, \texttt{setsid}
sel¾e, pak je tøeba provést \texttt{fork} a \texttt{setsid} zavolat v synovském
procesu. Takový proces nemá øídicí terminál, mù¾e ho získat otevøením terminálu,
který je¹tì není øídicím terminálem sezení, kdy¾ pøi \texttt{open} neuvede
pøíznak \texttt{O\_NOCTTY}, nebo jiným implementaènì závislým zpù\-so\-bem.
\end{itemize}


%%%%%

\pdfbookmark[1]{fork}{fork}

\begin{slide}
\sltitle{Create a new process: \texttt{fork()}}
\begin{center}
\input{img/tex/fork.tex}
\end{center}
\end{slide}

\begin{itemize}
\item \label{FORK} The child proces is almost an exact copy of its parent except
for the following:
\begin{itemize}
\item The child process has a unique process and parent process ID.
\item If the parent had multiple threads, the child will only have one that
called \texttt{fork}; will be further explained on page \pageref{FORKALL}.
\item Child process resource utilizations are set to 0.
\item \texttt{alarm} settings and file locks are not inherited.
\end{itemize}
\item The file descriptor tables are exact copies in both processes.  That means
that more processes can share and seek a common file position.  Signal masks are
not changed, more on that on page \pageref{SIGNALBLOCKINGEXAMPLE}.
\item For effiency and less memory consumption, the address space is not copied
but a \emph{copy-on-write} mechanism is used.
\item The reason why the parent gets its child's PID as a return value and the
child gets 0 is because it is easy for the child to get its parent PID via
\texttt{getpid}.  Imagine how the parent would figure out the new child PID,
especially if it already spawned multiple children.
\item Example: \priklad{fork/fork.c}
\item \label{VFORK} There is also \texttt{vfork}, used in the past to work
around the problem that the child address space was usually rewritten on
subsequent \texttt{exec}.  This problem was solved via already mentioned
copy-on-write mechanism.  See \priklad{fork/vfork.c} on how it works.
\end{itemize}

%%%%%

\pdfbookmark[1]{exec}{exec}

\begin{slide}
\sltitle{Execute a program: \texttt{exec}}
\texttt{extern char **\funnm{environ};\\
int \funnm{execl}(const char *\emph{path}, const char *\emph{arg0}, ... );}
\begin{itemize}
\item replaces the current process image with a new process image
\item runs a program defined via \emph{path}
\item arguments that follow, including \emph{arg0}, are given to the program via
\texttt{argc} and \texttt{argv} of its \texttt{main()}
\item the argument list must end with \texttt{(char *)0}, ie. \texttt{NULL}
\item \emph{arg0} should contain the program name (ie. not the full path)
\end{itemize}
\end{slide}

\label{EXEC}

\begin{itemize}
\item \emph{path} must be an absolute or relative path to the executable file.
\texttt{PATH} is only used for \funnm{execlp} a \funnm{execvp} (see the one of
the slides that follow), if \emph{path} does not contain \texttt{'/'}.
\item All variants of these calls are commonly just called the \funnm{exec}
call.  It goes without saying that one of the variants is used but usually that
is not important for the sake of a discussion.
\item Sometimes \texttt{argv[0]} is different from the executable file name.
For example, \texttt{login} command prefixes the shell file name with
\texttt{'-'}, eg. \texttt{-bash}.  The shell then knows it is supposed to
function as a login shell.  A login shell reads \texttt{/etc/profile}, for
example.
\item \funnm{exec} does not transfer the control to the program in memory
directly.  As desribed on page \pageref{RUNTIMELINKER}, the system (ie. the code
of the \funnm{exec} call) first maps the dynamic linker, aka loader, to the
process address space.  The loader then maps all dynamic libraries there as
well, then finally calls the program \texttt{main()}.
\item A useful exercise is to write a simple program calling \texttt{open()},
for example.  When done, run the program via \texttt{truss(1)} or
\texttt{strace(1)} like this: \texttt{truss ./a.out}. You will see what is being
done before \texttt{open} is called in the end.
\end{itemize}

\begin{slide}
\sltitle{Execute a program: \texttt{exec} (continued)}
\texttt{extern char **\funnm{environ};\\
int \funnm{execl}(const char *\emph{path}, const char *\emph{arg0}, ... );}
\begin{itemize}
\item successful \funnm{execl} never returns as the new process (program) fully
replaced the address space of the calling process
\begin{itemize}
\item ...the original place to return to no longer exists
\end{itemize}
\item signal handlers are set to default
\begin{itemize}
\item ...as the original handler code no longer exists
\end{itemize}
\item file descriptors with flag \texttt{FD\_CLOEXEC} are closed
\item the new process inherits \texttt{environ} from the calling process
\end{itemize}
\end{slide}

\begin{itemize}
\item More about signals on page \pageref{SIGNALS}.
\item \funnm{exec} does not change RUID and RGID.  And for security reasons, if
the executed program has a SUID bit set, the program's EUID and saved EUID are
set to the UID of the executable program owner.
\item Today's systems can also execute scripts that start with a line:\\
\texttt{\#!/\emph{interpreter\_path}/\emph{interpreter\_name} \emph{[args]}}
\end{itemize}

%%%%%

\pdfbookmark[1]{execv, execle, execl, execve, execlp}{execvariants}

\begin{slide}
\sltitle{Variants of the \texttt{exec} call}
\setlength{\baselineskip}{0.8\baselineskip}
\texttt{int \funnm{execv}(const char *\emph{path}, char *const \emph{argv}[]);} 
\begin{itemize}
\item like \funnm{execl} but arguments are in the \emph{argv} array,
the last iteam must be \texttt{NULL}
\end{itemize}
\begin{minipage}{\slidewidth}
\vspace{-1ex}\texttt{\begin{tabbing}
int \funnm{execle}(\=const char *\emph{path}, const char *\emph{arg0},
... ,\\\> char *const \emph{envp}[]);
\end{tabbing}}
\end{minipage}
\begin{itemize}
\item like \funnm{execl} but instead of the global variable \emph{environ}, 
the \emph{envp} argument is used
\end{itemize}
\begin{minipage}{\slidewidth}
\vspace{-1ex}\texttt{\begin{tabbing}
int \funnm{execve}(\=const char *\emph{path}, char *const \emph{argv}[],\\
\>char *const \emph{envp}[]);
\end{tabbing}}
\end{minipage}
\begin{itemize}
\item like \funnm{execv} but instead of \emph{environ}, \emph{envp} is used
\end{itemize}
\texttt{int \funnm{execlp}(const char *\emph{file}, const char *\emph{arg0},
...);\\
int \funnm{execvp}(const char *\emph{file}, char *const \emph{argv}[]);}
\begin{itemize}
\item like \funnm{execl} and \funnm{execv} but \texttt{PATH} is also used
for searching for the executable file
\end{itemize}
\end{slide}

\begin{itemize}
\item \emsl{l} = list (ie. list of arguments), \emsl{v} = vector (ie.  an array
of string pointers), \emsl{e}~=~environment (ie. environment variables are
passed to the function via an argument), \emsl{p} = \texttt{PATH} is used.
\item Aside from \funnm{execlp} and \funnm{execvp}, it is always needed to use
the full path to the executable program, either an absolute or relative one.
\item All variants aside from \funnm{execle} and \funnm{execve}
are also passing to the program being executed the environment variables of the
calling process, ie. the \texttt{environ} array.
\item For some unknown historical reasons, there is no \funnm{execpe}.
\item \label{EXEC_DATE} Example: \priklad{exec/exec-date.c}
\item \label{EXECL} The following use of \funnm{execl} is incorrect as it is
missing the mandatory argument for \texttt{argv[0]}:

\begin{verbatim}
	execl("/bin/ls", NULL);
\end{verbatim}

On some systems, the above has very interesting consequences.  As \texttt{NULL}
is taken as an expected \texttt{argv[0]}, the data on the stack are then
accepted as the program arguments until the next \texttt{NULL} is found there.
In the following example, run on some version of the FreeBSD system, \texttt{ls}
is trying to list filenames that are environment variable names and values (the
environment array contain strings \texttt{<varname>=<value>}), as those were on
the stack because the environment was passed to the program being executed, as
we already know.  In my case, the output was:

\begin{verbatim}
$ ./a.out 
: BLOCKSIZE=K: No such file or directory
: FTP_PASSIVE_MODE=YES: No such file or directory
: HISTCONTROL=ignoredups: No such file or directory
: HISTSIZE=10000: No such file or directory
...
...
\end{verbatim}

\end{itemize}

%%%%%

\pdfbookmark[1]{ELF}{ELF}

\begin{slide}
\sltitle{Executable file format}
\begin{itemize}
\item \emsl{a.out} format, in early UNIX versions
\item \emsl{Common Object File Format (COFF)} -- AT\&T System V, superseded
\emsl{a.out}
\item \emsl{Extensible Linking Format (ELF)} -- new in SVR4, replaced both older
formats
\item ELF format:\quad
\raisetab{\begin{tabular}[t]{|c|}
\hline
ELF header\\
\hline
\quad \quad program header table \quad\quad \\
\hline
section 1\\
\hline
$\vdots$\\
\hline
section N\\
\hline
section header table\\
\hline
\end{tabular}}
\end{itemize}
\end{slide}

\label{ELF}

\begin{itemize}
\item The UNIX standard does not specify what executable file format systems
should use.  While most of the UNIX and unix-like systems (eg. Linux distros)
use ELF, there are other widely used systems that do not.  One example is
Mac~OS~X (which is a certified UNIX system) that uses the \emph{Mach-O} file
format, short for \emph{Mach Object}.  Each Mach-O file is made
up of one Mach-O header, followed by a series of load commands, followed by one
or more segments, each of which contains between 0 and 255 sections.
\item On Solaris, the \texttt{elfdump} command allows listing sections of the
ELF file in a human readable form.  On Linux distros, use \texttt{readelf}.
\item The \emph{ELF header} contains basic information about the file.  Try
``\texttt{readelf -h /bin/ls}'' on any Linux distro.
\item The \emph{program header table} is only present in files that are
executable.  For example, dynamic libraries are ELF files that are not
executable.  It contains information on the virtual memory layout.  You can list
the table via ``\texttt{elfdump~-p}'' or ``\texttt{readelf~-l}''.
\item Sections contain code, data, symbol table, relocation data, etc.
\item The \emph{section header table} contains information for the linker, see
``\texttt{elfdump -c}'' or ``\texttt{readelf~-S}''.
\item Some systems sticked to a format based on the original \emph{a.out} for a
long time.  For example, OpenBSD moved from \emph{a.out} to ELF in 2003 when
releasing version 3.4.
\item Today it is common that systems randomly arrange the address space
positions of key data areas of a process, including the base of the executable
and the positions of the stack, heap and libraries.  This technique is called
\emph{Address Space Layout Randomization} (ASLR) and its objective is to prevent
an attacker from reliably jumping to, for example, a particular exploited
function in memory.  First introduced as a Linux kernel patch.  OpenBSD was the
first mainstream operating system to support ASLR by default, in version 3.4,
released in 2003.  Different systems apply this technique with different
parameters and on different parts of a program.  In general it is possible to
introduce randomness into other parts of a system, for example process IDs,
initial TCP sequence numbers, etc.
\end{itemize}

%%%%%

\pdfbookmark[1]{exit, wait, waitpid}{procexit}

\begin{slide}
\sltitle{Program termination}
\setlength{\baselineskip}{0.6\baselineskip}
\texttt{void \funnm{exit}(int \emph{status});}
\begin{itemize}
\item terminates a process with a return value \emph{status}.  Never returns.
\end{itemize}
\texttt{pid\_t \funnm{wait}(int *\emph{stat\_loc});}
\begin{itemize}
\item waits for a child process termination, returns its PID and puts
termination information into \emph{stat\_loc} which can be tested as:
    \begin{itemize}
    \item \texttt{WIFEXITED(stat\_loc)} \dots{} process called
    \texttt{exit()}
    \item \texttt{WEXITSTATUS(stat\_loc)} \dots{} argument of
    \texttt{exit()}
    \item \texttt{WIFSIGNALED(stat\_loc)} \dots{} process got a signal
    \item \texttt{WTERMSIG(stat\_loc)} \dots{} signal number
    \item \texttt{WIFSTOPPED(stat\_loc)} \dots{} process stopped
    (\texttt{WUNTRACED} flag required, need \funnm{waitpid} below)
    \item \texttt{WSTOPSIG(stat\_loc)} \dots{} stop signal number
    \end{itemize}
\end{itemize}
\texttt{pid\_t \funnm{waitpid}(pid\_t \emph{pid}, int *\emph{stat\_loc},
int \emph{opts});}
\begin{itemize}
\item waits for a specific child process termination
\end{itemize}
\end{slide}

\begin{itemize}
\item \emph{status\_loc} equal to \texttt{NULL} means to ignore the status
information.
\item Function \funnm{\_exit} works as \funnm{exit} but it does not flush stdio
streams and functions registered with the \funnm{atexit} call are not called.
\item There is also \texttt{WIFCONTINUED(stat\_loc)} which means a restarted
process after having been stopped before.  However, it is part of an extension
that not all systems support.
\item You can stop a process using ``\texttt{kill -STOP <PID>}'',
and restart it with ''\texttt{kill -CONT <PID>}''.
\item \emph{opts} in \funnm{waitpid} are an OR combination of the following
flags:
    \begin{itemize}
    \item \texttt{WNOHANG} \dots{} does not hang if there are no processes
    that wish to report status
    \item \texttt{WUNTRACED} \dots{} children of the current process that were
    stopped due to a \texttt{SIGTTIN}, \texttt{SIGTTOU}, \texttt{SIGTSTP}, or
    \texttt{SIGSTOP} signal also have their status reported.  Such processes are
    reported only once per such a situation.
    \item \texttt{WCONTINUED} \dots{} also report children of the current
    process that were restarted after having been stopped (and not waited for
    yet).  Part of the same extension as \texttt{WIFCONTINUED}.
    \item For the \texttt{WUNTRACED} and \texttt{WCONTINUED} flags, you should
    only use them in portable code if a macro \texttt{\_POSIX\_JOB\_CONT\-ROL}
    is defined in \texttt{<unistd.h>}.
    \end{itemize}
\item \emph{pid} in \funnm{waitpid}:
    \begin{itemize}
    \item \texttt{== -1} \dots{} wait for any child
    \item \texttt{> 0} \dots{} wait for a specific child
    \item \texttt{== 0} \dots{} wait for any child in the same process group as
    the calling process
    \item \texttt{< -1} \dots{} wait for any child in the process group of
    \texttt{abs(pid)}
    \end{itemize}
\item There are also \funnm{wait3} and \funnm{wait4} calls.
\item A parent should always call one of the wait functions otherwise the system
will accumulate \emph{zombies} -- terminated processes that occupy process table
slots only to be waited for by their parents.  Zombies could eventually exhaust
all the system memory.  Note that if the parent exits, its children are adopted
by the \texttt{init} process that will call \funnm{wait} on such processes.
However, you should always use wait for children even if you know the parent
will exit soon.
\item Actually, you could notify the system that the program will not wait for
its children in which case such zombies will not accumulate.  More on that later
when we do signals.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Example: start a new process and wait}
\begin{center}
\input{img/tex/fork_wait.tex}
\end{center}
\end{slide}

\begin{itemize}
\item This is a typical way to start a new process and continue after its
termination.  The parent could also choose not to wait for the child termination
right away but carry on with its life and wait for the child later.
\item Note that you have to use macros from the previous slide to get the
child's return value out of the status information.
\item \label{WAITPID} Example: \priklad{wait/wait.c}
\end{itemize}

%%%%%

\label{PIPEREADWRITE}

\pdfbookmark[1]{pipe}{pipe}

\begin{slide}
\sltitle{\texttt{pipe()}}
\texttt{int \funnm{pipe}(int \emph{fildes}[2]);}
\begin{itemize}
\item creates an unnamed pipe and allocates a pair of file descriptors
    \begin{itemize}
    \item \texttt{fildes[0]} \dots{} reading from a pipe
    \item \texttt{fildes[1]} \dots{} writing to a pipe
    \end{itemize}
\item the system makes sure that:
    \begin{itemize}
    \item producer blocks on writing if the pipe is full
    \item consumer blocks on reading if the pipe is empty
    \end{itemize}
\item consumer gets EOF (ie. \texttt{read()} returns
\texttt{0}) only if all copies of \texttt{fildes[1]} are closed.
\item named pipe (ie. fifo, see \funnm{mkfifo}) works the same way.  The
difference is any process can use it.
\end{itemize}
\end{slide}

\label{PIPE}

\begin{itemize}
\item An unnamed pipe is created by one process and can be passed to its
children only via file descriptors inherited through \funnm{fork}.  That
limitation can be worked around via passing an open file descriptor via a
u{}nix-domain socket.  However, such a workaround is out of scope for this
class.
\item If the function \funnm{write} writes at most \texttt{PIPE\_BUF} bytes to
the pipe, it is guaranteed that the write will be atomic, ie. those bytes will
not be interlaced with bytes written by other producers.
\item \label{TWO_WAY_PIPES} The SUSv3 standard does not specify whether
\texttt{fildes[0]} is also open for writing and if \texttt{fildes[1]} is also
open for reading.  FreeBSD and Solaris provide bidirectional pipes while Linux
may not.  It is best to assume unidirectional pipes.
\item \emsl{Important:} the same rules applied to reading and writing from/to
named pipes stand for unnamed pipes as well, see page \pageref{NAMEDPIPE}.
\item Examples: \priklad{pipe/broken-pipe.c}, \priklad{pipe/main.c}
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Example: a pipe between two processes}
\begin{center}
\input{img/tex/pipe.tex}
\end{center}
\end{slide}

\label{FDSHARING}

\begin{itemize}
\item Closing the writing descriptor \texttt{pd[1]} (see
{\color[rgb]{1,0,0} $\triangleright$}) in the consumer process is required
as the EOF would not be detected otherwise.
\item Closing the reading descriptor \texttt{pd[0]} in the consumer process is
desired as well (see {\color[rgb]{1,0,0} $\triangleright$}) as if the
consumer finishes prematurely the producent properly gets a \texttt{SIGPIPE}.
If that file descriptor in the producer was not closed while the consumer died
in the middle of processing the data, for example, the producer would not learn
that the consumer was gone (as the producer would remain to be an existing
reader itself), and would hang indefinitely on \funnm{write} after filling up
the pipe.
\item If we are not sure that the descriptor \texttt{0} was open before calling
\funnm{pipe}, we have to call \texttt{dup2(pd[1], 1)} in the producer as
otherwise \texttt{dup(pd[1])} could reuse the file descriptor \texttt{0} in
place of expected \texttt{1}.  You might also need to check if \verb#pd[1] == 1#
(ie. standard output was closed before calling \funnm{pipe}) as in that case we
could actually close one end of the pipe.  Similarly, in the consumer you might
need to check if \verb#pd[0] == 0#.
\item It is better to create a pipe from a child to its parent as typically the
process writing the pipe finishes first, then the consumer reads the rest of the
data, process it, and then finally exits.  Remember, the shell waits for the
program it started, ie. the parent, and it does not care at all about children
the running program spawned during its life.  If the pipe was created the other
way around, the shell could print the prompt after the parent finished while the
data from the child might still be flowing to the console.
\item For example, the original \emph{Bourne shell} constructed a pipeline the
way that the last process created a child as its producer, that producer itself
created its child as its producer, and this continued until the whole pipeline
was formed.  Ie. the first command in the pipeline was created as the last
process.
\item However, in \texttt{bash}, all processes in a pipeline are direct children
of the shell itself, ie. \texttt{bash} calls \funnm{fork} that many times as is
the number of programs in the pipeline.  Before the prompt is printed, it waits
for all processes to finish.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Shared memory -- introduction}
\begin{itemize}
\item pajpy a soubory jako metody meziprocesové komunikace vy¾adují
systémová volání
\item výhoda: procesy nemohou po¹kodit adresový prostor jiného
procesu
\item nevýhoda: velká re¾ie pro systémová volání, typicky
\funnm{read}, \funnm{write}
\item sdíl{}ená pamì» je namapování èásti pamìti do adresového
prostoru více procesù
\item odstranìní nevýhody, ztráta dosavadní výhody
\item synchronizace pøístupu do sdíl{}ené pamìti
\begin{itemize}
  \item System V semafory
  \item POSIX semafory bez nutnosti systémového volání v bì¾ném
  pøípadì
\end{itemize}
\end{itemize}
\end{slide}

\begin{itemize}
\item mapování souborù do pamìti je jednou z implementací sdíl{}ené
pamìti. Pro popis úseku sdíl{}ené pamìti pou¾ívá soubor.
\item takto implementovaná sdíl{}ená pamì» je tedy pravidelnì
zapisována na disk
\item pro sdíl{}ení bez re¾ie zápisu zmìnìných dat na disk je mo¾né pou¾ít
\emph{memory based} filesystém, napøíklad \emph{tmpfs} (Solaris, NetBSD -- zde
byl \emph{tmpfs} napsán v roce 2005 jako souèást \emph{Summer of Code}
sponzorovaného firmou Google, FreeBSD má podobnou vlastnost pod názvem
\emph{memory disk}).  Jako tzv. \emph{backing store} pro pamì»ové stránky
patøící tìmto filesystémùm je obecnì mo¾né pou¾ít swap oblast na disku.
\item pro synchronizaci pøístupu do sdíle{}né pamìti se vìt¹inou pou¾ívají
semafory.
\end{itemize}

%%%%%

\pdfbookmark[1]{mmap}{mmap}

\begin{slide}
\sltitle{Mapování souborù do pamìti (1)}
\begin{minipage}{\slidewidth}\vspace{-1\baselineskip}\texttt{\begin{tabbing}
void *\funnm{mmap}(\=void *\emph{addr}, size\_t \emph{l{}en},
int \emph{prot}, int \emph{flags},\\\> int \emph{fildes}, off\_t \emph{off});
\end{tabbing}}
\end{minipage}
\begin{itemize}
\item do pamì»ového prostoru procesu od adresy \texttt{addr}
(\texttt{0} \dots{}adresu pøidìlí jádro) namapuje úsek délky
\texttt{l{}en} zaèínající na pozici \texttt{off} souboru
reprezentovaného deskriptorem \texttt{fildes}. 
\item vrací adresu namapovaného úseku nebo \texttt{MAP\_FAILED}. 
\item v \texttt{prot} je OR-kombinace \texttt{PROT\_READ} (lze
èíst), \texttt{PROT\_WRITE} (lze zapisovat), \texttt{PROT\_EXEC}
(lze spou¹tìt), nebo \texttt{PROT\_NONE} (nelze k~datùm
pøistupovat). 
\item ve \texttt{flags} je OR-kombinace \texttt{MAP\_PRIVATE} (zmìny
jsou privátní pro proces, neukládají se do souboru),
\texttt{MAP\_SHARED} (zmìny se ukládají do souboru),
\texttt{MAP\_FIXED} (jádro nezmìní addr).
\end{itemize}
\end{slide}

\label{MMAP}

\begin{itemize}
\setlength{\itemsep}{0.8\itemsep}
\item Pøíklady: \priklad{mmap/reverse.c}, \priklad{mmap/map-nocore.c}
\item v pøíznacích musí být pøítomen \emsl{právì jeden} z \texttt{MAP\_PRIVATE}
a \texttt{MAP\_SHARED}
\item mapování souborù do pamìti je alternativou ke zpracování souborù pomocí
\texttt{read}, \texttt{write}, \texttt{lseek}.  Po namapování lze se
souborem pracovat jako s datovou strukturou v pamìti. Soubor se nekopíruje celý
do pamìti, alokují se pouze stránky na které se pøistupuje. Pokud je potøeba
stránku uvolnit, obsah se ukládá zpìt do souboru (kdy¾ je pou¾it
\texttt{MAP\_SHARED} -- tento zpùsob namapování je tedy ekvivalentní tomu, kdy
program zapí¹e do stejného souboru pomocí \texttt{write(2)}) nebo do swapu --
pou¾ívá se mechanizmus copy-on-write (pøi \texttt{MAP\_PRIVATE}).
\item pro namapování souboru do pamìti tedy potøebuji soubor nejdøíve otevøít
pomocí \texttt{open}. Mód v \texttt{prot} nemù¾e být ``vy¹¹í'' ne¾ bylo
specifikováno v módu pro \texttt{open}. Pou¾ití \texttt{MAP\_FIXED} se
nedoporuèuje, proto¾e to mù¾e být problém pro pøenositelnost kódu.
\item \textbf{varování:} toto se týká pouze \texttt{MAP\_SHARED} -- pokud je
soubor jiným procesem zkrácen tak, ¾e zkrácení se týká i právì namapované èásti,
pøi pøístupu do takové pamìti je procesu
zaslán signál \texttt{SIGBUS} resp. \texttt{SIGSEGV}.
Øe¹ením je pou¾ít mandatory locking, to ale není
v¹ude implementováno. V pøípadì, ¾e je namapovaná pamì» pou¾ita jako parametr
volání \texttt{write}, signál se nepo¹le, proto¾e \texttt{write} vrátí -1
a \texttt{errno} je nastaveno na \texttt{EFAULT}.
\item pøi pou¾ití \texttt{MAP\_PRIVATE} vidím na Solarisu v¹echny zmìny
provedené jinými procesy, které namapovaly sdíl{}enì, a¾ do té doby, kdy do
stránky zapí¹u -- v tom okam¾iku se vytvoøí kopie stránky a dal¹í takové zmìny
ji¾ nevidím. Na FreeBSD tyto zmìny nevidím ani pøed zápisem. Viz specifikace:
\emph{,,It is unspecified whether modifications to the underlying object done
after the \texttt{MAP\_PRIVATE} mapping is established are visible through the
\texttt{MAP\_PRIVATE} mapping.''}
\item hodnota \texttt{off+l{}en} mù¾e pøekraèovat aktuální velikost souboru, za
konec souboru ale nelze zapisovat a soubor tak prodlou¾it - proces by obdr¾el
signál \texttt{SIGBUS} resp. \texttt{SIGSEGV},
viz pøíklad \priklad{mmap/lseek.c}.  Signál dostanu stejnì tak v situaci, kdy
do read-only namapovaného segmentu zkusím zapsat (je to logické, pøiøazení
nemá návratovou hodnotu kterou byste mohli otestovat).
\item mapuje se v¾dy po celých stránkách, hodnoty \texttt{off} (a pøi
\texttt{MAP\_FIXED} i \texttt{addr}) musí být správnì zarovnané.  Poslední
stránka je za koncem souboru doplnìna nulami a tento úsek se nikdy nepøepisuje
do souboru.
\item Anonymní mapování lze sdílet mezi rùznými procesy pouze pomocí
\texttt{fork()}. Jedinou alternativou je pamì» sdílená pomocí systémového
volání \texttt{shmat}.
\item pøístup do namapovaného úseku, ale za poslední existující stránku
namapovaného objektu, zpùsobí signál \texttt{SIGBUS} resp. \texttt{SIGSEGV}.
Neplatí to v¹ude úplnì pøesnì, viz pøíklad \priklad{mmap/sigbus.c}.
\item Pøi pou¾ití \texttt{MAP\_FIXED} namapování souboru nahradí pøípadné
pøedchozí mapování stránek v rozsahu.
\texttt{addr} a¾ \texttt{addr+l{}en-1}, viz pøíklad \priklad{mmap/override.c}.
\item existující roz¹íøení pro flagy (nejsou souèástí SUSv3):
    \begin{itemize}
    \setlength{\itemsep}{0.8\itemsep}
    \item pøíznak \texttt{MAP\_ANON} ve FreeBSD a Solarisu -- vytvoøení
    anonymního segmentu bez vazby na soubor, deskriptor musí být \texttt{-1}.
    Mapuje se tak anonymní objekt, který jak víme má místo fyzického ulo¾ení
    na swapu (tedy není trvalé). Linux má podobnou funkcionalitu pøes
    \texttt{MAP\_ANONYMOUS}. Tento pøíznak pou¾ívají pamì»ové alokátory, které
    pracují s voláním \texttt{mmap}, viz také strana
    \pageref{SOLARIS_PROC_ADDR_SPACE}.
    \item v IRIXu lze pomocí \texttt{MAP\_AUTOGROW} automaticky
    zvìt¹it namapovaný objekt pøi pøístupu za jeho stávající konec.
    \end{itemize}
\item bì¾ným pøíkazem, který pou¾ívá mapování souborù do pamìti, je
\texttt{cat(1)}. Èíst z takové pamìti je prostì rychlej¹í ne¾ opakovanì volat
\texttt{read}, kde je nutné se pro ka¾dé takové volání pøepnout z u¾ivatelského
re¾imu do re¾imu jádra a zpìt.
\end{itemize}


%%%%%

\pdfbookmark[1]{msync, munmap, mprotect}{msync}

\begin{slide}
\sltitle{Mapování souborù do pamìti (2)}
\texttt{int \funnm{msync}(void *\emph{addr}, size\_t \emph{l{}en},
int \emph{flags});}
\begin{itemize}
\item zapí¹e zmìnìné stránky v úseku l{}en bajtù od adresy addr do
souboru. Hodnota flags je OR-kombinace 
    \begin{itemize}
    \item \texttt{MS\_ASYNC} \dots{} asynchronní zápis 
    \item \texttt{MS\_SYNC} \dots{} synchronní zápis 
    \item \texttt{MS\_INVALIDATE} \dots{} zru¹it namapovaná data,
    která se li¹í od obsahu souboru 
    \end{itemize}
\end{itemize}
\texttt{int \funnm{munmap}(void *\emph{addr}, size\_t \emph{l{}en});}
\begin{itemize}
\item zapí¹e zmìny, zru¹í mapování v délce \texttt{l{}en} od adresy
\texttt{addr}. 
\end{itemize}
\texttt{int \funnm{mprotect}(void *\emph{addr}, size\_t \emph{l{}en},
int \emph{prot});}
\begin{itemize}
\item zmìní pøístupová práva k namapovanému úseku souboru. Hodnoty
prot jsou stejné jako u \texttt{mmap()}.
\end{itemize}
\end{slide}

\begin{itemize}
\item ulo¾ení zmìn do souboru na disk je zaruèené a¾ po provedení
\texttt{msync} nebo \texttt{munmap}, ale ostatní procesy, které
mají soubor namapován, vidí zmìny hned.
\item mapování pamìti a nastavování pøístupových práv pou¾ívá napø.
knihovna Electric Fence, která slou¾í pro ladìní chyb pøi práci s
dynamickou pamìtí.
\end{itemize}


%%%%%

\begin{slide}
\sltitle{Pøíklad: mapování souborù do pamìti}
\setlength{\baselineskip}{0.8\baselineskip}
\begin{alltt}
int main(int argc, char *argv[])
\{
    int fd, fsz; char *addr, *p1, *p2, c;

    fd = \emprg{open}(argv[1], O\_RDWR);
    fsz = \emprg{lseek}(fd, 0, SEEK\_END);
    p1 = addr = \emprg{mmap}(0, fsz, PROT\_READ|PROT\_WRITE,
                     MAP\_SHARED, fd, 0);
    p2 = p1 + fsz - 1;
    while(p1<p2) \{
        c = *p1; *p1++ = *p2; *p2-- = c;
    \}
    \emprg{munmap}(addr, fsz); 
    \emprg{close}(fd);
    return (0);
\}
\end{alltt}
\end{slide}

\begin{itemize}
\item Tento program otoèí poøadí znakù v souboru (zapí¹e soubor od konce k
za\-èát\-ku).
\item Jedna z hlavních výhod sdílených segmentù je mo¾nost pracovat s
daty v souboru pomocí pointerové aritmetiky. Obecnì je ale nutné dát pozor
na zarovnání pøi dereferencích; napø. na SPARCu dojde pøi takovém pøístupu
signál \texttt{SIGBUS}, viz pøíklad \priklad{mmap/aligned.c}.
\end{itemize}

%%%%%

\pdfbookmark[1]{dlopen, dlsym, dlclose, dlerror}{dynlib}

\begin{slide}
\sltitle{Dynamický pøístup ke knihovnám}
\texttt{void *\funnm{dlopen}(const char *\emph{file}, int \emph{mode});} 
\begin{itemize}
\item zpøístupní knihovnu v souboru \texttt{file}, vrátí
\emsl{handle} nebo \texttt{NULL}.
\item v \emph{mode} je OR-kombinace \texttt{RTLD\_NOW} (okam¾ité relokace),
\texttt{RTLD\_LAZY} (odlo¾ené relokace), \texttt{RTLD\_GLOBAL}
(symboly budou globálnì dostupné), \texttt{RTLD\_LOCAL} (nebudou
globálnì dostupné). 
\end{itemize}
\texttt{void *\funnm{dlsym}(void *\emph{handle}, const char *\emph{name});}
\begin{itemize}
\item vrátí adresu symbolu zadaného jména z knihovny. 
\end{itemize}
\texttt{int \funnm{dlclose}(void *\emph{handle});}
\begin{itemize}
\item ukonèí pøístup ke knihovnì. 
\end{itemize}
\texttt{char *\funnm{dlerror}(void);}
\begin{itemize}
\item vrátí textový popis chyby pøi práci s knihovnami.
\end{itemize}
\end{slide}

\label{DLOPEN}

\begin{itemize}
\item pomocí tìchto funkcí lze implementovat dynamicky nahrávané plug-in moduly
naèítané aplikací podle potøeby (napø. podle obsahu jejího
kon\-fi\-gu\-raè\-ní\-ho souboru).
\item dynamickým naèítáním knihoven se také dá vyøe¹it situace, kdy potøebujeme
vyu¾ít nìkolik knihoven, které definují symbol se stejným jménem. Jedna knihovna
se pøímo pøilinkuje k programu, k ostatním se pøistupuje pomocí \texttt{dlopen}.
\item soubor musí být ve správném formátu (sdíl{}ená knihovna \texttt{.so} ve
formátu \emph{ELF} resp. formátu podporovaném na daném systému),
napøíklad u \texttt{gcc} to znamená pou¾ít pøepínaè \texttt{-shared},
u \texttt{cc} na Solarisu (Sun Studio Compiler) je to pøepínaè \texttt{-G}.
Na OS X (s formátem \emph{Mach-O}) je to \texttt{-dynamiclib}, knihovny
mají pøíponu \texttt{.dynlib}.
\item pokud cesta obsahuje znak \texttt{/}, bere se podle tvaru jako globální
nebo re\-la\-tiv\-ní. Pokud lomítko neobsahuje, pou¾ije se pro hledaní objektu
defaultní na\-sta\-ve\-ní dynamického linkeru, typicky \texttt{/lib} a
\texttt{/usr/lib}, které se dá roz¹íøít pomocí promìnné
\texttt{LD\_LIBRARY\_PATH}. Na její pou¾ití ov¹em pozor, viz poznámky na
stranì \pageref{EVIL_LDLIBPATH}.
\item konstanty pro parametr \emph{mode} funkce \funnm{dlopen}:
    \begin{itemize}
    \item \texttt{RTLD\_NOW} -- v¹echny relokace (vyøe¹ení v¹ech odkazù) pro
    symboly nalezené v pøipojovaném objektu jsou provedeny okam¾itì po nata¾ení
    knihovny, aplikace má jistotu, ¾e jsou v¹echny symboly pøístupné
    \item \texttt{RTLD\_LAZY} -- relokace mohou být odlo¾eny a¾ do chvíle
    pou¾ití symbolu. Co to v praxi znamená? Pokud otevøete objekt, který závisí
    na dal¹ích objektech, dynamický linker tyto ostatní závislé objekty mapuje
    do pa\-mì\-ti, a¾ kdy¾ jsou opravdu potøeba. Mù¾e se tak stát, ¾e závislosti
    neexistují, ale volání \texttt{dlopen} stejnì uspìje. U \texttt{RTLD\_NOW}
    se závislé objekty mapují do pamìti hned, a teprve pak \texttt{dlopen} vrátí
    pøíslu¹ný handle. Na Solarisu mù¾ete defaultní chování pro dynamický linker
    vynutit promìnnými prostøedí \texttt{LD\_BIND\_NOW} a
    \texttt{LD\_BIND\_LAZY}. Pøi konfliktu nastavení má v¾dy pøednost nastavení
    \texttt{NOW}, a» ji¾ je globální nebo jen v módu volání \texttt{dlopen} pøi
    mapování jednoho konkrétního objektu. Pøi spou¹tìní aplikace jsou v¹echny
    závislé objekty defaultnì mapované hned, ale je mo¾né jednotlivé knihovny
    linkovat pro ,,lazy binding'' pomocí \texttt{-z lazyload}, viz manuálové
    stránky pro \texttt{ld} a \texttt{ld.so.1}. Pøíklad:
    \priklad{dyn-lib/ld-lazy.c}.
    \item \texttt{RTLD\_GLOBAL} \dots{} symboly z knihovny mohou být pou¾ity pøi
    zpracování relokací v ostatních knihovnách a jsou dostupné pomocí
    \texttt{dlopen(0, RTLD\_GLOBAL)}. Toto je defaultní nastavení pro objekty
    mapované pøi spu¹tìní programu. Pro \texttt{dlopen} je defaultní nastavení
    \texttt{RTLD\_LOCAL}. To znamená, ¾e je mo¾né namapovat stejnou knihovnu
    nìkolikrát a symboly se nebudou vzájemnì pøekrývat. Pozor ale na to, kdy¾
    takové knihovny budou pou¾ívat symboly jiného globální objektu - napø.
    \texttt{errno} z \texttt{libc.so}. Takový symbol je dále spoleèný pro
    v¹echny namapované objekty, vèetnì tìch mapovaných pomocí
    \texttt{RTLD\_LOCAL}.
    \end{itemize}
\item \label{RTLD_NEXT} speciální handle \texttt{RTLD\_NEXT} hledá symbol pouze
v knihovnách nahraných po knihovnì, ve které je volání \texttt{dlsym}. Hodí se
pro pøedefinování existujících funkcí, pokud v redefinované funkci potøebujeme
volat pùvodní. Kni\-ho\-vna s novou funkcí se nahrává jako první (napø. pomocí
promìnné \texttt{LD\_PRELOAD}), adresu pùvodní funkce získá voláním
\texttt{dlsym(RTLD\_NEXT, \emph{fn\_name})}. Pøíklad:
\priklad{dyn-lib/rtld\_next.c}.
\item v¹echny tyto funkce jsou souèástí dynamického linkeru, který má ka¾dá
dynamicky slinkovaná aplikace namapovaný ve svém adresovém prostoru. Viz také
strany \pageref{RUNTIMELINKER} a \pageref{EXEC}.
\end{itemize}


%%%%%

\begin{slide}
\sltitle{Pøíklad: zpøístupnìní knihovny}
\begin{alltt}
char *err;
void *handle;
double y, x = 1.3;
double (*fun)(double); 
char *libname = "libm.so", *fn\_name = "sin";

if ((handle = \emprg{dlopen}(libname, RTLD\_NOW)) == NULL) \{
        fprintf(stderr, "%s\bs{}n", dlerror()); exit(1);
\}
fun = \emprg{dlsym}(handle, fn\_name);
if ((err = \emprg{dlerror}()) != NULL)
        fprintf(stderr, "%s\bs{}n", err); exit(1);
y = fun(x);
\emprg{dlclose}(handle);
\end{alltt}
\end{slide}

\begin{itemize}
\item zde se volá funkce \texttt{sin} z knihovny matematických funkcí
\texttt{libm.so}.
\item funkce \texttt{dlsym} vrátí adresu symbolu daného jména, ale
v¾dy jako ukazatel na \texttt{void}, neprobíhá ¾ádná typová kontrola
ani není k dispozici ¾ádná informace o typu symbolu. Ten, kdo tuto
adresu pou¾ívá, musí zajistit její správné pøetypování. 
\item pøi pou¾ití knihoven v C++ je tøeba si uvìdomit, ¾e C++
pou¾ívá \emph{name mangling}, tj. do jména funkce (metody) je
zakódováno pøípadné jméno tøídy nebo namespace a typy parametrù.
\item pøíklad: \priklad{dyn-lib/dlopen.c}
\end{itemize}

\endinput
