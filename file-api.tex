changequote([[[, ]]])

\pdfbookmark[1]{standard file descriptors}{stdfds}

\begin{slide}
\sltitle{File API}
\begin{itemize}
\item before working with a file, it must be first open via
\funnm{open}() or \funnm{creat}()
\item open files are accessible via \emph{file descriptors}, numbered from 0.
More descriptors can share the same file opening (read/write mode, position).
\item standard file descriptors
    \begin{itemize}
    \item 0 \dots{} standard input (read only) 
    \item 1 \dots{} standard output (write only) 
    \item 2 \dots{} unbuffered error output (write only) 
    \end{itemize}
\item for reading and writing a file: \funnm{read}(), \funnm{write}()
\item position change: \funnm{lseek}(), close: \funnm{close}(),
information: \funnm{stat}(), file control: \funnm{fcntl}(),
access rights: \funnm{chmod}(), \dots
\end{itemize}
\end{slide}

\begin{itemize}
\item Every function that allocates file descriptors (not just \funnm{open}() or
\funnm{creat}() but also \funnm{pipe}(), see page \pageref{PIPEREADWRITE}, and
\funnm{dup}(), see page \pageref{DUP_CALL}, for example), always uses the first
available descriptor number.  That is very important and will be later used when
we work with pipes and redirect process input and output.
\item A process inherits file descriptors from its parent so it does not have to
open already open files.  Usually at least file descriptors 0, 1, and 2 are
provided.
\item Functions from a header file \texttt{stdio.h} (eg. \funnm{fopen}(),
\funnm{fprintf}(), and \funnm{fscanf}()), and their file handle \texttt{FILE}
are defined in the standard libc library and use standard system calls like
\funnm{open}(), \funnm{write}(), and \funnm{read}().  From those functions, we
will only use functions for printing to the terminal output like
\funnm{fprintf}().
\end{itemize}

%%%%%

\begin{slide}
\sltitle{System View of Open Files}
\begin{center}
%\input{img/tex/open_files1.latex}
\includegraphics[width=89mm]{img/eps/open_files1.eps}
% This is too big.  I'd have had to shrunk it.
%\includegraphics{img/eps/open_files1.eps}
\end{center}
\end{slide}

\label{OPENFILETABLES}

\begin{itemize}
\item This is a simplified view of the kernel tables that deal with files.  It
is modeled after a similar picture in [Bach].  Today it is more compliated but
the main idea stays.  See the next slide for how it may look present time
systems.
\item Each process on the system has its \emph{file descriptor table}.
\item Slots in that table points to the \emph{system file table}.  There is
only one such a table in kernel.  This table carries the opened file mode and
also the \emsl{current file position.}
\item From the system file table, it is pointed to the \emph{system inode
table}.  Nowadays the table contains so called \emph{vnodes} -- \emph{virtual
nodes} but that is not relevant for us now.
\item The system file table represents an additional level of indirection so
that different processes can share the file position.
\item When opening a file via an \texttt{open} call, a new slot in both the file
descriptor and system file tables is always allocated.  File position sharing in
the same process is achieved via file descriptor duplication where more
descriptors share the same system file table slot.  If a file position sharing
is needed among multiple processes, that is achieved via the \texttt{fork}
call, and it is explained on page \pageref{FDSHARING}.
\end{itemize}

%%%%%

\pdfbookmark[1]{open}{open}

\begin{slide}
\sltitle{Opening a file: \texttt{open()}}
\texttt{int \funnm{open}(const char *\emph{path}, int \emph{oflag},
... );}
\begin{itemize}
\item opens a file \texttt{path}, returns its file descriptor. The
\texttt{oflag} is an OR combination of the following flags:
    \begin{itemize}
    \item \texttt{O\_RDONLY}/\texttt{O\_WRONLY}/\texttt{O\_RDWR} \dots{}
    open for reading, writing, or both
    \item \texttt{O\_APPEND} \dots{} append only
    \item \texttt{O\_CREAT} \dots{} create the file if it does not exist
    \item \texttt{O\_EXCL} \dots{} fail if the file exists (for use with
    \texttt{O\_CREATE})
    \item \texttt{O\_TRUNC} \dots{} truncate the file (write permission
    needed)
    \item \dots{}
    \end{itemize}
\item with \texttt{O\_CREAT}, the third parameter \emph{mode}
defines the access mode for the newly create file
\end{itemize}
\end{slide}

\label{OPEN}

\begin{itemize}
\item The first available file descriptor is always used.  
\item When \texttt{O\_CREAT} is used, the \emph{mode} is modified using the
current mask that can be changed via a shell command \texttt{umask} -- those
bits in \emph{mode}, also set in the process umask, are nullified.  The
default umask value is typically (and historically) \texttt{022}.  We recommend
you to always se it to \texttt{077} in your profile script.  Never do that for
root though otherwise you will end up with a system in a non-supported
configuration -- installed software will not be possible to run by
non-privileged users, what worked before may stop working, etc.
\item If the \emph{mode} argument is required and not specified, you get
whatever is on the stack.  Both flags and the mode are stored in the system file
table, see page \pageref{OPENFILETABLES}.
\item Macros for use with \emph{mode} can be usually found in the manual page
for \texttt{chmod(2)}, and you can find them also in the \texttt{stat.h} header
file (or in another file included from it) where the standard requires them to
be.
\item A no longer needed slot in the file descriptor or system file table is
zeroed out before its reuse. 
\item There are other flags as well:
\begin{itemize}
\item \texttt{O\_SYNC} (\texttt{O\_DSYNC}, \texttt{O\_RSYNC}) \dots{} the call
returns after the data is physically stored (synchronized I/O).
\texttt{O\_DSYNC} is for writing synchronization only, \texttt{O\_RSYNC} for
reading.
\item \texttt{O\_NOCTTY} \dots{} when opening a terminal by a process without a
controlling terminal, the terminal being opened does not become it.
\item \label{O_NONBLOCK} \texttt{O\_NONBLOCK} \dots{} if reading or writing
cannot be satisfied right away, calls \texttt{read}/\texttt{write} will fail
instead of getting blocked and waiting for the completion.  \texttt{errno} is
set to \texttt{EAGAIN} in such a case.
\end{itemize}
\item One cannot use \texttt{O\_RDONLY | O\_WRONLY} for both reading and writing
as historically, implementations used 0 for the read-only flag.  The standard
defines that only one of those three flags may be used.
\item Is is possible to open and create a file for writing so that writing is
disallowed by its mode.  It will work for that file opening but any other file
opening for writing will fail.
\item You need write permission to use \texttt{O\_TRUNC}.
\item The behavior of \texttt{O\_EXCL} without using \texttt{O\_CREAT} at the
same is undefined.
\item For file locking, the \texttt{fcntl} call is used, see page
\pageref{FCNTL}.
\end{itemize}

%%%%%

\pdfbookmark[1]{creat}{creat}

\begin{slide}
\sltitle{Creating a file}
\texttt{int \funnm{creat}(const char *\emph{path}, mode\_t \emph{mode});}
\begin{itemize}
\item the function is equivalent to:\\
\texttt{open(path, O\_WRONLY|O\_CREAT|O\_TRUNC, mode);}
\end{itemize}
\texttt{int \funnm{mknod}(const char *\emph{path}, mode\_t \emph{mode},
dev\_t \emph{dev});}
\begin{itemize}
\item creates a device special file
\end{itemize}
\texttt{int \funnm{mkfifo}(const char *\emph{path}, mode\_t \emph{mode});} 
\begin{itemize}
\item creates a named pipe
\end{itemize}
\end{slide}

\label{MKFIFO}
\label{CREAT}

\begin{itemize}
\item The \texttt{open} call allows to open a regular file, a device, or a named
pipe.  However, it (and \texttt{creat} as well) can only create a regular file,
so you need the other two calls for non-regular files.
\item The test of a file existence using the flag \texttt{O\_EXCL} and its
subsequent creation if it did not exist, is an atomic operation.  You can use
that for lock files but only with the \texttt{open} call, not \texttt{creat}.
\item You need extra privileges to create device special files (eg. to be a
root).
\end{itemize}

%%%%%

\pdfbookmark[1]{read, write}{readwrite}

\begin{slide}
\sltitle{Reading and writing files: \texttt{read()}, \texttt{write()}}

\texttt{ssize\_t \funnm{read}(int \emph{fd}, void *\emph{buf},
size\_t \emph{nbyte});}
\begin{itemize}
\item attempts to read \emph{nbyte} bytes of data from the object referenced by
the descriptor \emph{fd} into the buffer pointed to by \emph{buf}
\item returns the number of bytes actually read, 0 on EOF, -1 on error
\end{itemize}

\texttt{ssize\_t \funnm{write}(int \emph{fd}, const void *\emph{buf},
size\_t \emph{nbyte});}
\begin{itemize}
\item attempts to write \emph{nbyte} of data to the object referenced by the
descriptor \emph{fd} from the buffer pointed to by \emph{buf}
\item number of bytes which were written is returned, -1 on error
\end{itemize}     
\end{slide}

\label{READCALL}

\begin{itemize}
\setlength{\itemsep}{0.8\itemsep}
\item For any Unix system, a file is just a sequence of bytes without any innner
structure.
\item \emsl{Behavior of \texttt{read} and \texttt{write} depends on the type of
the file} (regular, device, pipe, or socket) and whether the file is in a
blocking or non-blocking mode (flag \texttt{O\_NONBLOCK} on file opening, see
page \pageref{O_NONBLOCK}).
\item For both calls there are quite a few situations that can happen, and
which are listed in the next few paragraphs.  If unsure, consult the standard.
\item \texttt{read} returns a non-zero number of bytes less than \emph{nbyte} if
less then \emph{nbyte} bytes remain in a file, if the call was interrupted
by a signal, or if the file is a pipe, device, or socket and there is less than
\emph{nbyte} bytes available at the moment.  If there is no data, a blocking
\texttt{read} will block unless some data gets available, a non-blockin
\texttt{read} returns -1 and sets \texttt{errno} to \texttt{EAGAIN}.
\item \texttt{write} returns a non-zero number of bytes less than \emph{nbyte}
if less then \emph{nbyte} bytes can fit the file (eg. disk full), if the call
was interrupted by a signal, or if \verb#O_NONBLOCK# was set and only part of
the data fits into a pipe, socket, or a device; without \verb#O_NONBLOCK#
the call will block until all the data can be written.  If nothing can be
written, a blocking \texttt{write} blocks until writing data is possible, a
non-blocking call returns -1 and sets \texttt{errno} to \texttt{EAGAIN}.
\item \emsl{Important exceptions for pipes} are listed on page
\pageref{NAMEDPIPE}.
\item
If \texttt{read} or \texttt{write} returns a non-zero number less than
\texttt{nbyte} due to an error, a repeated call returns -1 and sets
\texttt{errno}.
\item If \texttt{read} or \texttt{write} are interrupted before they manage to
read or write, respectively, at least one byte, the call returns -1 and sets
\texttt{errno} to \texttt{EINTR}.  Note that there is a difference if the call
manages to read or write, respectively, at least one byte -- see the paragraphs
above.
\item \texttt{O\_APPEND} guarantees an atomic write to the end of a file on a
local filesystem, ie. \emsl{every} write will add data to the file end (so
called \emph{append-only} file).
\end{itemize}

%%%%%

\pdfbookmark[1]{close}{close}

\begin{slide}
\sltitle{Closing a file: \texttt{close()}}
\texttt{int \funnm{close}(int \emph{fildes});} 
\begin{itemize}
\item releases \texttt{fildes}, if it was the last descriptor for a file
opening, closes the file
\item if number of links is 0, the file data is released
\item if the last pipe descriptor is closed, remaining data is lost
\item on a process termination, implicit \texttt{close} is called on all
descriptors
\end{itemize}
\end{slide}

\begin{itemize}
\item Note that the file data is released only after the number of links gets to
0 \emsl{and} if the file was opened before, when closing it.  It means that you
can \texttt{rm} all hard links to a specific file but if a process has the file
still open, the file data remains on the disk until the process closes the file
or terminates.
\item If a process needs a temporary file, it can create it, unlink it right
away, and work with it using the existing file descriptor.  When the file
descriptor is closed (and all of its possible duplications), the file data is
released.
\item Even \texttt{close} may fail.  For example, some filesystems may write the
data on file closure, and if that write fails, \texttt{close} fails.
\item If you forget to close file descriptors when you no longer need them,
and it is a long living process, a daemon perhaps, depending on the system
configuration you may hit memory starvation as the system memory will be filled
with the ever growing file descriptor table.
\item \label{SIMPLE_CAT} A very simple \texttt{cat(1)} program:
\example{read/cat.c}
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Example: copy files}
\begin{alltt}
{\footnotesize
#include <fcntl.h>
#include <unistd.h>

int main(int argc, char *argv[])
\{
    char buf[4096];
    int inf, outf;
    ssize\_t ilen;

    inf = \emprg{open}(argv[1], O\_RDONLY);
    outf = \emprg{creat}(argv[2], 0666);
    while ((\emblue{ilen} = \emprg{read}(inf, buf, sizeof (buf))) > 0)
            \emprg{write}(outf, buf, \emblue{ilen});

    \emprg{close}(inf); \emprg{close}(outf);
    return (0);
\}
}
\end{alltt}
\end{slide}

\begin{itemize}
\item The example above is complete.  You can cut-and-paste, compile, and run
it.  Obviously, due to the slide size constraint, it is missing several error
checks otherwise needed for a well behaved utility, like checking \texttt{argc}
before using \texttt{argv}, or checking return values for \texttt{open} and
\texttt{creat}.
\item It is not efficient to read and write by a few bytes as each system call
costs a certain overhead, independent on the size of the processed block.  It is
much better to read and write larger blocks, say 8-1024KB.  You can
\texttt{strace(1)} a \texttt{cat} command on Linux to see what blocks they use
for \texttt{read}.  It may be around 128 kilobytes.  The following example,
\example{read/cat.c}, has an option \texttt{-b} for setting the read block size;
you can try different block sizes, including 1, on a reasonable big file (use
\texttt{mkfile(1)} on BSD/macOS or \texttt{fallocate(1)} on Linux to create an
arbitrarily large file), and use \texttt{time(1)} to measure the system call
overhead.
\item If you need to work with little pieces of data read from files, you can
use stream oriented functions that internally buffer the data -- \texttt{fopen},
\texttt{fread}, \dots
\item Note that we always only write as many bytes as we actually read.  See
page \pageref{READCALL} for more information on when we can read/write less data
than requested.
\end{itemize}

%%%%%
\begin{slide}
\sltitle{Working with a named pipe (FIFO)}

\begin{itemize}
\item it may not be possible to create a FIFO on a distributed filesystem (eg.
NFS or AFS)
\item you need to know the semantics of opening a FIFO
  \begin{itemize}
  \item opening a FIFO for just reading will block until a writer (aka producer)
  shows up, unless one already exists.
  \item opening a FIFO for just writing will block until a reader (aka consumer)
  shows up, unless one already exists.
  \item this behavior can be adjusted using a flag \texttt{O\_NONBLOCK}
  \end{itemize}
\item semantics for reading and writing is a bit more complicated, see
the notes below this slide.
  \begin{itemize}
  \item same as for a conventional, unnamed, pipe (will be later)
  \end{itemize}
\end{itemize}
\end{slide}

\label{NAMEDPIPE}

\begin{itemize}
\item A named pipe is created using the system call \texttt{mkfifo}, see page
\pageref{MKFIFO}.  Using an unnamed pipe is described later on page
\pageref{PIPE}.
\item A consumer is a process that opens a file/pipe for reading, a producer
opens a file/pipe for writing. 
\item It is possible to open a named pipe for reading and writing at the same
time.  The same process thus can write to the pipe and then read the same data
from it.
\item If the pipe is not yet open for writing by any process, to open the pipe
for reading without blocking on the call, one needs to use \texttt{O\_NONBLOCK},
see page \pageref{O_NONBLOCK}.  Without that flag the consumer will block
waiting for a producer.
\item However, trying to read a previously opened pipe that has no producer
results in a return value of 0, indicating the end of file -- the process will
not block waiting for a producer.  It is irrelevant whether the pipe was opened
in a blocking or non-blocking mode.
\item When writing to a pipe without a consumer (ie. the producer opened the
pipe when there was at least one existing consumer), the kernel will send the
producer a signal \texttt{SIGPIPE} (``broken pipe'').  See the following
example.  For simplicity, we are using an unnamed pipe but that does not matter
as it would have behaved in the same manner.  The \texttt{date(1)} command never
reads anything from its standard input so it is guaranteed that the producer,
\texttt{dd(1)}, will be writing to a pipe without a consumer.  If a process is
killed by a signal, the shell provides a signal number added to 128 as its
return value, and \texttt{kill -l} understands that:

\begin{verbatim}
bash$ dd if=/dev/zero | date
Sun Mar  2 01:03:38 CET 2008
bash$ echo ${PIPESTATUS[0]}
141
bash$ kill -l 141
PIPE
\end{verbatim}

\item When opening a pipe for writing only with \texttt{O\_NONBLOCK} and without
an existing consumer, the call returns -1 and \texttt{errno} is set to
\texttt{ENXIO}.  This asymmetry to opening a pipe for reading in a non-blocking
mode is due to the fact that it is not desirable to have data in a pipe that may
not be read in a short period of time.  The Unix system does not allow for
storing pipe data for arbitrary length of time.  Without the
\texttt{O\_NONBLOCK} flag, the process will block while waiting for a consumer.
By asymmetry we mean that the system does not mind to keep consumers without
producers but it tries to avoid writers without existing readers.
\item  If you want to create a process that sits on a named pipe and processes
data from producers, you need to open it with the flag \texttt{O\_RDWR} even
that you do not intend to write it.  If you do not use the flag, you might end
up with \texttt{read} returning 0 after all producers, perhaps temporarily only,
disappear, which could be solved by busy waiting.  A much better solution would
be to use the \texttt{select} call, see page \pageref{SELECT}.
\item Writing data of length \texttt{PIPE\_BUF} bytes or less
(\texttt{limits.h}) is guaranteed as atomic, ie. data will not be intermingled
with data written by other writers.  For example, on Linux kernel 4.x it is 4096
bytes, on Solaris 11 it is 5120 bytes, and on FreeBSD 8.2 it is only 512 bytes.
It is obvious from the above that if you write less or equal than
\texttt{PIPE\_BUF}, you always write the whole data or fail, and if
\texttt{O\_NONBLOCK} is set and the whole data buffer cannot be written (for
example, a pipe can hold only a limited number of bytes), the call will fail.
\item A pipe has no file position, you always append data to a pipe.
\item All the information here applies to a unnamed pipes as well, see page
\pageref{PIPE}.

%%%\item pro zápis platí toto (pøevzato z [Rochkind]):
%%%
%%%\renewcommand{\arraystretch}{1.3}
%%%
%%%\begin{tabularx}{1.0\textwidth}{|l|l|l|l|l|}
%%%\hline
%%%\texttt{O\_NONBLOCK} ? & bajtù k zápisu & nic nelze zapsat & èásteèný zápis
%%%mo¾ný & kompletní zápis mo¾ný \\
%%%\hline
%%%není & \texttt{<= PIPE\_BUF} & zablokuje se; kompletní zápis; atomické &
%%%zablokuje se; kompletní zápis; atomické & nezablokuje se; kompletní zápis;
%%%atomické \\
%%%\hline
%%%není & \texttt{> PIPE\_BUF} & zablokuje se; kompletní zápis; není atomické &
%%%zablokuje se; kompletní zápis; není atomické & mù¾e se zablokovat; kompletní
%%%zápis; není atomické \\
%%%\hline
%%%nastaven & \texttt{<= PIPE\_BUF} & \texttt{EAGAIN} & \texttt{EAGAIN} &
%%%nezablokuje se; kompletní zápis; atomické \\
%%%\hline
%%%nastaven & \texttt{> PIPE\_BUF} & \texttt{EAGAIN} & nezablokuje se; èásteèný
%%%zápis nebo \texttt{EAGAIN}; není atomické & nezablokuje se; kompletní,
%%%èásteèný zápis nebo \texttt{EAGAIN}; není atomické \\
%%%\hline
%%%\end{tabularx}
\end{itemize}

%%%%%

\pdfbookmark[1]{lseek}{lseek}

\begin{slide}
\sltitle{Setting file position: \texttt{lseek()}}
\texttt{off\_t \funnm{lseek}(int \emph{fildes}, off\_t \emph{offset},
int \emph{whence});}
\begin{itemize}
\item will reposition the file offset for reading and writing in an already
opened file associated with a file descriptor \emph{fildes}
\item based on value of \texttt{whence}, the file offset is set to:
    \begin{itemize}
    \item \texttt{SEEK\_SET} \dots{} the value of \emph{offset}
    \item \texttt{SEEK\_CUR} \dots{} current position plus \emph{offset}
    \item \texttt{SEEK\_END} \dots{} size of the file plus \emph{offset}
    \end{itemize}
\item returns the resulting offset (ie. from the file beginning)
\item \texttt{lseek(fildes, 0, SEEK\_CUR)} only returns the current file
position
\end{itemize}
\end{slide}

\begin{itemize}
\item \label{LSEEK} Poèítá se od 0, tj. offset 0 je první bajt souboru. Tam, kde
to má smysl, je mo¾né pro \texttt{offset} pou¾ít i záporné èíslo. Pøíklad:
\example{read/lseek.c}.


\item Lze se pøesunout i na pozici za koncem souboru. Pokud se pak
provede zápis, soubor se prodlou¾í a v pøeskoèené èásti budou samé
nuly (samotné \texttt{lseek} nestaèí). Nìkteré filesystémy takové
bloky celých nul pro úsporu místa neukládají.
\item Velikost souboru je mo¾né zjistit pomocí \texttt{lseek(fildes,
0, SEEK\_END)}.
\item Nejèastìj¹í operace s \texttt{lseek} jsou \emsl{tøi}: nastavení
konkrétní pozice od zaèátku souboru, nastavení pozice na konec
souboru a zji¹tìní aktuální pozice v souboru (0 spoleènì se
\texttt{SEEK\_CUR})
\item Pøi pou¾ití \texttt{lseek} se ¾ádné I/O neprovede, tj. ¾ádný pøíkaz
se nepo¹le na øadiè disku.
\item \texttt{lseek} nemusí slou¾it jen pro operace \texttt{read} a
\texttt{write}, ale také pro následnou operaci \texttt{lseek}
\item \label{BIG_FILE} Seekování a zápis mù¾e vést k problémùm se zálohami.
Pøíklad: \example{read/big-file.c} demonstruje, ¾e pøesun souboru s
"dírami" (tzv. sparse file) mù¾e vést k nárùstu velikosti souboru
co se týèe blokù alokovaných file systémem.
Chování zále¾í na kombinaci operaèního systému, archivního programu a
file systému (a jejich verzí). Nìkteré programy mají pøepínaèe, které
umo¾ní díry zachovat (napø. \texttt{dd} s \texttt{conv=sparse},
\texttt{tar} s \texttt{-S}, \texttt{rsync} s \texttt{--sparse}, atd.).


\item Pozor na pøehození parametrù. Druhá øádka samostatnì vypadá OK, ale má
pøehozené parametry. \texttt{SEEK\_SET} je navíc 0 a \texttt{SEEK\_CUR} je 1,
tak¾e vás to nikam neposune a nic ¹patného se nestane, a o to je hor¹í to pak
najít.
\begin{verbatim}
lseek(fd, 1, SEEK_SET)
lseek(fd, SEEK_SET, 1)
\end{verbatim}
\end{itemize}

%%%%%

\pdfbookmark[1]{truncate}{truncate}

\begin{slide}
\sltitle{Change file size: \texttt{truncate()}}
\texttt{int \funnm{truncate}(const char *\emph{path}, off\_t \emph{length});\\
int \funnm{ftruncate}(int \emph{fildes}, off\_t \emph{length});}
\begin{itemize}
\item causes the regular file to be truncated to a size of precisely
\emph{length} bytes.
\item if the file was larger than \emph{length}, the extra data is lost
\item if the file previously was shorter, it is extended, and the extended part
reads as null bytes
\end{itemize}
\end{slide}

\begin{itemize}
\item To truncate the file when opening it can be achieved via using the 
\texttt{O\_TRUNC} flag in \texttt{open}, see page \pageref{OPEN}.
\end{itemize}

%%%%%

\pdfbookmark[1]{dup, dup2}{dup}

\begin{slide}
\sltitle{Descriptor duplication: \texttt{dup()}, \texttt{dup2()}}
\texttt{int \funnm{dup}(int \emph{fildes});}
\begin{itemize}
\item creates a copy of the file descriptor \emph{fildes}, using the
lowest-numbered unused descriptor.  Returns the new descriptor.
\item same as \texttt{fcntl(fildes, F\_DUPFD, 0);} (will be later)
\end{itemize}
\texttt{int \funnm{dup2}(int \emph{fildes}, int \emph{fildes2});}
\begin{itemize}
\item duplicates \texttt{fildes} to \texttt{fildes2}. 
\item almost the same as\\
\texttt{close(fildes2);\\ fcntl(fildes, F\_DUPFD, fildes2);}
\end{itemize}
\end{slide}

\label{DUP_CALL}

\begin{itemize}
\item We already know that the first available file descriptor is used when
opening and creating file, see page \pageref{OPEN}.
\item The original and duplicated file descriptors share the same slot in the
system file table (see page \pageref{OPENFILETABLES}), ie. they share the file
position and read/write mode.
\item The equivalent for \texttt{dup2} is not fully equivalent.  If
\emph{fildes} is equal to \emph{fildes2}, \texttt{close(fildes2)} does not
happen and \texttt{dup2} returns \texttt{fildes2} right away.
\end{itemize}

%%%%%

\begin{slide}
\sltitle{Example: implement shell redirection}
\begin{itemize}
\item \verb#$ program < in > out 2>> err#
\end{itemize}
\begin{verbatim}
close(0);
open("in", O_RDONLY);
close(1);
open("out", O_WRONLY | O_CREAT | O_TRUNC, 0666);
close(2);
open("err", O_WRONLY | O_CREAT | O_APPEND, 0666);
\end{verbatim}
\begin{itemize}
\item \verb#$ program > out 2>&1#
\end{itemize}
\begin{verbatim}
close(1);
open("out", O_WRONLY | O_CREAT | O_TRUNC, 0666);
close(2);
dup(1);
\end{verbatim}
\end{slide}

\begin{itemize}
\item Note the flag \texttt{O\_APPEND} used to implement a redirection
\texttt{>>}.
\item \label{REDIRECT} Another example of \texttt{dup} use will be provided when
we start working with pipes.  The first redirection example from the slide
(without \texttt{stderr}) is in \example{read/redirect.c}.  The call
\texttt{execl} in that example replaces the current process image with the
program passed as the first argument.  We got ahead of ourselves here though, we
will learn about the \texttt{exec} calls on page \pageref{EXEC}.
\item To fully understand how redirection works it is good to draw the file
descriptor table for each step and where the slots point to.  For example, for
the 2nd example in the slide, we have the initial state, after \texttt{close(1)}
and \texttt{open("out", ...)}, and the final state, as follows:

\begin{verbatim}
+-------+              +-------+              +-------+
|   0   +-> stdin      |   0   +-> stdin      |   0   +-> stdin
+-------+              +-------+              +-------+
|   1   +-> stdout ==> |   1   +-> "out"  ==> |   1   +-> "out"
+-------+              +-------+              +-------+    /
|   2   +-> stderr     |   2   +-> stderr     |   2   +---' 
+-------+              +-------+              +-------+
\end{verbatim}

\item You need to pay attention to the state of descriptors.  The 2nd example
will not work if the descriptor 0 is already closed, as 
\texttt{open} returns 0 (the first available descriptor) and \texttt{dup} fails
while trying to duplicate an already closed descriptor.  Possible
solutions:

\begin{alltt}
close(1);
if((fd = open("out", O\_WRONLY | O\_CREAT | O\_TRUNC, 0666)) == 0)
        dup(0);
close(2);
dup(1);
if(fd == 0)
        close(0);
\end{alltt}

or

\begin{alltt}
fd = open("out", O\_WRONLY | O\_CREAT | O\_TRUNC, 0666);
if(fd != 1) \{
        dup2(fd, 1);
        close(fd);
\}
dup2(1, 2);
\end{alltt}
\end{itemize}

%%%%%

\pdfbookmark[1]{fcntl, ioctl}{fcntlioctl}

\begin{slide}
\sltitle{Manipulate file descriptors and devices: \texttt{fcntl()},
\texttt{ioctl()}} \texttt{int \funnm{fcntl}(int \emph{fildes}, int
\emph{cmd}, ...);}
\begin{itemize}
\item file descriptor duplication
\item setting descriptor and file status flags
\item advisory and possibly mandatory locking
\end{itemize}

\texttt{int \funnm{ioctl}(int \emph{fildes}, int \emph{request}, ... );}
\begin{itemize}
\item manipulates the underlying device parameters of special files
\item used as a universal interface for manipulating devices
\item each device defines a set of requests it understands
\end{itemize}
\end{slide}

\label{FCNTL}

\begin{itemize}
\item Example: close standard error output on program execution (exec call):\\
\texttt{fcntl(2, F\_SETFD, FD\_CLOEXEC);}
\item We will see later that descriptors are used for sockets as well, so it is
possible to use \texttt{fnctl} on them, for example to set a non-blocking
socket.  See page \pageref{CONNECT} for more information.
\item Values for \emph{cmd} in \texttt{fcntl}:
\begin{itemize}
\item \texttt{F\_DUPFD} \dots{} duplicate descriptors
\item \texttt{F\_GETFD} \dots{} get file descriptor flags.  \texttt{FD\_CLOEXEC}
is the only descriptor flag defined in SUSv4.
\item \texttt{F\_SETFD} \dots{} set file descriptor flags
\item \texttt{F\_GETFL} \dots{} get file opening flags (read/write, append,
\dots)
\item \texttt{F\_SETFL} \dots{} set file opening flags
(\texttt{O\_APPEND}, \texttt{O\_DSYNC}, \texttt{O\_NONBLOCK}, \texttt{O\_R\-SYNC},
and \texttt{O\_SYNC}).  Setting RO/RW is not allowed, and neither are flags for
creation, truncation, and exclusive access.
\item \texttt{F\_GETLK}, \texttt{F\_SETLK}, \texttt{F\_SETLKW} \dots{}
for file locking
\end{itemize}
\item Note that there are two kinds of flags.  Flags associated with the file
descriptor, having \texttt{FD} in the macro names (only one such exists --
\texttt{FD\_CLOEXEC}), and flags associated with the slot in the system file
table of opened files, having \texttt{FL} in the \texttt{fcntl} command macros
(ie. \texttt{F\_GETFL}).  See also the picture on page \pageref{OPENFILETABLES}.
\item Devices may support reading and writing using \texttt{read} and
\texttt{write}, and mapping files to memory (\texttt{mmap}, see page
\pageref{MMAP}), all other operations on devices (eg. setting parameters,
locking, or eject) are performed using the \texttt{ioctl} system call.
\item When setting flags, always get the present flags first.  Even when you
know the flags are zero, you never know how the code is modified in the future,
and what other flags are possibly added.  So, you should always use something
like the following when setting a new flag:

\begin{verbatim}
flags = fcntl(fd, F_GETFL);
if (fcntl(fd, F_SETFL, flags | O_APPEND) == -1)
  ...
\end{verbatim}

\dots similarly when removing a flag.
\end{itemize}

%%%%%

\pdfbookmark[1]{stat, fstat}{stat}

\begin{slide}
\sltitle{Get file status information: \texttt{stat()}}
\setlength{\baselineskip}{0.9\baselineskip}
\texttt{int \funnm{stat}(const char *\emph{path}, struct stat *\emph{buf});\\
int \funnm{fstat}(int \emph{fildes}, struct stat *\emph{buf});}
\begin{itemize}
\item for a file specified by a path or a file descriptor, returns a struct
containing file information, such as:
\begin{itemize}
\item \texttt{st\_ino} \dots{} i-node number
\item \texttt{st\_dev} \dots{} ID of device containing file
\item \texttt{st\_uid}, \texttt{st\_gid} \dots{} user/group ID of owner
\item \texttt{st\_mode} \dots{} file type and mode
\item \texttt{st\_size}, \texttt{st\_blksize}, \texttt{st\_blocks}
\dots{} total size in bytes, preferred blocksize for filesystem I/O, and number
of 512B blocks allocated
\item \texttt{st\_atime}, \texttt{st\_mtime}, \texttt{st\_ctime}
\dots{} time of last access, last modification, and last i-node modification
\item \texttt{st\_nlink} \dots{} number of hard links
\end{itemize}
\end{itemize}
\end{slide}

\begin{itemize}
\item You may be able to instruct the system not to update the file access time
when reading from a file, with granularity per file system.  This option is
useful on file systems where there are large numbers of files and performance is
more critical than updating the file access time (which is rarely ever
important).  It may also come in handy if your filesystem is on a medium with a
limited number of erase/write cycles -- a CompactFlash, for example.  If your
system supports it, it will be a \texttt{noatime} option for the \texttt{mount}
command.  See the manual page.
\item \emph{Metadata} is information about the file -- access mode, access
times, length, owner, group, etc.  Metadata does \emsl{not} include the file
data itself, neither the filename as the file data can be accesses through
several different hard links and those hardlinks are in the data of directories.
In other words, metadata is data about the actual file data.
\item Metadata can be read even when the process has not rights to read the file
data.
\item These functions do not provide file descriptor flags or flags from the
system file table.  These functions are about file information as stored on some
mountable media.
\item \texttt{st\_ctime} is not the creation time but the change time -- the
last modification of the inode.
\item The UNIX norm does not specify the ordering of the \texttt{struct stat}
members, neither it prohibits adding new.
\item \label{STAT} Example: \example{stat/stat.c}
\item You can call \texttt{fstat} on file descriptors 0,1,2 as well.  Unless
redirected before, you will get information on the underlying terminal device
(eg. \texttt{/dev/ttys011} on macOS).  Example: \example{stat/stat012.c}.
\end{itemize}


%%%%%

\pdfbookmark[1]{lstat}{lstat}

\begin{slide}
\sltitle{Get file status information (2)}
\begin{itemize}
\item for a file type, in \texttt{<sys/stat.h>} there are
constants \verb#S_IFMT# (bit mask for the file type bit field), \verb#S_IFBLK#
(block device), \verb#S_IFCHR# (character device), \verb#S_IFIFO#
(FIFO), \verb#S_IFREG# (regular), \verb#S_IFDIR# (directory),
\verb#S_IFLNK# (symlink). 
\item macros for file type checking: \verb#S_ISBLK(m)#,
\verb#S_ISCHR(m)#, \verb#S_ISFIFO(m)#, \verb#S_ISREG(m)#,
\verb#S_ISDIR(m)#, and \verb#S_ISLNK(m)#. 
\item access right masks: \verb#S_IRUSR# (owner has read permission),
\verb#S_IWGRP# (group has write permission), etc.
\end{itemize}
\texttt{int \funnm{lstat}(const char *\emph{path}, struct stat
*\emph{buf});}
\begin{itemize}
\item if \emph{path} is a symlink, \texttt{stat()} returns informace on the file
the symlink refers to. This function returns information about the link itself.
\end{itemize}
\end{slide}

\begin{itemize}
\item typ a práva souboru jsou ulo¾ena spoleènì v \verb#st_mode#,
proto existují zmi\-òo\-va\-ná makra.
\item S\_IFMT specifikuje tu èást bitù, které jsou vìnované typu
souboru, makra pro jednotlivé typy pak nejsou masky, ale hodnoty,
tak¾e test na typ souboru je nutné udìlat takto:
\texttt{(st\_mode~\&~S\_IFMT~==~S\_IFREG)}. V¹echna makra jsou v
normì, tak¾e jejich pou¾íváním zaruèíme pøenositelný kód.
\item Pøíklad: \example{stat/filetype.c}
\end{itemize}


%%%%%

\pdfbookmark[1]{utime}{utime}

\begin{slide}
\sltitle{Setting file times}
\texttt{int \funnm{utime}(const char *\emph{path},
const struct utimbuf *\emph{times});}
\begin{itemize}
\item changes file last access and modification times
\item cannot change i-node access time (ctime)
\item calling process must have write permission for the file
\end{itemize}
\end{slide}

\begin{itemize}
\item Tuto funkci pou¾ívají hlavnì kopírovací a archivaèní programy,
aby zajistily stejné èasy kopie a originálu (napø. \texttt{tar} nebo
\texttt{rsync}). 
\item Shellové rozhraní pro funkci \texttt{utime} pøedstavuje pøíkaz
\texttt{touch}. Mìnit takto èas modifikace i-uzlu ale nelze.
\end{itemize}


%%%%%

\pdfbookmark[1]{link, unlink, rename}{link}

\begin{slide}
\sltitle{File name manipulations}
\texttt{int \funnm{link}(const char *\emph{path1}, const char *\emph{path2});}
\begin{itemize}
\item creates a new link (aka hard link), ie. a directory entry, named
\emph{path2} to file \emph{path1}.  Hard links cannot span filesystems (use
\funnm{symlink} for that).
\end{itemize}
\texttt{ int \funnm{unlink}(const char *\emph{path});}
\begin{itemize}
\item deletes a name (ie. a directory entry) and after deleting the last link to
the file and after closing the file by all processes, delete the file data.
\end{itemize}
\texttt{int \funnm{rename}(const char *\emph{old}, const char *\emph{new});}
\begin{itemize}
\item change the file name (ie. one specific link) from \emph{old} to
\emph{new}.  Works within the same filesystem only.
\end{itemize}
\end{slide}

\begin{itemize}
\item opìt zdùrazòuji, ¾e \emsl{u{}nix nemá volání typu delete na soubory}.
Po\-drob\-nì\-ji viz strana \pageref{FILEDELETE}.
\item volání \texttt{link} vytváøí hardlinky, tj. zobrazení ze
jména souboru na èíslo i-uzlu. Èísla i-uzlù jsou jednoznaèná pouze v
rámci svazku, proto pro linky mezi filesystémy je nutné pou¾ít
symlinky.
\item parametr \texttt{path2} nesmí existovat, tedy nelze takto
pøejmenovávat
\item \texttt{unlink} nefunguje na adresáøe
\item shellový pøíkaz \texttt{mv} pou¾ívá \texttt{rename} pro
pøesuny v rámci jednoho svazku. Pøesun souboru mezi filesystémy
vy¾aduje nejprve soubor zkopírovat a pak smazat originál voláním
\texttt{unlink}.
\item \texttt{rename} funguje nad symlinky, ne nad soubory, na
které symlink ukazuje
\item existuje i volání \texttt{remove}, viz strana \pageref{REMOVE}.
\end{itemize}


%%%%%

\pdfbookmark[1]{symlink, readlink}{symlink}

\begin{slide}
\sltitle{Symbolic links}
\texttt{int \funnm{symlink}(const char *\emph{path1},
const char *\emph{path2});} 
\begin{itemize}
\item make a new symbolic name from \emph{path2} $\rightarrow$ \emph{path1}.
\item \emph{path1} may span filesystems, and may not exist at all
\end{itemize}
\texttt{int \funnm{readlink}(const char *\emph{path}, char *\emph{buf},
size\_t \emph{bufsz});} 
\begin{itemize}
\item put maximum of \emph{bufsz} bytes from the symlink target path to
\emph{buf}
\item returns the number of bytes written to \emph{buf}. 
\item \emph{buf} is \emsl{not} terminated by \verb#'\0'#
\end{itemize}
\end{slide}

\begin{itemize}
\item Shellový pøíkaz \texttt{ln} volá \texttt{symlink} nebo
\texttt{link}, podle toho, jestli je pou¾it pøe\-pí\-naè \texttt{-s}
nebo ne.
\item Smazání hardlinku nesma¾e soubor, pokud na nìj vede je¹tì jiný
hardlink. Naopak soubor (polo¾ku adresáøe i data) je mo¾né smazat, i
kdy¾ na nìj ukazují nìjaké symlinky.
\item \texttt{readlink} je pou¾itelný v situaci, pokud chci
smazat soubor, na který daný symlink ukazuje
\item \texttt{bufsize} se typicky dává o 1 men¹í ne¾ velikost
bufferu, to pro ukonèení znakem \verb#'\0'#
\end{itemize}

%%%%%

\pdfbookmark[1]{mkdir, rmdir, opendir, readdir, closedir}{dirfncs}

\begin{slide}
\sltitle{Working with directories}
\texttt{int \funnm{mkdir}(const char *\emph{path}, mode\_t \emph{mode});}
\begin{itemize}
\item attempts to create an empty directory \emph{path} with entries
'\texttt{.}' a '\texttt{..}' 
\end{itemize}
\texttt{int \funnm{rmdir}(const char *\emph{path});}
\begin{itemize}
\item deletes directory \emph{path}.  The directory \emsl{must} be empty.
\end{itemize}
\texttt{DIR *\funnm{opendir}(const char *\emph{dirname});\\
struct dirent *\funnm{readdir}(DIR *\emph{dirp});\\
int \funnm{closedir}(DIR *\emph{dirp});}
\begin{itemize}
\item sequentially reads directory entries
\item structure \texttt{dirent} contains:
    \begin{itemize}
    \item \verb#d_ino# \dots{} i-node number
    \item \verb#d_name# \dots{} file name
    \end{itemize}
\end{itemize}
\end{slide}

\begin{itemize}
\item Polo¾ky adresáøe nejsou nijak uspoøádány, \texttt{readdir} je mù¾e vracet
v libovolném poøadí. V pøípadì chyby se vrací NULL jako pøedtím a \texttt{errno}
je nastaveno. Konec adresáøe se signalizuje tím, ¾e \texttt{readdir} vrátí NULL
a \texttt{errno} není zmìnìno.
\item \texttt{readdir} je stavová funkce. Pro vrácení se na zaèátek je mo¾né
pou¾ít funkci \texttt{rewinddir}. Pokud tuto funkci voláte z více vláken je
nutné pou¾ívat reentrantní \texttt{readdir\_r}, proto¾e struktura
\texttt{dirent} je statická.
\item V nìkterých implementacích (napø. FreeBSD) lze adresáø otevøít pro ètení
(ne pro zápis) jako normální soubor a èíst ho pomocí \texttt{read}, ale je tøeba
znát jeho vnitøní organizaci. Proto je \texttt{readdir} pro zpracování obsahu
adresáøe lep¹í ne¾ \texttt{read}, který vrací raw data adresáøe. Kromì toho,
norma nevy¾aduje, aby adresáø bylo mo¾né èíst funkcí \texttt{read}, Linux to
napøíklad nedovolí.
\item \texttt{d\_ino} není moc u¾iteèné, proto¾e v pøípadì, kdy daný adresáø je
mount point, tak ukazuje na adresáø, na který je dal¹í filesystém namontován, ne
na koøen namontovaného filesystému
\item \label{D_TYPE} Nìkteré systémy mají ve struktuøe \texttt{dirent} polo¾ku
\texttt{d\_type}. Ta mù¾e nabývat hodnot \texttt{DT\_REG}, \texttt{DT\_DIR},
\texttt{DT\_FIFO} atd., viz manuálová stránka pro \texttt{dirent}. Byla to vìc
specifická pro BSD a následnì pøevzatá i jinými systémy, na\-pøí\-klad Linuxem.
Není to souèástí normy a tedy to \emsl{není pøenositelné.} Pøe\-no\-si\-tel\-ný
zpùsob je na ka¾dou polo¾ku zavolat \texttt{stat}.
\item \texttt{rmdir} nefunguje na neprázdný adresáø, musíte sami smazat jeho
obsah pøed smazáním adresáøe. Nìkdy lze v kódu nalézt zoufalé pokusy typu
\texttt{system("rm -r xxx")} co¾ má svoje nevýhody (napø. závislost programu
na shellu. Dále pozor na sanitizaci promìnných prostøedí a jména adresáøe).
\item \label{REMOVE} Norma specifikuje i volání \texttt{remove}, které se chová
jako \texttt{unlink} pro regulární soubory, a jako \texttt{rmdir} pro adresáøe.
\end{itemize}


%%%%%

\begin{slide}
\sltitle{Example: read a directory}
\begin{alltt}
int main(int argc, char *argv[])
\{
    DIR *d;
    struct dirent *de;

    for(int i = 1; i < argc; i++) \{
        d = \emprg{opendir}(argv[i]);
        while(de = \emprg{readdir}(d))
            printf("%s\bs{}n", de->d_name);
        \emprg{closedir}(d);
    \} 
    return (0);
\}
\end{alltt}
\end{slide}

\begin{itemize}
\item pøíkaz \texttt{ls} je zalo¾en na takovéto smyèce, navíc
provádí napø. tøídìní jmen souborù a zji¹»ování dal¹ích informací
pomocí \texttt{stat}.
\item konec adresáøe se pozná tak, ¾e \texttt{readdir} vrátí
\texttt{NULL}. To v¹ak vrátí i v pøípadì, pokud nastala chyba. V
takovém pøípadì je kód chyby v promìnné \texttt{errno}, v pøípadì
prvním je \texttt{errno} nezmìnìna. Proto by \texttt{errno} mìlo být
v¾dy nastavené na nulu pøed voláním \texttt{readdir}. V pøíkladu
tomu tak není, proto¾e z dùvodu málo místa nekontrolujeme
\texttt{errno} vùbec.
\item pøíklad: \example{readdir/readdir.c}
\end{itemize}

%%%%%

\pdfbookmark[1]{chdir, fchdir, getcwd}{pwd}

\begin{slide}
\sltitle{Change working directory}
\begin{itemize}
\item every process has its current working directory.  When a process refers to
a file using a relative path, the reference is interpreted relative to the
current working directory of the process.
\item the working directory is inherited from the process parent
\end{itemize}
\texttt{int \funnm{chdir}(const char *\emph{path});}\\
\texttt{int \funnm{fchdir}(int \emph{fildes});}
\begin{itemize}
\item changes working directory for the process
\end{itemize}
\texttt{char *\funnm{getcwd}(char *\emph{buf}, size\_t \emph{size});}
\begin{itemize}
\item stores the absolute path to the current working directory to \emph{buf},
its \emph{size} must be at least one byte longer than the path length.
\end{itemize}
\end{slide}

\begin{itemize}
\item funkci \texttt{fchdir} se pøedává deskriptor získaný voláním
\texttt{open} na adresáø.
\item funkce \texttt{getcwd} mù¾e vrátit jinou cestu ne¾ tu, po které jsme
se do ak\-tu\-ál\-ní\-ho adresáøe dostali, jesli¾e èást cesty v
\texttt{chdir} byl symlink nebo do¹lo k pøesunu (pøejmenování) nìkterého
adresáøe na cestì od koøene. U souèasných u{}nixù by se to ale u¾ stát nemìlo.
\item na vìt¹inì moderních unixových systémù existuje funkce \texttt{chroot},
která u\-mo¾\-òu\-je zmìnit koøenový adresáø volajícího procesu na daný
adresáø. Je èasto pou¾ívaná v implementací serverù k omezení pøístupu
pouze na daný podstrom file systému (napø. FTP servery).
Pokud se pou¾ívá pro zapezpeèení, vy¾aduje to zvlá¹tní opatrnost,
proto¾e existují cesty jak se dostat do pù\-vod\-ní\-ho stromu.
Pokud je nutné z chroot prostøedí spou¹tìt programy, nastávají dal¹í
komplikace s nutností replikace kritických systémových souborù do chroot
prostøedí (pokud není program upraven aby mìl v¹e zabudované v sobì).
Tato funkce není souèástí aktuální verze standardu (POSIX 1003.1-2008).
\begin{itemize}
\item dal¹í, mnohem obecnìj¹í, zpùsoby izolace procesù se dají nalézt v
unixových systémech (jails v FreeBSD, zones v Solarisu, sandboxing v Mac
OS X). Zpravidla se velmi li¹í tím jaké hranice doká¾í vytyèit, k èemu
jsou urèeny, zpùsobem administrace, \ldots.
\end{itemize}
\end{itemize}

%%%%%

\pdfbookmark[1]{access}{access}

\begin{slide}
\sltitle{Check permissions for access: \texttt{access()}}
\texttt{int \funnm{access}(const char *\emph{path}, int \emph{amode});}
\begin{itemize}
\item checks whether the calling process can access the file \emph{path}
\item \emph{amode} is an OR-combination of contants 
    \begin{itemize}
    \item \verb#R_OK# \dots{} read permission test
    \item \verb#W_OK# \dots{} write permission test
    \item \verb#X_OK# \dots{} execution permission test
    \item \verb#F_OK# \dots{} file existence test
    \end{itemize}
\item in contrast to \texttt{stat()}, the result depends on the process's RUID
and RGID
\item \emsl{never use this call, it cannot be used in a safe way.  See the notes
below.}
\end{itemize}
\end{slide}

\begin{itemize}
\item Volání \texttt{access} aplikuje mechanismus testování pøístupových práv k
zadanému souboru pro volající proces a vrátí výsledek.
\item Funkce \texttt{access} volání byla pro setuid proces, aby si mohl ovìøit,
zda u¾ivatel bì¾ící daný setuid proces by mìl za normálních okolností k
pøíslu¹nému souboru pøístup. Z toho vyplývá, ¾e toto volání je \emsl{security
hole} -- mezi testem a následnou akcí se soubor mù¾e zmìnit tøeba tak, ¾e
pùvodní (mùj) soubor sma¾u a vytvoøím symbolický link se stejným jménem na
soubor, ke kterému bych jinak nemìl pøístup. Toto proces nemù¾e nikdy o¹etøit,
tak¾e vesele zmodifikuje soubor, který bych jako u¾ivatel nikdy nemohl zmìnit.
Správným øe¹ením je vrátit se zpátky k reálným UID/GID a pøístup rovnou
vyzkou¹et. Pokud napøíklad daný soubor otevøeme, u¾ nám ho nikdo pod rukama
``nevymìní''.
\end{itemize}


%%%%%

\pdfbookmark[1]{chmod, chown}{chmodchown}

\begin{slide}
\sltitle{Setting file permissions}
\texttt{int \funnm{chmod}(const char *\emph{path}, mode\_t \emph{mode});}
\begin{itemize}
\item changes permissions of file \emph{path} to \emph{mode}.
\item can be used by the file owner or root
\end{itemize}
\texttt{int \funnm{chown}(const char *\emph{path}, uid\_t \emph{owner},
gid\_t \emph{group});}
\begin{itemize}
\item changes file owner and group for \emph{path}.  Value of
\texttt{-1} means do not change that ID.
\item only root change change owners so that users could not work around quotas
to disown their files
\item a regular user can change a group of files he/she owns, and must belong to
the target group
\end{itemize}
\end{slide}

\begin{itemize}
\item parametr \texttt{mode} zde samozøejmì neobsahuje typ souboru,
jako tomu je na\-pøí\-klad u volání \texttt{stat}. Hodnoty
\texttt{mode} viz \texttt{chmod}(2).
\item pokud nejsem vlastník, nemohu celkem logicky zmìnit mód ani u
souboru s nastaveným pøístupem \texttt{rw-rw-rw-}
\item v nìkterých implementacích mù¾e vlastník souboru pøedat
vlastnictví nì\-ko\-mu jinému, napø. v IRIXu je chování \texttt{chown}
nastavitelné jako parametr jádra.
\item není bì¾né volat funkci \texttt{chmod} z u¾ivatelských
aplikací, na to se pou¾ívají flagy u volání \texttt{open}, hlavní
pou¾ití je v aplikaci \texttt{chmod(1)}
\end{itemize}

\endinput
